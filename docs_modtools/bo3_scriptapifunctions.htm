<HTML>warning: can't match cpp function  (for GetCycleOriginOffset) in project; skipping
<H1>void ActivateClientExploder(<I>&lt;exploder id&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;exploder id&gt; id of exploder to activate</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Activates a client side exploderThis is sent as a reliable command, and will not work with killcam or demos.<BR><B>EXAMPLE:  </B>ActivateClientExploder( 101 )<BR></OL><P>
<HR><H1>void ActivateClientRadiantExploder(<I>&lt;exploder id&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;exploder id&gt; string id of exploder to activate</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Activates a client side radiant exploder<BR><B>EXAMPLE:  </B>ActivateClientRadiantExploder( "light_switch" )<BR></OL><P>
<HR><H1>void &lt;actor&gt; ActorIKEnabled()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Determines whether this actor can use IK functions. Returns true if IK is available, otherwise false.<BR><B>EXAMPLE:  </B>if (guy ActorIKEnabled()) ...<BR></OL><P>
<HR><H1>void AddAwarenessIndicator(<I>&lt;pos&gt;</I>,<I>&lt;material&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;pos&gt; awareness location<LI>        <B>[MANDATORY]</B>  &lt;material&gt; awareness material</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Draw an awareness indicator<BR><B>EXAMPLE:  </B>AddAwarenessIndicator(ai.origin, "hit_material_green" )<BR></OL><P>
<HR><H1>void &lt;player&gt; AddBonusCardStat(<I>&lt;bonuscard&gt;</I>,<I>&lt;statname&gt;</I>,<I>&lt;statincrease&gt;</I>,<I>&lt;currentclassnum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;bonuscard&gt; Bonus Card define from _bonuscards.gsh<LI>        <B>[MANDATORY]</B>  &lt;statname&gt; The name of the stat you wish to set<LI>        <B>[MANDATORY]</B>  &lt;statincrease&gt; The amount you would like to increase the stat<LI>        <B>[MANDATORY]</B>  &lt;currentclassnum&gt; The loadout the player is using</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the indicated stat for that bonus card<BR><B>EXAMPLE:  </B>self AddBonusCardStat( BONUSCARD_OVERKILL, "kills", 1, self.class_num )<BR></OL><P>
<HR><H1>void AddDemoBookmark(<I>&lt;type&gt;</I>,<I>&lt;time&gt;</I>,<I>&lt;client1&gt;</I>,<I>&lt;client2&gt;</I>,<I>&lt;scoreEventPriority&gt;</I>,<I>&lt;entityNumber&gt;</I>,<I>&lt;eType&gt;</I>,<I>&lt;birthTime&gt;</I>,<I>&lt;overrideEntityCamera&gt;</I>,<I>[actorEntityNumber]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;type&gt; the type of bookmark<LI>        <B>[MANDATORY]</B>  &lt;time&gt; the time of recording the bookmark<LI>        <B>[MANDATORY]</B>  &lt;client1&gt; the client related to the bookmark<LI>        <B>[MANDATORY]</B>  &lt;client2&gt; other client which is associated with the bookmark<LI>        <B>[MANDATORY]</B>  &lt;scoreEventPriority&gt;<LI>        <B>[MANDATORY]</B>  &lt;entityNumber&gt; The entity number<LI>        <B>[MANDATORY]</B>  &lt;eType&gt; Entity type<LI>        <B>[MANDATORY]</B>  &lt;birthTime&gt; Birth Time<LI>        <B>[MANDATORY]</B>  &lt;overrideEntityCamera&gt; Whether to override Entity Camera<LI>        <B>[OPTIONAL]</B>  [actorEntityNumber]</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>adds the information to the demo bookmarking system<BR><B>EXAMPLE:  </B>AddDemoBookmark( bookmark_string, gettime(), self GetEntityNumber(), 255, 0, inflictorEntNum, inflictorEntType, inflictorBirthTime, false, self.grenade_multiattack_ent GetEntityNumber() )<BR></OL><P>
<HR><H1>void AddEntityInfluencer(<I>&lt;name&gt;</I>,<I>&lt;entity&gt;</I>,<I>&lt;team mask&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; valid spawn influencer preset name.<LI>        <B>[MANDATORY]</B>  &lt;entity&gt; Attached to entity.  Goes away when entity is deleted. Unless a time is set.<LI>        <B>[MANDATORY]</B>  &lt;team mask&gt; teams that this influencer will affect</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Adds a new influencer of &lt;name&gt; attached to &lt;entity&gt<BR><B>EXAMPLE:  </B>influencer_id = AddEntityInfluencer( name, player, allies_mask )<BR></OL><P>
<HR><H1>void &lt;player&gt; AddFriendlyScrambler(<I>&lt;x&gt;</I>,<I>&lt;y&gt;</I>,<I>&lt;handle&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;x&gt; X coord (float)<LI>        <B>[MANDATORY]</B>  &lt;y&gt; Y coord (float)<LI>        <B>[MANDATORY]</B>  &lt;handle&gt; will be used to remove the scrambler (integer)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Adds new friendly scrambler to the compass<BR><B>EXAMPLE:  </B>player AddFriendlyScrambler( scrambler.origin[0], scrambler.origin[1], scrambler.handle )<BR></OL><P>
<HR><H1>void AddInfluencer(<I>&lt;name&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;team mask&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; valid spawn influencer preset name.<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; center point of the influencer<LI>        <B>[MANDATORY]</B>  &lt;team mask&gt; teams that this influencer will affect</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Adds a new influencer of &lt;name&gt; at &lt;origin&gt<BR><B>EXAMPLE:  </B>influencer_id = AddInfluencer( name, origin, allies_mask )<BR></OL><P>
<HR><H1>void AddOrientedInfluencer(<I>&lt;name&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;angles&gt;</I>,<I>&lt;team mask&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; valid spawn influencer preset name.<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; center point of the influencer<LI>        <B>[MANDATORY]</B>  &lt;angles&gt; angles of entity<LI>        <B>[MANDATORY]</B>  &lt;team mask&gt; teams that this influencer will affect</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Adds a new influencer of &lt;name&gt; at &lt;origin&gt; and &lt;angles&gt<BR><B>EXAMPLE:  </B>influencer_id = AddOrientedInfluencer( name, origin, angles, allies_mask )<BR></OL><P>
<HR><H1>void &lt;player&gt; AddSensorGrenadeArea(<I>&lt;position&gt;</I>,<I>&lt;handle&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; origin<LI>        <B>[MANDATORY]</B>  &lt;handle&gt; will be used to remove the sensor</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Adds new sensor grenade radius indicator to the compass<BR><B>EXAMPLE:  </B>player AddSensorGrenadeArea( sensor.origin, sensor.handle )<BR></OL><P>
<HR><H1>void AddSpawnPoints(<I>&lt;team&gt;</I>,<I>&lt;parentID&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; The team<LI>        <B>[MANDATORY]</B>  &lt;parentID&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Adds spawnpoints to the spawn system<BR><B>EXAMPLE:  </B>AddSpawnPoints( "allies", "mp_tdm_spawn" )<BR></OL><P>
<HR><H1>entity AddTestClient()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Adds a test client to the map and returns a reference to that client.<BR><B>EXAMPLE:  </B>ent[i] = AddTestClient()<BR></OL><P>
<HR><H1>void AddToInterestPool(<I>&lt;value&gt;</I>,<I>&lt;priority&gt;</I>,<I>&lt;lifespan&gt;</I>,<I>&lt;point of interest&gt;</I>,<I>&lt;originator&gt;</I>,<I>[unique]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;value&gt; Amount the event adds to the pool. (integer)<LI>        <B>[MANDATORY]</B>  &lt;priority&gt; How important is the event. (integer)<LI>        <B>[MANDATORY]</B>  &lt;lifespan&gt; Time the event stays in the pool. (float)<LI>        <B>[MANDATORY]</B>  &lt;point of interest&gt; Position the AI will investigate. (vector3)<LI>        <B>[MANDATORY]</B>  &lt;originator&gt; Entity that caused the event.<LI>        <B>[OPTIONAL]</B>  [unique] Only one of this type can exist in the pool. (integer)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Add a script event to the sentient's interest pool.<BR><B>EXAMPLE:  </B>point = self AddToInterestPool( 500, 10, 5, ai.origin, ai )<BR></OL><P>
<HR><H1>void AddZombieBoxWeapon(<I>&lt;weapon&gt;</I>,<I>&lt;weaponModelName&gt;</I>,<I>&lt;isDualWield&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to add<LI>        <B>[MANDATORY]</B>  &lt;weaponModelName&gt; The model name of the weapon<LI>        <B>[MANDATORY]</B>  &lt;isDualWield&gt; True if the weapon is dual wield, false otherwise</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Adds a zombie box weapon<BR><B>EXAMPLE:  </B>AddZombieBoxWeapon( weapon, weapon.worldModel, weapon.isDualWield )<BR></OL><P>
<HR><H1>void &lt;actor&gt; AimAtEntityIK(<I>[otherguy]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [otherguy] the other guy to aim at</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set this actor to aim at the specified entity. Call this function without any entity specified to turn it off.<BR><B>EXAMPLE:  </B>guy AimAtEntityIK( otherguy )<BR></OL><P>
<HR><H1>void &lt;actor&gt; AimAtPosIK(<I>[pos]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [pos] the position to aim at</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set this actor to aim at the specified position. Call this function without any position specified to turn it off.<BR><B>EXAMPLE:  </B>guy AimAtPosIK( pos )<BR></OL><P>
<HR><H1>void AimingAtFriendly()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if localclient 0 has crosshairs on friendly<BR><B>EXAMPLE:  </B>isFriend = AimingAtFriendly()<BR></OL><P>
<HR><H1>void AllClientsPrint(<I>&lt;string&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string&gt; the string to print</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Cause all clients to print the localized version of this string.<BR><B>EXAMPLE:  </B>AllClientsPrint( "Game Complete" )<BR></OL><P>
<HR><H1>void AllocateSoundRandoms(<I>&lt;num randoms&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;num randoms&gt; number of randoms</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Allocate a pool of random sounds<BR><B>EXAMPLE:  </B>AllocateSoundRandoms(randoms.size - nScriptThreadedRandoms)<BR></OL><P>
<HR><H1>void AllowActionSlotInput(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the controller you to enable the action slots</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>always allow action slot input<BR><B>EXAMPLE:  </B>AllowActionSlotInput(localclientnum)<BR></OL><P>
<HR><H1>void &lt;actor_or_player&gt; AllowedStances(<I>&lt;stance&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;stance&gt; (string) A stance, can be 'prone', 'crouch', 'stand'. Any number of stances may be added.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the list of the actor's allowed stances.<BR><B>EXAMPLE:  </B>self AllowedStances( "crouch", "prone" )<BR></OL><P>
<HR><H1>void AllowRoundAnimation(<I>&lt;flag&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flag&gt; 1 to allow, 0 to disallow</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>sets the allow round animation flag to enabled or disabled<BR><B>EXAMPLE:  </B>AllowRoundAnimation( 1 )<BR></OL><P>
<HR><H1>void AllowScoreboard(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the controller you to enable the action slots</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>allow scoreboard or not<BR><B>EXAMPLE:  </B>AllowScoreboard(localclientnum)<BR></OL><P>
<HR><H1>void &lt;entity&gt; AllowTacticalInsertion(<I>&lt;allow&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;allow&gt; true or false</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>If false, disallows tactical insertions in the bounding area of this entity. Allows tactical insertions otherwise<BR><B>EXAMPLE:  </B>my_trigger AllowTacticalInsertion( false )<BR></OL><P>
<HR><H1>void AllWeaponAttachmentsUnlocked(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; weapon</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Are all the weapon attachments unlocked for this weapon?<BR><B>EXAMPLE:  </B>player AllWeaponAttachmentsUnlocked( weapon )<BR></OL><P>
<HR><H1>void AnimHasNotetrack(<I>&lt;animation&gt;</I>,<I>&lt;note track&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; an animation<LI>        <B>[MANDATORY]</B>  &lt;note track&gt; a constant string with the name of the note track</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>queries the given animation for a note track<BR><B>EXAMPLE:  </B>if ( IsDefined( facialanim ) && AnimHasNotetrack( facialanim, "dialogue" ) ) ...<BR></OL><P>
<HR><H1>void &lt;actor&gt; AnimMappingSearch(<I>&lt;animation_alias_name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation_alias_name&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Searches animation mapping table to return a animation name when given a animation mapping alias name.<BR><B>EXAMPLE:  </B>self AnimMappingSearch("anim_arrive_cover_left_crouch")<BR></OL><P>
<HR><H1>void &lt;entity&gt; AnimRelative(<I>&lt;notify&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;angles&gt;</I>,<I>&lt;animation&gt;</I>,<I>[mode]</I>,<I>[root]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;notify&gt; The notify to send<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The starting position of the anim script<LI>        <B>[MANDATORY]</B>  &lt;angles&gt; The starting angle of the anim script<LI>        <B>[MANDATORY]</B>  &lt;animation&gt; The animation<LI>        <B>[OPTIONAL]</B>  [mode] Valid modes are "normal" and "deathplant"<LI>        <B>[OPTIONAL]</B>  [root] The root animation</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Runs an animscript on an entity.<BR><B>EXAMPLE:  </B>driver AnimRelative( "germantruck_driver_closedoor", org , angles, driver.closedooranim )<BR></OL><P>
<HR><H1>void &lt;entity&gt; AnimScripted(<I>&lt;notify&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;angles&gt;</I>,<I>&lt;animation&gt;</I>,<I>[mode]</I>,<I>[root]</I>,<I>[rate]</I>,<I>[blend]</I>,<I>[lerp]</I>,<I>[animation time]</I>,<I>[is_scene_animation]</I>,<I>[showPlayerWeaponInFirstPerson]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;notify&gt; The notify to send<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The starting position of the anim script<LI>        <B>[MANDATORY]</B>  &lt;angles&gt; The starting angle of the anim script<LI>        <B>[MANDATORY]</B>  &lt;animation&gt; The animation<LI>        <B>[OPTIONAL]</B>  [mode] Valid modes are "normal" and "deathplant"<LI>        <B>[OPTIONAL]</B>  [root] The root animation<LI>        <B>[OPTIONAL]</B>  [rate] The playback rate of animation<LI>        <B>[OPTIONAL]</B>  [blend] The blend time for the animation<LI>        <B>[OPTIONAL]</B>  [lerp] The lerp time for an aligned animation<LI>        <B>[OPTIONAL]</B>  [animation time] The starting animation time in 0-1 range<LI>        <B>[OPTIONAL]</B>  [is_scene_animation] Should be true for player scene animations or scripted animations where the player has no control, can be ignored for non-players<LI>        <B>[OPTIONAL]</B>  [showPlayerWeaponInFirstPerson] determines if the first person player should have his weapon during cinematics</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Runs an animscript on an entity.<BR><B>EXAMPLE:  </B>driver AnimScripted( "germantruck_driver_closedoor", org , angles, driver.closedooranim )<BR></OL><P>
<HR><H1>void Announcement(<I>&lt;string&gt;</I>,<I>&lt;duration&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string&gt; The announcement.<LI>        <B>[MANDATORY]</B>  &lt;duration&gt; How long, in seconds, to display the announcement.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sends an announcement to all clients.<BR></OL><P>
<HR><H1>void &lt;entity&gt; ApplyBallisticTarget(<I>&lt;targetPos&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;targetPos&gt; The position to launch the vehicle towards</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Launch a vehicle with just enough force at a target.<BR><B>EXAMPLE:  </B>dropRaps ApplyBallisticTarget( (50,50,10) )<BR></OL><P>
<HR><H1>void &lt;player&gt; AreAllMissionsAtScore(<I>&lt;score&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;score&gt; A score that all missions must be at to return true (integer)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if all missions are at the score specified<BR><B>EXAMPLE:  </B>is_score_achieved = self AreAllMissionsAtScore( 10000 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; AreMeshesStreamed()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if this entity's meshes are streamed in<BR><B>EXAMPLE:  </B>thing areMeshesStreamed()<BR></OL><P>
<HR><H1>void arenagetcurrentseason()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the current arena season<BR><B>EXAMPLE:  </B>ArenaGetCurrentSeason()<BR></OL><P>
<HR><H1>void ArenaGetSlot()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the current arena slot<BR><B>EXAMPLE:  </B>ArenaGetSlot()<BR></OL><P>
<HR><H1>void AreTexturesLoaded()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check to see if start-of-level textures are loaded - if they're not, the streamer forces a black screen.<BR><B>EXAMPLE:  </B>while( !areTexturesLoaded() ) { wait(0.05); }<BR></OL><P>
<HR><H1>void &lt;entity&gt; AreTexturesStreamed()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if this entity's textures are streamed in<BR><B>EXAMPLE:  </B>thing areTexturesStreamed()<BR></OL><P>
<HR><H1>void ArraySort(<I>&lt;array&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;max&gt;</I>,<I>&lt;range&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;array&gt; array to sort<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; the origin from which to compare<LI>        <B>[OPTIONAL]</B>  [closest] if set to true the array will be sorted by distance closest to &lt;origin&gt;, if false by distance farthest from &lt;origin&gt;<LI>        <B>[OPTIONAL]</B>  [max] if set then only the first &lt;max&gt; count of entities will be returned<LI>        <B>[OPTIONAL]</B>  [range] if set then only the entities within &lt;range&gt; will be considered</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns a sorted array of entities by closest or farthest distance from &lt;origin&gt<BR></OL><P>
<HR><H1>void ArraySortClosest(<I>&lt;array&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;max&gt;</I>,<I>&lt;minDist&gt;</I>,<I>[maxDist]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;array&gt; array to sort<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; the origin from which to compare<LI>        <B>[OPTIONAL]</B>  [&lt;maxReturnCount] if set then only the first &lt;max&gt; count of entities will be returned<LI>        <B>[OPTIONAL]</B>  [minDist] if set then only the entities further than &lt;minDist&gt; will be considered<LI>        <B>[OPTIONAL]</B>  [maxDist] if set then only the entities closer then &lt;maxDist will be considered</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns a sorted array of entities by closest from &lt;origin&gt<BR></OL><P>
<HR><H1>void ArtilleryIconLocation(<I>&lt;position&gt;</I>,<I>&lt;teamNum&gt;</I>,<I>&lt;isActive&gt;</I>,<I>[isMortar]</I>,<I>[clientNum]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; Position of icon<LI>        <B>[MANDATORY]</B>  &lt;teamNum&gt; Team number<LI>        <B>[MANDATORY]</B>  &lt;isActive&gt; Whether the icon is active or not<LI>        <B>[OPTIONAL]</B>  [isMortar] Whether the artillery is a mortar<LI>        <B>[OPTIONAL]</B>  [clientNum] The client number</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the artillery icon location<BR><B>EXAMPLE:  </B>ArtilleryIconLocation( self.origin, 1, true )<BR></OL><P>
<HR><H1>void &lt;entity&gt; ASMSetAnimationRate(<I>&lt;rate&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;rate&gt; (float)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>change the delta animation rate for the entity using ASM.<BR><B>EXAMPLE:  </B>self ASMSetAnimationRate( 0.3 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; Attach(<I>&lt;modelname&gt;</I>,<I>[tagname]</I>,<I>[ignoreCollision]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;modelname&gt; The model name to attach (string).<LI>        <B>[OPTIONAL]</B>  [tagname] The tag to attach the model to (string).<LI>        <B>[OPTIONAL]</B>  [ignoreCollision] flag to ignore collision. Defaults to false (integer).</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Attach a model to an entity.<BR><B>EXAMPLE:  </B>self Attach( "panzerflak_ammo", "tag_weapon_left" )<BR></OL><P>
<HR><H1>void &lt;player&gt; AttachShieldModel(<I>&lt;modelname&gt;</I>,<I>[tagname]</I>,<I>[ignoreCollision]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;modelname&gt; The model name to attach (string).<LI>        <B>[OPTIONAL]</B>  [tagname] The tag to attach the model to (string).<LI>        <B>[OPTIONAL]</B>  [ignoreCollision] flag to ignore collision. Defaults to false (integer).</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Attach a shield model to a player.<BR><B>EXAMPLE:  </B>self AttachShieldModel( "weapon_riot_shield", "tag_weapon_left" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; AttachWeapon(<I>&lt;weapon&gt;</I>,<I>&lt;renderoptions&gt;</I>,<I>&lt;acvi&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to attach.<LI>        <B>[OPTIONAL]</B>  &lt;renderoptions&gt; The render options for the weapon<LI>        <B>[OPTIONAL]</B>  &lt;acvi&gt; The attachment cosmetic variations</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Attaches a weapon to the entity.<BR><B>EXAMPLE:  </B>self AttachWeapon( weapon )<BR></OL><P>
<HR><H1>void BadPlace_Box(<I>&lt;name&gt;</I>,<I>&lt;duration&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;halfSize&gt;</I>,<I>&lt;team&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; The name of the bad place. If name is not "", the bad place can be moved or deleted by using the unique name.<LI>        <B>[MANDATORY]</B>  &lt;duration&gt; If duration &gt; 0, the bad place will automatically delete itself after this time. If duration &lt;= 0, the bad place must have a name and will last until manually deleted.<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The origin of the box.<LI>        <B>[MANDATORY]</B>  &lt;halfSize&gt; The halfSize of the box.<LI>        <B>[MANDATORY]</B>  &lt;team&gt; You must specify at least one team for which this place is bad, but can give several.  The allowed teams are 'axis', 'allies', and 'neutral'.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Creates a bad place box. AI will flee this position if they can, and will not go into it if they can avoid it.<BR><B>EXAMPLE:  </B>BadPlace_Box( "moody", -1, level.moodyfall_mn, level.moodyfall_halfSize, "neutral" )<BR></OL><P>
<HR><H1>void BadPlace_Cylinder(<I>&lt;name&gt;</I>,<I>&lt;duration&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;radius&gt;</I>,<I>&lt;height&gt;</I>,<I>&lt;team&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; The name of the bad place. If name is not "", the bad place can be moved or deleted by using the unique name.<LI>        <B>[MANDATORY]</B>  &lt;duration&gt; If duration &gt; 0, the bad place will automatically delete itself after this time. If duration &lt;= 0, the bad place must have a name and will last until manually deleted.<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The origin of the cylinder.<LI>        <B>[MANDATORY]</B>  &lt;radius&gt; The radius of the cylinder.<LI>        <B>[MANDATORY]</B>  &lt;height&gt; The height of the cylinder.<LI>        <B>[MANDATORY]</B>  &lt;team&gt; You must specify at least one team for which this place is bad, but can give several.  The allowed teams are 'axis', 'allies', and 'neutral'.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Creates a bad place cylinder. AI will flee this position if they can, and will not go into it if they can avoid it.<BR><B>EXAMPLE:  </B>BadPlace_Cylinder( "moody", -1, level.moodyfall_mn, level.moodyfall_radius, "neutral" )<BR></OL><P>
<HR><H1>void BadPlace_Delete(<I>&lt;bad place identifier&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;bad place identifier&gt; The bad place to delete</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Deletes a bad place. It is okay to delete a bad place name that doesn't exist. It is not okay to delete the special name "".<BR><B>EXAMPLE:  </B>BadPlace_Delete( "bpFlak1" )<BR></OL><P>
<HR><H1>void &lt;ball&gt; BallSetTarget(<I>[target]</I>,<I>[targetOffset]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  [target] The target of the missile<LI>        <B>[OPTIONAL]</B>  [targetOffset] Offset to the target location (vector3)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the target of the ball to the given entity, and resets if no entity is specified.<BR><B>EXAMPLE:  </B>self BallSetTarget( player )<BR></OL><P>
<HR><H1>void Ban(<I>&lt;clientnum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;clientnum&gt; The client number of the player to ban.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Bans the specified player.<BR><B>EXAMPLE:  </B>Ban( 2 )<BR></OL><P>
<HR><H1>entity BeamTrace(<I>&lt;start_pos&gt;</I>,<I>&lt;end_pos&gt;</I>,<I>&lt;hit_characters&gt;</I>,<I>&lt;ignore_ent&gt;</I>,<I>[ignore_water]</I>,<I>[ignore_glass]</I>,<I>[ignore_ent2]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start_pos&gt; (point) The start position for the trace.<LI>        <B>[MANDATORY]</B>  &lt;end_pos&gt; (point) The end position for the trace.<LI>        <B>[MANDATORY]</B>  &lt;hit_characters&gt; (bool) Tell the trace to hit characters or not.<LI>        <B>[MANDATORY]</B>  &lt;ignore_ent&gt; (entity) Entity to ingore for trace.<LI>        <B>[OPTIONAL]</B>  [ignore_water] (bool) Ignore water - defaults to false.<LI>        <B>[OPTIONAL]</B>  [ignore_glass] (bool) Ignore glass - defaults to false.<LI>        <B>[OPTIONAL]</B>  [ignore_ent2] (entity) Second entity to ingore for trace.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Performs a bullet trace between two points and returns an array of information about the trace result.<BR><B>EXAMPLE:  </B>a_trace = BeamTrace( org1, org2 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; BloodImpact(<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;value&gt; Has to be one of: "none", "hero" or "normal"</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the blood impact type on the character<BR><B>EXAMPLE:  </B>guy BloodImpact ( "none" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; BlurAndTint_FX(<I>&lt;localClientNum&gt;</I>,<I>true/false. Default is true.</I>,<I>&lt;level&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the player<LI>        <B>[OPTIONAL]</B>  true/false. Default is true.<LI>        <B>[OPTIONAL]</B>  &lt;level&gt; 0 - 1</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Plays RadioActive/Fire FX<BR><B>EXAMPLE:  </B>entity BlurAndTint_FX(0, true, 1)<BR></OL><P>
<HR><H1>void Bobbing(<I>&lt;direction vector&gt;</I>,<I>&lt;amplitude&gt;</I>,<I>&lt;period&gt;</I>,<I>&lt;phase&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;direction vector&gt; The direction of the bobbing<LI>        <B>[MANDATORY]</B>  &lt;amplitude&gt; The amount of the bobbing in units<LI>        <B>[MANDATORY]</B>  &lt;period&gt; The period of the bobbing in seconds<LI>        <B>[OPTIONAL]</B>  &lt;phase&gt; The phase offset of the bobbing</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Causes a script entity to bob around its origin, along a given vector dir<BR><B>EXAMPLE:  </B>self Bobbing( directionVir, 0.3, 0.4, 0.0f )<BR></OL><P>
<HR><H1>void &lt;player&gt; BonusCardActiveCount(<I>&lt;classnum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;classnum&gt; The current class num of the player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns how many bonus cards are active, cannot be called on a larry<BR><B>EXAMPLE:  </B>cardCount = self BonusCardActiveCount( self.class_num )<BR></OL><P>
<HR><H1>void BoundsWouldTelefrag(<I>&lt;mins&gt;</I>,<I>&lt;maxs&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;mins&gt; Mins of bounding box<LI>        <B>[MANDATORY]</B>  &lt;maxs&gt; Maxs of bounding box</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the passed in bounding box would telefrag a player if another player was spawned there.<BR><B>EXAMPLE:  </B>if ( BoundsWouldTelefrag( vehicle GetAbsMins(), vehicle GetAbsmaxs() ) ) ...<BR></OL><P>
<HR><H1>void BulletSpread(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>,<I>&lt;spread&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt; The bullet starting point<LI>        <B>[MANDATORY]</B>  &lt;end&gt; The bullet ending point<LI>        <B>[MANDATORY]</B>  &lt;spread&gt; Amount of spread</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>uses spread to return a new end position<BR><B>EXAMPLE:  </B>endpos = BulletSpread( self.origin, target.origin, 1.0 )<BR></OL><P>
<HR><H1>entity BulletTrace(<I>&lt;start_pos&gt;</I>,<I>&lt;end_pos&gt;</I>,<I>&lt;hit_characters&gt;</I>,<I>&lt;ignore_ent&gt;</I>,<I>[ignore_water]</I>,<I>[ignore_glass]</I>,<I>[ignore_ent2]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start_pos&gt; (point) The start position for the trace.<LI>        <B>[MANDATORY]</B>  &lt;end_pos&gt; (point) The end position for the trace.<LI>        <B>[MANDATORY]</B>  &lt;hit_characters&gt; (bool) Tell the trace to hit characters or not.<LI>        <B>[MANDATORY]</B>  &lt;ignore_ent&gt; (entity) Entity to ingore for trace.<LI>        <B>[OPTIONAL]</B>  [ignore_water] (bool) Ignore water - defaults to false.<LI>        <B>[OPTIONAL]</B>  [ignore_glass] (bool) Ignore glass - defaults to false.<LI>        <B>[OPTIONAL]</B>  [ignore_ent2] (entity) Second entity to ingore for trace.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Performs a bullet trace between two points and returns an array of information about the trace result.<BR><B>EXAMPLE:  </B>a_trace = BulletTrace( org1, org2 )<BR></OL><P>
<HR><H1>void BulletTracePassed(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>,<I>&lt;hit characters&gt;</I>,<I>&lt;ignore entity&gt;</I>,<I>[ignore entity 2]</I>,<I>[fx vis]</I>,<I>[ignore water]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt; The bullet start point<LI>        <B>[MANDATORY]</B>  &lt;end&gt; The bullet end point<LI>        <B>[MANDATORY]</B>  &lt;hit characters&gt; An entity to ignore<LI>        <B>[MANDATORY]</B>  &lt;ignore entity&gt; An entity to ignore<LI>        <B>[OPTIONAL]</B>  [ignore entity 2] An entity to ignore<LI>        <B>[OPTIONAL]</B>  [fx vis] check against fx visibility also<LI>        <B>[OPTIONAL]</B>  [ignore water] mask contents_water</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Allows script to do a bullet point trace with ( MASK_SHOT & ~CONTENTS_SKY ) returns true if the trace does not hit anything<BR><B>EXAMPLE:  </B>passed = BulletTracePassed( grenade.origin, self.origin + (0,0,TROPHY_TRACE_Z), false, self )<BR></OL><P>
<HR><H1>void CamAnimScripted(<I>&lt;player&gt;</I>,<I>&lt;cam_anim&gt;</I>,<I>&lt;start_time&gt;</I>,<I>&lt;align_origin&gt;</I>,<I>&lt;align_angles&gt;</I>,<I>[lerp_duration]</I>,<I>[camera_name]</I>,<I>[ignoreProcessingInitialNoteTracks]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player to play animation on<LI>        <B>[MANDATORY]</B>  &lt;cam_anim&gt; The animation to play<LI>        <B>[MANDATORY]</B>  &lt;start_time&gt; The start time of the animation<LI>        <B>[MANDATORY]</B>  &lt;align_origin&gt; The origin to align to<LI>        <B>[MANDATORY]</B>  &lt;align_angles&gt; The angles to align to<LI>        <B>[OPTIONAL]</B>  [lerp_duration] The lerp duration<LI>        <B>[OPTIONAL]</B>  [camera_name] The camera name<LI>        <B>[OPTIONAL]</B>  [ignoreProcessingInitialNoteTracks] Ignores processing the initial notetracks if the camera time starts earlier</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Plays the camera script on a player.<BR><B>EXAMPLE:  </B>CamAnimScripted( player, "proto_melee_cam", gettime(), origin, angles )<BR></OL><P>
<HR><H1>void &lt;player&gt; CameraForceDisableScriptCam()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Disable the script cam from client script.<BR><B>EXAMPLE:  </B>player CameraForceDisableScriptCam( true )<BR></OL><P>
<HR><H1>void &lt;entity&gt; CameraSetLensId(<I>&lt;id&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;id&gt; int</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>EXAMPLE:  </B>entity CameraSetLensId(0)<BR></OL><P>
<HR><H1>void &lt;player&gt; CameraSetUpdateCallback(<I>[function]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [function] a function pointer to a function that will get called during the camera update, the function should set the scr cam</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the function that will get called during the camera update<BR><B>EXAMPLE:  </B>player CameraSetUpdateCallback( &function )<BR></OL><P>
<HR><H1>void CanClaimNode(<I>&lt;node&gt;</I>,<I>&lt;team&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; pathnode to check<LI>        <B>[MANDATORY]</B>  &lt;team&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the node is unclaimed, false otherwise.<BR><B>EXAMPLE:  </B>if ( CanClaimNode( cover, team ) )<BR></OL><P>
<HR><H1>void CanPath(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt;<LI>        <B>[MANDATORY]</B>  &lt;end&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if a path can be found between these positions.<BR><B>EXAMPLE:  </B>if ( self CanPath( self.origin, targetpos ) )<BR></OL><P>
<HR><H1>void ChangeAdvertisedStatus(<I>&lt;onOff&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;onOff&gt; (boolean)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Changes the advertised status<BR><B>EXAMPLE:  </B>changeAdvertisedStatus( onOff )<BR></OL><P>
<HR><H1>void &lt;entity&gt; CheckIfSongUnlocked(<I>&lt;aliasname&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;aliasname&gt; The sound alias to play (string)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>EXAMPLE:  </B>self CheckIfSongUnlocked( "frag_out" )<BR></OL><P>
<HR><H1>void CheckNavMeshDirection(<I>&lt;start&gt;</I>,<I>&lt;dir&gt;</I>,<I>&lt;dist&gt;</I>,<I>[characterRadius]</I>,<I>[materialFlags]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt; start of the trace<LI>        <B>[MANDATORY]</B>  &lt;dir&gt; direction to trace<LI>        <B>[MANDATORY]</B>  &lt;dist&gt; distance to trace<LI>        <B>[OPTIONAL]</B>  [characterRadius] the radius of the capsule used in trace. default to 0.<LI>        <B>[OPTIONAL]</B>  [materialFlags] the flags marking whether a face type can be used</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Run a trace on NavMesh to get the furthest position a character can move in that direction<BR><B>EXAMPLE:  </B>pos = CheckNavMeshDirection( (10,20,30), ( 1, 1, 0 ), 25 )<BR></OL><P>
<HR><H1>void CleanupSpawnedDynEnts()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Removed all dyn ents that were dynamically spawned (gib pieces, destructible parts, etc)<BR><B>EXAMPLE:  </B>CleanupSpawnedDynEnts()<BR></OL><P>
<HR><H1>void &lt;player&gt; ClearAlternateAimParams()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Forces the local player to use default values for aim assist.  Only works in zombie/campaign mode. Can only be called on players<BR><B>EXAMPLE:  </B>self ClearAlternateAimParams()<BR></OL><P>
<HR><H1>void &lt;entity&gt; ClearAnim(<I>&lt;animation&gt;</I>,<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; The animation or animtree node to clear<LI>        <B>[MANDATORY]</B>  &lt;time&gt; The blending time for the clear</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets an animation's goal weight (and the goal weights of all of its descendents) to zero over the specified time.<BR><B>EXAMPLE:  </B>self ClearAnim( %root, 0)<BR></OL><P>
<HR><H1>void &lt;entity&gt; ClearAnimLimited(<I>&lt;animation&gt;</I>,<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; The animation or animtree node to clear<LI>        <B>[MANDATORY]</B>  &lt;time&gt; The blending time for the clear</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets an animation's goal weight to zero over the specified time.<BR><B>EXAMPLE:  </B>self ClearAnimLimited( %root, 0)<BR></OL><P>
<HR><H1>void ClearLastUpdatedCollectibles()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR></OL><P>
<HR><H1>void &lt;entity&gt; ClearMaterialOverride()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Clears the material override<BR><B>EXAMPLE:  </B>self ClearMaterialOverride()<BR></OL><P>
<HR><H1>void &lt;player&gt; ClearNearestEnemyScrambler()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>clears closest enemy scrambler from the compass<BR><B>EXAMPLE:  </B>player ClearNearestEnemyScrambler( )<BR></OL><P>
<HR><H1>void ClearPlayerCorpses()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Removes all player corpses from the level<BR><B>EXAMPLE:  </B>ClearPlayerCorpses( )<BR></OL><P>
<HR><H1>void &lt;player&gt; ClearPlayerGravity()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears the gravity override for the player.<BR><B>EXAMPLE:  </B>player ClearPlayerGravity()<BR></OL><P>
<HR><H1>void ClearSpawnPoints(<I>&lt;list&gt;</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  &lt;list&gt; which list of spawnpoints to clear</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears all spawnpoints out of the system<BR><B>EXAMPLE:  </B>ClearSpawnPoints()<BR></OL><P>
<HR><H1>void ClearSpawnPointsBaseWeight(<I>&lt;team mask&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team mask&gt; teams that this command will affect</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears the objective base weights set in the spawn points<BR><B>EXAMPLE:  </B>ClearSpawnPointsBaseWeight( team_mask )<BR></OL><P>
<HR><H1>void &lt;entity&gt; ClearStepTriggerSound()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Clears the sound triggered by steps<BR><B>EXAMPLE:  </B>trigPlayer ClearStepTriggerSound()<BR></OL><P>
<HR><H1>void &lt;entity&gt; ClearStowedWeapon()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears the stowed weapon for the player<BR><B>EXAMPLE:  </B>self ClearStowedWeapon()<BR></OL><P>
<HR><H1>void ClearStreamerRequest(<I>&lt;slot&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slot&gt; Request slot</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Clear a hint from a request slot (0-7)<BR><B>EXAMPLE:  </B>clearStreamerRequest(0)<BR></OL><P>
<HR><H1>void &lt;turret&gt; ClearTargetEntity()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears the current target for this vehicle or turret.<BR><B>EXAMPLE:  </B>roof_turret ClearTargetEntity()<BR></OL><P>
<HR><H1>void ClearTopScorers()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears the top scorer for the end game screen.<BR><B>EXAMPLE:  </B>ClearTopScorers()<BR></OL><P>
<HR><H1>void ClientAnnouncement(<I>&lt;clientnum&gt;</I>,<I>&lt;string&gt;</I>,<I>&lt;duration&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;clientnum&gt; The client number that the announcement is sent to.<LI>        <B>[MANDATORY]</B>  &lt;string&gt; The announcement.<LI>        <B>[MANDATORY]</B>  &lt;duration&gt; How long, in seconds, to display the announcement.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sends an announcement to a single client.<BR></OL><P>
<HR><H1>void &lt;client&gt; ClientClaimTrigger(<I>&lt;trigger&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;trigger&gt; A trigger entity.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Claim a single user trigger.<BR><B>EXAMPLE:  </B>other ClientClaimTrigger( self )<BR></OL><P>
<HR><H1>void ClientPrint(<I>&lt;client&gt;</I>,<I>&lt;string&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;client&gt; A client entity.<LI>        <B>[MANDATORY]</B>  &lt;string&gt; A message to print.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Print a localized version of this string for a given client<BR></OL><P>
<HR><H1>void &lt;client&gt; ClientReleaseTrigger(<I>&lt;trigger&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;trigger&gt; A trigger entity.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Release a single user trigger.<BR><B>EXAMPLE:  </B>other ClientReleaseTrigger( self )<BR></OL><P>
<HR><H1>void ClientSysRegister(<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; The unique name of the system to be registered</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Declares a system who's state will be communicated over to the client script system when it changes.  Takes a unique name, and returns the id of the system.<BR><B>EXAMPLE:  </B>index = ClientSysRegister("FakeFire")<BR></OL><P>
<HR><H1>void ClientSysSetState(<I>&lt;id&gt;</I>,<I>&lt;state&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;id&gt; The integer id of the client system.  Returned from call to ClientSysRegister.<LI>        <B>[MANDATORY]</B>  &lt;state&gt; Arbitrary string state.  Will be sent to the client script system.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the state of a pre registered client system for all clients.  The state will be communicated to the client script system.<BR><B>EXAMPLE:  </B>ClientSysSetState(level._ClientSys["FakeFire"], "Event1Phase1")<BR></OL><P>
<HR><H1>entity CloneAndRemoveEntity(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; entity field</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Creates a new entity at the position/orientation/pose of the original, and kills the original<BR><B>EXAMPLE:  </B>CloneAndRemoveEntity( ent )<BR></OL><P>
<HR><H1>void &lt;entity&gt; codcaster_keyline_enable(<I>&lt;type&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;type&gt; 0-disable 1-enable</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Enable or disable the CODCaster Keyline effect<BR><B>EXAMPLE:  </B>entity CODCasterKeyline_Enable( 0 )<BR></OL><P>
<HR><H1>void CodeGetClientField(<I>&lt;entity&gt;</I>,<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The entity to search the name in<LI>        <B>[MANDATORY]</B>  &lt;name&gt; Unique name to identify the field.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the value for a given client field.<BR><B>EXAMPLE:  </B>val = CodeGetClientField(ent, "my_field")<BR></OL><P>
<HR><H1>void CodeGetPlayerStateClientField(<I>&lt;player&gt;</I>,<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; A player<LI>        <B>[MANDATORY]</B>  &lt;name&gt; Unique name to identify the field.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the value for a given player state client field.<BR><B>EXAMPLE:  </B>val = CodeGetPlayerStateClientField(ent, "my_field")<BR></OL><P>
<HR><H1>void CodeGetUIModelClientField(<I>&lt;player&gt;</I>,<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; A player<LI>        <B>[MANDATORY]</B>  &lt;name&gt; Unique name to identify the field.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the value for a given player uimodel client field.<BR><B>EXAMPLE:  </B>val = CodeGetUIModelClientField(ent, "my_field")<BR></OL><P>
<HR><H1>void CodeGetWorldClientField(<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; Unique name to identify the field.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the value for a given client field.<BR><B>EXAMPLE:  </B>val = CodeGetWorldClientField("my_field")<BR></OL><P>
<HR><H1>void CodeIncrementClientField(<I>&lt;entity&gt;</I>,<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity<LI>        <B>[MANDATORY]</B>  &lt;name&gt; Unique name to identify the field.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Increments the value for a given client field.<BR><B>EXAMPLE:  </B>CodeIncrementClientField(ent, "my_field")<BR></OL><P>
<HR><H1>void CodeIncrementPlayerStateClientField(<I>&lt;player&gt;</I>,<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; A player<LI>        <B>[MANDATORY]</B>  &lt;name&gt; Unique name to identify the field.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Increments the value for a given player state client field.<BR><B>EXAMPLE:  </B>CodeIncrementPlayerStateClientField(ent, "my_field")<BR></OL><P>
<HR><H1>void CodeIncrementUIModelClientField(<I>&lt;entity&gt;</I>,<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity<LI>        <B>[MANDATORY]</B>  &lt;name&gt; Unique name to identify the field.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Increments the value for a given client field.<BR><B>EXAMPLE:  </B>CodeIncrementUIModelClientField(ent, "my_field")<BR></OL><P>
<HR><H1>void CodeIncrementWorldClientField(<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; Unique name to identify the field.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Increments the value for a given world client field.<BR><B>EXAMPLE:  </B>CodeIncrementWorldClientField("my_field")<BR></OL><P>
<HR><H1>void CodeSetClientField(<I>&lt;entity&gt;</I>,<I>&lt;name&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity<LI>        <B>[MANDATORY]</B>  &lt;name&gt; Unique name to identify the field.<LI>        <B>[MANDATORY]</B>  &lt;value&gt; Value to transmit.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the value for a given client field.<BR><B>EXAMPLE:  </B>CodeSetClientField(ent, "my_field", 1)<BR></OL><P>
<HR><H1>void CodeSetPlayerStateClientField(<I>&lt;player&gt;</I>,<I>&lt;name&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; A player<LI>        <B>[MANDATORY]</B>  &lt;name&gt; Unique name to identify the field.<LI>        <B>[MANDATORY]</B>  &lt;value&gt; Value to transmit.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the value for a given player state client field.<BR><B>EXAMPLE:  </B>CodeSetPlayerStateClientField(ent, "my_field", 1)<BR></OL><P>
<HR><H1>void CodeSetUIModelClientField(<I>&lt;player&gt;</I>,<I>&lt;name&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; A player<LI>        <B>[MANDATORY]</B>  &lt;name&gt; Unique name to identify the field.<LI>        <B>[MANDATORY]</B>  &lt;value&gt; Value to transmit.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the value for a given player uimodel client field.<BR><B>EXAMPLE:  </B>CodeSetUIModelClientField(ent, "my_field", 1)<BR></OL><P>
<HR><H1>void CodeSetWorldClientField(<I>&lt;name&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; Unique name to identify the field.<LI>        <B>[MANDATORY]</B>  &lt;value&gt; Value to transmit.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the value for a given world client field.<BR><B>EXAMPLE:  </B>CodeSetWorldClientField("my_field", 1)<BR></OL><P>
<HR><H1>void CollisionTestPointsInBox()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR></OL><P>
<HR><H1>void CollisionTestPointsInCone()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR></OL><P>
<HR><H1>void CollisionTestPointsInCylinder()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR></OL><P>
<HR><H1>void CollisionTestPointsInPill()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR></OL><P>
<HR><H1>void CollisionTestPointsInSphere()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of collision result structures<BR></OL><P>
<HR><H1>void &lt;entity&gt; ConnectPaths()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Connects the paths that intersect with the entity. If the entity is a script_brushmodel then it must have DYNAMICPATH set to connect paths.<BR><B>EXAMPLE:  </B>vehicle ConnectPaths()<BR></OL><P>
<HR><H1>void &lt;player&gt; ConsumableDecrement()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Decrement a specified consumable for the player by the specified amount<BR><B>EXAMPLE:  </B>self ConsumableDecrement( "blackjack", "awarded", 1 )<BR></OL><P>
<HR><H1>void &lt;player&gt; ConsumableGet()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the value of the specified consumable for the player<BR><B>EXAMPLE:  </B>self ConsumableGet( "blackjack", "awarded" )<BR></OL><P>
<HR><H1>void &lt;player&gt; ConsumableIncrement()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Increment a specified consumable for the player by the specified amount<BR><B>EXAMPLE:  </B>self ConsumableIncrement( "blackjack", "awarded", 1 )<BR></OL><P>
<HR><H1>void &lt;player&gt; ConsumableSet()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set a specified consumable for the player to the specified amount<BR><B>EXAMPLE:  </B>self ConsumableSet( "blackjack", "awarded", 1 )<BR></OL><P>
<HR><H1>void CountPlayers(<I>[team]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [team] - if specifed, returns lists of players on different teams, in team based game modes.  Valid values "allies", "axis", "neutral" & "all"</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns a count of the current players, even if they are still connecting to the game.<BR><B>EXAMPLE:  </B>count = CountPlayers()<BR></OL><P>
<HR><H1>void CreateDynEntAndLaunch(<I>&lt;model&gt;</I>,<I>&lt;pos&gt;</I>,<I>&lt;angles&gt;</I>,<I>&lt;hitpos&gt;</I>,<I>&lt;force&gt;</I>,<I>[fx]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;model&gt;<LI>        <B>[MANDATORY]</B>  &lt;pos&gt; position to spawn at.<LI>        <B>[MANDATORY]</B>  &lt;angles&gt; angles to spawn at.<LI>        <B>[MANDATORY]</B>  &lt;hitpos&gt; the hit position<LI>        <B>[MANDATORY]</B>  &lt;force&gt; The force of the launch<LI>        <B>[OPTIONAL]</B>  [fx] particle effects to play on this dynent</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Creates and launches a dynent.<BR><B>EXAMPLE:  </B>CreateDynEntAndLaunch( spawn_models[i], origin, angles, origin, velocity, anim._effect["animscript_gibtrail_fx"] )<BR></OL><P>
<HR><H1>void CreateSoundRandom(<I>&lt;position&gt;</I>,<I>&lt;name&gt;</I>,<I>&lt;min wait&gt;</I>,<I>&lt;max wait&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; The position<LI>        <B>[MANDATORY]</B>  &lt;name&gt; The sound name<LI>        <B>[MANDATORY]</B>  &lt;min wait&gt; The minimum wait time<LI>        <B>[MANDATORY]</B>  &lt;max wait&gt; The maximum wait time</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Create sound random at the position<BR><B>EXAMPLE:  </B>CreateSoundRandom(randSound.origin, randSound.script_sound, randSound.script_wait_min, randSound.script_wait_max)<BR></OL><P>
<HR><H1>entity CreateStreamerHint(<I>&lt;origin&gt;</I>,<I>&lt;factor&gt;</I>,<I>[lightingState]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; Location at which to spawn the streamer hint.<LI>        <B>[MANDATORY]</B>  &lt;factor&gt; The relative importance of this entity's viewpoint to the main viewpoint.<LI>        <B>[OPTIONAL]</B>  [lightingState] The lighting state to stream</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Allows scripter to create a streamer hint entity viewpoint to the player's viewpoint.<BR><B>EXAMPLE:  </B>streamHintEnt = createStreamerHint( level.player.origin, 0.333 )<BR></OL><P>
<HR><H1>void CurrentSessionMode()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the current session mode index<BR><B>EXAMPLE:  </B>sessionMode = CurrentSessionMode()<BR></OL><P>
<HR><H1>void CylinderDamage(<I>&lt;cylinder_vec&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;near_radius&gt;</I>,<I>&lt;far_radius&gt;</I>,<I>&lt;max_damage&gt;</I>,<I>&lt;min_damage&gt;</I>,<I>[attacker]</I>,<I>[means_of_death]</I>,<I>[weapon]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;cylinder_vec&gt; contains the direction and the length of the cylinder relative to the base origin<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; Origin of damage<LI>        <B>[MANDATORY]</B>  &lt;near_radius&gt; Radius of the damage at the near end<LI>        <B>[MANDATORY]</B>  &lt;far_radius&gt; Radius of the damage at the far end<LI>        <B>[MANDATORY]</B>  &lt;max_damage&gt; Max damage, this is the damage at the origin<LI>        <B>[MANDATORY]</B>  &lt;min_damage&gt; Max damage, this is the damage at the edge of the radius<LI>        <B>[OPTIONAL]</B>  [attacker] Attacker the dealt the damage<LI>        <B>[OPTIONAL]</B>  [means_of_death] Means of death of the damage<LI>        <B>[OPTIONAL]</B>  [weapon] Weapon used to damage</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>cylinder_dir_vector should contains the direction and the length of the cylinder relative to the base origin<BR></OL><P>
<HR><H1>void &lt;entity&gt; DamageConeTrace(<I>&lt;damage position&gt;</I>,<I>[ignore entity]</I>,<I>&lt;damage position&gt;</I>,<I>[cone angle]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;damage position&gt; The point the sight starts at<LI>        <B>[OPTIONAL]</B>  [ignore entity] An entity to ignore when doing the traces<LI>        <B>[OPTIONAL]</B>  [damage angles] The forward direction of the cone, whose base is at the &lt;damage position&gt;.  Must be normalized.<LI>        <B>[OPTIONAL]</B>  [cone angle] Angle in degrees from the line of sight to the edge of the cone.  Defaults to 65.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Determines how much the entity can be seen from the given position. Performs multiple traces and returns an approximation to how much of the entity is visible from the given point (between 0 and 1). In SinglePlayer this will always be 1 if the entity is partially visible.<BR><B>EXAMPLE:  </B>turretDamageFraction = entity damageConeTrace( turret.origin + (0,0,40), turret )<BR></OL><P>
<HR><H1>void DeactivateClientExploder(<I>&lt;exploder id&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;exploder id&gt; id of exploder to deactivate</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Deactivates a client side exploder<BR><B>EXAMPLE:  </B>DeactivateClientExploder( 101 )<BR></OL><P>
<HR><H1>void DeactivateClientRadiantExploder(<I>&lt;exploder id&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;exploder id&gt; string id of exploder to deactivate</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Deactivates a client side radiant exploder<BR><B>EXAMPLE:  </B>DeactivateClientRadiantExploder( "light_switch" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; Delete()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Removes an entity from the game in the same manner as a trigger_kill<BR><B>EXAMPLE:  </B>self Delete()<BR></OL><P>
<HR><H1>void DeletePathNode(<I>&lt;node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; The node to delete</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Delete a dynamically created path node or cover node<BR><B>EXAMPLE:  </B>DeletePathNode( node )<BR></OL><P>
<HR><H1>void DemoIsAnyFreeMoveCamera()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR></OL><P>
<HR><H1>void DemoIsDollyCamera()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR></OL><P>
<HR><H1>void DemoIsEditCamera()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR></OL><P>
<HR><H1>void DemoIsMovieCamera()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR></OL><P>
<HR><H1>entity DeployRiotShield(<I>&lt;owner&gt;</I>,<I>&lt;shield_ent&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;owner&gt;<LI>        <B>[MANDATORY]</B>  &lt;shield_ent&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the index in a particular class<BR><B>EXAMPLE:  </B>DeployRiotShield( owner, shield )<BR></OL><P>
<HR><H1>void &lt;entity&gt; DepthInWater()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the depth (in inches) that the entity is in water.  Returns depth in inches, or 0 if the entity isn't in water.  Will work for all water types.<BR><B>EXAMPLE:  </B>depth = get_players()[0] DepthInWater()<BR></OL><P>
<HR><H1>void &lt;player&gt; DepthOfPlayerInWater()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the depth (in inches) that the player is in water.  Returns depth in inches, or 0 if the entity isn't in water.  Will work for all water types.  More effecient than depthinwater but will only work for players<BR><B>EXAMPLE:  </B>depth = get_players()[0] DepthOfPlayerInWater()<BR></OL><P>
<HR><H1>void &lt;entity&gt; Detach(<I>&lt;modelname&gt;</I>,<I>[tagname]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;modelname&gt; The model name to detach (string)<LI>        <B>[OPTIONAL]</B>  [tagname] The tag to detach the model from (string)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>detaches an attached model from an entity<BR><B>EXAMPLE:  </B>self Detach( "explosivepack", "tag_weapon_right" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; DetachAll()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>detaches all attached models from an entity<BR><B>EXAMPLE:  </B>self DetachAll()<BR></OL><P>
<HR><H1>void &lt;player&gt; DetachShieldModel(<I>&lt;modelname&gt;</I>,<I>[tagname]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;modelname&gt; The model name to detach (string)<LI>        <B>[OPTIONAL]</B>  [tagname] The tag to detach the model from (string)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Detaches an attached shield model from a player.<BR><B>EXAMPLE:  </B>self DetachShieldModel( "weapon_riot_shield", "tag_weapon_left" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; Detonate(<I>[player]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [player] The player who owns the entity</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Detonate the entity and set the owner to the player which is specified.<BR><B>EXAMPLE:  </B>self Detonate( attacker )<BR></OL><P>
<HR><H1>void DirectionalHitIndicator(<I>&lt;victims0&gt;</I>,<I>[victims1]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;victims0&gt; A bit array of entities 0-31 that got hit<LI>        <B>[OPTIONAL]</B>  [victims1] A bit array of entities 32-63 that got hit</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Create a directional hit indicator<BR><B>EXAMPLE:  </B>attacker DirectionalHitIndicator( victimArray0, victimArray1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; DisableAimAssist()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Disables Aim assist on the entity. Entity has to be either a brush model or an actor or a vehicle or a script_model.<BR><B>EXAMPLE:  </B>player DisableAimAssist()<BR></OL><P>
<HR><H1>void DisableDestructiblePieces(<I>&lt;label&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;label&gt; the name of the field listed in the destructible gdt to disable</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Disables all destructible pieces that have this label set in the destructible gdt<BR><B>EXAMPLE:  </B>DisableDestructiblePieces( "heavy_armor" )<BR></OL><P>
<HR><H1>void DisableGrenadeSuicide()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stops cooked grenades from killing the player.<BR></OL><P>
<HR><H1>void &lt;entity&gt; DisableGrenadeTouchDamage()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Resets the grenade touch damage flag of the entity<BR><B>EXAMPLE:  </B>self DisableGrenadeTouchDamage()<BR></OL><P>
<HR><H1>void &lt;player&gt; DisableOffhandSpecial()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Disable the ability to activate a player's special offhand weapons<BR><B>EXAMPLE:  </B>player DisableOffhandSpecial()<BR></OL><P>
<HR><H1>void &lt;entity&gt; DisableOnRadar()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the icon to be shown on the minimap<BR><B>EXAMPLE:  </B>actor DisableOnRadar()<BR></OL><P>
<HR><H1>void DisableSpawnPointList(<I>&lt;list&gt;</I>,<I>&lt;team mask&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;list&gt; list to disable<LI>        <B>[MANDATORY]</B>  &lt;team mask&gt; teams that this command will affect</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>disables spawn point list for a the team_mask<BR><B>EXAMPLE:  </B>DisableSpawnPointList()<BR></OL><P>
<HR><H1>void DisableSpeedBlur(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>REmoves a speed blur on on the screen<BR><B>EXAMPLE:  </B>DisableSpeedBlur( &lt;localClientNum&gt; )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; DisableVehicleSounds()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Disables all sounds from a vehicle<BR><B>EXAMPLE:  </B>self DisableVehicleSounds()<BR></OL><P>
<HR><H1>void &lt;entity&gt; DisconnectPaths(<I>[detailLevel]</I>,<I>[moveAllowed]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [detailLevel] how detailed the cut part matches the entity. 0 or omitted: box, 1: convex hull fitting rough shape, 2: [SUPER EXPENSIVE] use collision shape directly<LI>        <B>[OPTIONAL]</B>  [moveAllowed] sets whether the silhouette moves with the entity (defaults to true)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Disconnects the paths that intersect with the entity. If the entity is a script_brushmodel then it must have DYNAMICPATH set to disconnect paths.<BR><B>EXAMPLE:  </B>level.ArmoredCar DisconnectPaths()<BR></OL><P>
<HR><H1>void &lt;entity&gt; DoDamage(<I>&lt;health&gt;</I>,<I>&lt;source position&gt;</I>,<I>[attacker]</I>,<I>[inflictor]</I>,<I>[hitloc]</I>,<I>[mod]</I>,<I>[dflags]</I>,<I>[weapon]</I>,<I>[infdestructible_piece_indexlictor]</I>,<I>[forcePain]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;health&gt; The amount of damage to do<LI>        <B>[MANDATORY]</B>  &lt;source position&gt; The position that the damage comes from<LI>        <B>[OPTIONAL]</B>  [attacker] The entity that dealt the damage (such as an AI or player)<LI>        <B>[OPTIONAL]</B>  [inflictor] The entity that the damage came from (such as a grenade or turret)<LI>        <B>[OPTIONAL]</B>  [hitloc] The location of the damage, default is none; one of: { 'none', 'torso_upper', 'torso_lower', 'helmet', 'head', 'neck', 'left_arm_upper', 'left_arm_lower', 'left_hand', 'right_arm_upper', 'right_arm_lower', 'right_hand', 'left_leg_upper', 'left_leg_lower', 'left_foot', 'right_leg_upper', 'right_leg_lower', 'right_foot' }<LI>        <B>[OPTIONAL]</B>  [mod] . The means of death string. Otherwise, the means of death will be 'MOD_UNKNOWN'.<LI>        <B>[OPTIONAL]</B>  [dflags] . Damage flags.<LI>        <B>[OPTIONAL]</B>  [weapon] . Weapon used.<LI>        <B>[OPTIONAL]</B>  [infdestructible_piece_indexlictor] The destructible piece index from the destructible def gdt"<LI>        <B>[OPTIONAL]</B>  [forcePain] true/false; If true, actor-&gt;painDeath.iPainTime will be reset to zero"</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Does damage to this entity<BR><B>EXAMPLE:  </B>player DoDamage(25, gasEffectArea.origin, player.lastPoisonedBy, grenade_obj, 0, "MOD_EXPLOSIVE", 0, GetWeapon("tabun_gas_mp"), -1, false)<BR></OL><P>
<HR><H1>void DoesWeaponReplaceSpawnWeapon(<I>&lt;weapon name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon name&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the new weapon is an alt mode of the spawn weapon. Only certain alt variations are valid (not-gl)<BR><B>EXAMPLE:  </B>if ( DoesWeaponReplaceSpawnWeapon( self.spawnWeapon, newWeapon ) )<BR></OL><P>
<HR><H1>void &lt;entity&gt; DontInterpolate()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>pop the entity's position instantaneously to where it moves this time step, rather than smoothly moving there from the previous position<BR><B>EXAMPLE:  </B>entity DontInterpolate()<BR></OL><P>
<HR><H1>void &lt;player&gt; DoubleXPTimerFired()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Used to decrement consumable double xp promotions<BR></OL><P>
<HR><H1>void &lt;entity&gt; DragonStrike_Enable(<I>&lt;type&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;type&gt; 0-disable 1-enable</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Enable or disable the DragonStrike effect<BR><B>EXAMPLE:  </B>entity DragonStrike_enable( 0 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; DragonStrike_SetColorRadiusSpinPulse(<I>red, green, blue</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  red, green, blue</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set Dragon Strike Cicle position<BR><B>EXAMPLE:  </B>entity DragonStrike_SetColorRadiusSpinPulse( 1.0, 0.5, 0.25, 100.0, 0.5, 1.0 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; DragonStrike_SetPosition(<I>vec3_t position</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  vec3_t position</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set Dragon Strike Cicle position<BR><B>EXAMPLE:  </B>entity DragonStrike_SetPosition( vec3 )<BR></OL><P>
<HR><H1>void DrawNode(<I>&lt;node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; pathnode</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Draws a node<BR><B>EXAMPLE:  </B>DrawNode( self.node)<BR></OL><P>
<HR><H1>void DropNodEToFloor(<I>&lt;node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; node to drop</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Drop the node to the floor.<BR><B>EXAMPLE:  </B>DropNodeToFloor( node )<BR></OL><P>
<HR><H1>void EACPathSet(<I>&lt;vec3&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;vec3&gt; The value.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the value of a eac path drone.<BR><B>EXAMPLE:  </B>SetEACPATH( origin )<BR></OL><P>
<HR><H1>void Earthquake(<I>&lt;scale&gt;</I>,<I>&lt;duration&gt;</I>,<I>&lt;radius&gt;</I>,<I>[target]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;scale&gt; scale of the earthquake. Must be greater than 0.<LI>        <B>[MANDATORY]</B>  &lt;duration&gt; The duration of the earthquake. Must be greater than 0.<LI>        <B>[MANDATORY]</B>  &lt;radius&gt; The radius of the earthquake. Must be greater than 0.<LI>        <B>[OPTIONAL]</B>  [target] Target is given if earthquake is to be shown to particular client</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Create an earthquake<BR><B>EXAMPLE:  </B>Earthquake( 0.22, 7, player.origin, 150 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; EnableAimAssist()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enables Aim assist on the entity. Entity has to be either a brush model or an actor or a vehicle or a script_model.<BR><B>EXAMPLE:  </B>player EnableAimAssist()<BR></OL><P>
<HR><H1>void EnableAllDestructiblePieces()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enables all destructible pieces that were previously disabled<BR><B>EXAMPLE:  </B>EnableAllDestructiblePieces()<BR></OL><P>
<HR><H1>void EnableGrenadeSuicide()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enables cooked grenades killing the player.<BR></OL><P>
<HR><H1>void &lt;entity&gt; EnableGrenadeTouchDamage()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the grenade touch damage flag of the entity<BR><B>EXAMPLE:  </B>self EnableGrenadeTouchDamage()<BR></OL><P>
<HR><H1>void EnableInfluencer(<I>&lt;influencer id&gt;</I>,<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;influencer id&gt; The influencer to enable/disable<LI>        <B>[MANDATORY]</B>  &lt;enable&gt; True to enable. False to disable</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enables or disables the given influencer<BR><B>EXAMPLE:  </B>EnableInfluencer( influencer_id, true )<BR></OL><P>
<HR><H1>void &lt;entity&gt; EnableLinkTo()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>enables linkto for an entity<BR><B>EXAMPLE:  </B>self.bombtrigger EnableLinkTo()<BR></OL><P>
<HR><H1>void EnableNavMeshTrigger(<I>&lt;targetname&gt;</I>,<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;targetname&gt; The targetname of the trigger entity.<LI>        <B>[MANDATORY]</B>  &lt;enable&gt; Whether to enable disable the given volume for pathfinding.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enables/disables a given navmesh trigger<BR><B>EXAMPLE:  </B>EnableNavMeshTrigger( "some_trigger", true )<BR></OL><P>
<HR><H1>void &lt;entity&gt; EnableObstacle(<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;enable&gt; Whether to enable or disable the obstacle</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enables or disables the hkai obstacle associated with a given entity.<BR><B>EXAMPLE:  </B>ent EnableObstacle( true )<BR></OL><P>
<HR><H1>void &lt;player&gt; EnableOffhandSpecial()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enable the ability to activate a player's special offhand weapons<BR><B>EXAMPLE:  </B>player EnableOffhandSpecial()<BR></OL><P>
<HR><H1>void &lt;entity&gt; EnableOnRadar()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the icon to be shown on the minimap<BR><B>EXAMPLE:  </B>actor EnableOnRadar()<BR></OL><P>
<HR><H1>void EnableSpawnPointList(<I>&lt;list&gt;</I>,<I>&lt;team mask&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;list&gt; list to enable<LI>        <B>[MANDATORY]</B>  &lt;team mask&gt; teams that this command will affect</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>enables spawn point list for a the team_mask<BR><B>EXAMPLE:  </B>EnableSpawnPointList()<BR></OL><P>
<HR><H1>void EnableSpeedBlur(<I>&lt;localClientNum&gt;</I>,<I>&lt;amount&gt;</I>,<I>&lt;inner radius&gt;</I>,<I>&lt;inner outerradius&gt;</I>,<I>&lt;velocityShouldScale&gt;</I>,<I>&lt;velocityScale&gt;</I>,<I>&lt;blurInTime&gt;</I>,<I>&lt;blurOutTime&gt;</I>,<I>&lt;shouldOffset&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the player<LI>        <B>[MANDATORY]</B>  &lt;amount&gt; Blur Amount ( 0.0 - 1.0 )<LI>        <B>[MANDATORY]</B>  &lt;inner radius&gt; The size of the inner radius ( 0.0 - 1.0 )<LI>        <B>[MANDATORY]</B>  &lt;inner outerradius&gt; The size of the inner radius ( 0.0 - 1.0 )<LI>        <B>[OPTIONAL]</B>  &lt;velocityShouldScale&gt; false don't scale with velocity, true scale<LI>        <B>[OPTIONAL]</B>  &lt;velocityScale&gt; Specify the velocity when the scale is 1.0<LI>        <B>[OPTIONAL]</B>  &lt;blurInTime&gt; Specify the time it takes to complete a blur in<LI>        <B>[OPTIONAL]</B>  &lt;blurOutTime&gt; Specify the time it takes to complete a blur out<LI>        <B>[OPTIONAL]</B>  &lt;shouldOffset&gt; Specify whether the blur should change as you move left/right or up/down</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets a speed blur on on the screen with parameters<BR><B>EXAMPLE:  </B>EnableSpeedBlur( localClientNum, .02, .5, .75, true, 300.0 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; EnableVehicleSounds()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Enables all sounds from a vehicle<BR><B>EXAMPLE:  </B>self EnableVehicleSounds()<BR></OL><P>
<HR><H1>void &lt;player&gt; EndCamAnimScripted(<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Ends the camera script on a player.<BR><B>EXAMPLE:  </B>EndCamAnimScripted( player )<BR></OL><P>
<HR><H1>void &lt;player&gt; EndExtraCamAnimScripted(<I>&lt;player&gt;</I>,<I>&lt;extra_cam_index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player to play animation on<LI>        <B>[MANDATORY]</B>  &lt;extra_cam_index&gt; The extra camera index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Ends the extracam camera script on a player.<BR><B>EXAMPLE:  </B>EndExtraCamAnimScripted( player, 0 )<BR></OL><P>
<HR><H1>void evSetRanges(<I>&lt;localClientNum&gt;</I>,<I>&lt;geometryRange&gt;</I>,<I>&lt;targetRange&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number.<LI>        <B>[MANDATORY]</B>  &lt;geometryRange&gt; geometry draw distance.<LI>        <B>[MANDATORY]</B>  &lt;targetRange&gt; target object draw distance.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the visual range for EV mode<BR><B>EXAMPLE:  </B>evSetRanges( localclientnum, geometryRange, targetRange )<BR></OL><P>
<HR><H1>void ExitLevel(<I>[save persistent]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [save persistent] if true then player info is retained</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>exits the current level<BR><B>EXAMPLE:  </B>ExitLevel( false )<BR></OL><P>
<HR><H1>void ExperimentsGetVariant()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the variant for a user for an experiment<BR><B>EXAMPLE:  </B>variant = player ExperimentsGetVariant( experimentName )<BR></OL><P>
<HR><H1>void ExtraCamAnimScripted(<I>&lt;player&gt;</I>,<I>&lt;extra_cam_index&gt;</I>,<I>&lt;cam_anim&gt;</I>,<I>&lt;start_time&gt;</I>,<I>&lt;align_origin&gt;</I>,<I>&lt;align_angles&gt;</I>,<I>[lerp_duration]</I>,<I>[camera_name]</I>,<I>[ignoreProcessingInitialNoteTracks]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player to play animation on<LI>        <B>[MANDATORY]</B>  &lt;extra_cam_index&gt; The extra camera index<LI>        <B>[MANDATORY]</B>  &lt;cam_anim&gt; The animation to play<LI>        <B>[MANDATORY]</B>  &lt;start_time&gt; The start time of the animation<LI>        <B>[MANDATORY]</B>  &lt;align_origin&gt; The origin to align to<LI>        <B>[MANDATORY]</B>  &lt;align_angles&gt; The angles to align to<LI>        <B>[OPTIONAL]</B>  [lerp_duration] The lerp duration<LI>        <B>[OPTIONAL]</B>  [camera_name] The camera name<LI>        <B>[OPTIONAL]</B>  [ignoreProcessingInitialNoteTracks] Ignores processing the initial notetracks if the camera time starts earlier</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Plays the camera script on an extracam player.<BR><B>EXAMPLE:  </B>ExtraCamAnimScripted( player, 0, "proto_melee_cam", gettime(), origin, angles )<BR></OL><P>
<HR><H1>void FakeFire(<I>&lt;owner&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;weapon&gt;</I>,<I>&lt;shot count&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;owner&gt; The player who fakes fire<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; the origin of the fake fire<LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon used<LI>        <B>[MANDATORY]</B>  &lt;shot count&gt; Number of shots fired</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Simulates gun fire.  Sound and radar blip.<BR><B>EXAMPLE:  </B>decoy FakeFire( player, position, "turret_mp", 20 )<BR></OL><P>
<HR><H1>void FindAnimByName(<I>&lt;tree&gt;</I>,<I>&lt;anim&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;tree&gt; Anim tree name<LI>        <B>[MANDATORY]</B>  &lt;anim&gt; Name of anim</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Find specified animation( using animation name ) in a specified animtree( using atr name).<BR><B>EXAMPLE:  </B>animnamehash = FindAnimByName("generic_human", "chicken_dance")<BR></OL><P>
<HR><H1>void &lt;entity&gt; FindDRFilter(<I>&lt;object&gt;</I>,<I>&lt;filterset&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;object&gt; entity to check for flags on<LI>        <B>[MANDATORY]</B>  &lt;filterset&gt; filterset to use</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>optimized code replacement for find_dr_filter<BR><B>EXAMPLE:  </B>object FindDRFilter( filterset )<BR></OL><P>
<HR><H1>void FindPath(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt;.<LI>        <B>[MANDATORY]</B>  &lt;end&gt;.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if a path can be found between these positions.<BR><B>EXAMPLE:  </B>if ( self FindPath( self.origin, potentialpos ) )<BR></OL><P>
<HR><H1>void FlashbackFinish()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Finishes the flashback<BR><B>EXAMPLE:  </B>self FlashbackFinish()<BR></OL><P>
<HR><H1>void FlashbackStart(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon in the player loadout.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Starts the flashback and returns the new origin<BR><B>EXAMPLE:  </B>newpos = self FlashbackStart( &lt;weapon&gt; )<BR></OL><P>
<HR><H1>void FlushSubtitles(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum to flush the subtitles for</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Flush and clear any current subtitles on the screen for this specific client<BR><B>EXAMPLE:  </B>FlushSubtitles(0) <BR></OL><P>
<HR><H1>void FootstepDoEverything()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the footsteps to play sound and play the footstep fx<BR><B>EXAMPLE:  </B>FootstepDoEverything()<BR></OL><P>
<HR><H1>void FootstepDoFootstepFX()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the footsteps to play the effect<BR><B>EXAMPLE:  </B>FootstepDoFootstepFX()<BR></OL><P>
<HR><H1>void FootstepDoNothing()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the footsteps to do nothing. Not to play sound or play any fx<BR><B>EXAMPLE:  </B>FootstepDoNothing()<BR></OL><P>
<HR><H1>void FootstepDoSound()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the footsteps to play sound<BR><B>EXAMPLE:  </B>FootstepDoSound()<BR></OL><P>
<HR><H1>void ForceAmbientRoom(<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; The sound name</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Force play an ambient sound<BR><B>EXAMPLE:  </B>ForceAmbientRoom( "sndHealth_LowHealth" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; ForceDelete()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Forces Removal of a  entity. Does not wait till next snapshot to remove it.  Will cause crash if called on animated entity<BR><B>EXAMPLE:  </B>thing forcedelete()<BR></OL><P>
<HR><H1>void ForceGameModeMappings(<I>&lt;localClientNum&gt;</I>,<I>&lt;modeName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number to play the animation on<LI>        <B>[MANDATORY]</B>  &lt;modeName&gt; Name of the mode to switch to or "default" for user defaults</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Forces the users controller mappings for a specific game mode (or resets to user defaults)<BR><B>EXAMPLE:  </B>ForceGameModeMappings( localClientNum, "default" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; ForcePainOn()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>toggles pain.forcePain to true;  next damage reaction guarenteed<BR><B>EXAMPLE:  </B>ai ForcePainOn()<BR></OL><P>
<HR><H1>void ForceStreamBundle(<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; Name of the script bundle to stream</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Force the assets in a script bundle to stream in<BR><B>EXAMPLE:  </B>ForceStreamBundle( "cin_ram_02_03_ai" )<BR></OL><P>
<HR><H1>void ForceStreamMaterial(<I>&lt;material&gt;</I>,<I>[textureLods]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;material&gt; Material to force stream<LI>        <B>[OPTIONAL]</B>  [textureLods] Texture LODs to not force</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Forces the streamer to load texture LODs for a material even if it isn't yet visible.  Returns true when all levels are loaded.  Call StopForceStreamingMaterial when you no longer need it, or Steve will be upset that you're wasting Streamer memory.<BR><B>EXAMPLE:  </B>areAllForcedLodsLoaded = ForceStreamMaterial( material, mipsToNotForce )<BR></OL><P>
<HR><H1>void ForceStreamWeaponRenderOptions(<I>&lt;localClientNum&gt;</I>,<I>&lt;weapon&gt;</I>,<I>&lt;weaponOptions&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; Weapon to look up the materials to stream with<LI>        <B>[MANDATORY]</B>  &lt;weaponOptions&gt; Render Options to look up the materials to stream with</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Forces all materials for the combination of weapon and render options to stream in<BR><B>EXAMPLE:  </B>ForceStreamWeaponRenderOptions( localClientNum, weapon, weaponOptions )<BR></OL><P>
<HR><H1>void ForceStreamWeapons()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Forces all weapon materials to stream in<BR><B>EXAMPLE:  </B>forceStreamWeapons()<BR></OL><P>
<HR><H1>void ForceStreamXModel(<I>&lt;model&gt;</I>,<I>[meshLodsToForce]</I>,<I>[textureLodsToForce]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;model&gt; The model to force stream<LI>        <B>[OPTIONAL]</B>  [meshLodsToForce] The mesh LODs to force ( Default is 0 )<LI>        <B>[OPTIONAL]</B>  [textureLodsToForce] The texture LODs to force ( Default is 0 )</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Forces the streamer to load model and texture LODs for a model even if it isn't yet visible.  Returns true when all levels are loaded.  Call StopForceStreamingXModel when you no longer need it, or Steve will be upset that you're wasting Streamer memory.<BR><B>EXAMPLE:  </B>areAllForcedLodsLoaded = CScr_ForceStreamXModel( model, meshLodsToNotForce, textureLodsToNotForce, alsoStreamLowerLods=true )<BR></OL><P>
<HR><H1>void ForceTModeVisible(<I>&lt;entity&gt;</I>,<I>[visible]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The entity the value is being set for<LI>        <B>[OPTIONAL]</B>  [visible] If the entity should be considered always visible or not (default true)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Forces an entity to be visible as if a player was seeing it via tmode<BR><B>EXAMPLE:  </B>ForceTModeVisible( aiGuy, true )<BR></OL><P>
<HR><H1>void FXBlockSight(<I>&lt;entity&gt;</I>,<I>&lt;radius&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; the entity to use for the origin for tje line of sight blocker<LI>        <B>[MANDATORY]</B>  &lt;radius&gt; the radius of the 'smoke screen' blocker</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Uses a general entity and a radius to set a line of sight blocker on the server for some AI. Destroyed when the entity is freed.<BR><B>EXAMPLE:  </B>FXBlockSight( fxent, 64 )<BR></OL><P>
<HR><H1>void GadgetActivate(<I>&lt;slot&gt;</I>,<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slot&gt; The gadget slot to activate. (integer)<LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The gadget weapon</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>turns gadget on in slot.<BR><B>EXAMPLE:  </B>self GadgetActivate( slot )<BR></OL><P>
<HR><H1>void GadgetCharging(<I>&lt;slot&gt;</I>,<I>[value]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slot&gt; The gadget slot. (integer)<LI>        <B>[OPTIONAL]</B>  [value] undefined to get current state, true to set or false to unset. (boolean)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the gadget charging state.<BR><B>EXAMPLE:  </B>self GadgetCharging( slot, true )<BR></OL><P>
<HR><H1>void GadgetDeactivate(<I>&lt;slot&gt;</I>,<I>&lt;weapon&gt;</I>,<I>&lt;penalty&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slot&gt; The gadget slot to deactivate. (integer)<LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The gadget weapon<LI>        <B>[OPTIONAL]</B>  &lt;penalty&gt; The power penalty type</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>turns gadget off in slot.<BR><B>EXAMPLE:  </B>self GadgetDeactivate( slot, weapon, GADGET_OFF_PENALTY_SHUT_OFF )<BR></OL><P>
<HR><H1>void GadgetFlickering(<I>&lt;slot&gt;</I>,<I>[flicker]</I>,<I>[length]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slot&gt; The gadget slot to test or apply flickering state. (integer)<LI>        <B>[OPTIONAL]</B>  [flicker] Set gadget to flickering state if true (boolean)<LI>        <B>[OPTIONAL]</B>  [length] Set gadget flickering length (integer)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Tests a gadget is flickering and can optionally set flickering.<BR><B>EXAMPLE:  </B>self GadgetFlickering( slot, true, 200 )<BR></OL><P>
<HR><H1>void GadgetGetSlot(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon in the player loadout.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get gadget slot for weapon.<BR><B>EXAMPLE:  </B>self GadgetGetSlot( weapon )<BR></OL><P>
<HR><H1>void GadgetIsActive(<I>&lt;slot&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slot&gt; The gadget slot to test. (integer)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the gadget is active.<BR><B>EXAMPLE:  </B>self GadgetIsActive( slot )<BR></OL><P>
<HR><H1>void GadgetIsPrimed(<I>&lt;slot&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slot&gt; The gadget slot to test. (integer)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the gadget is primed.<BR><B>EXAMPLE:  </B>self GadgetIsPrimed( slot )<BR></OL><P>
<HR><H1>void GadgetIsReady(<I>&lt;slot&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slot&gt; The gadget slot to test. (integer)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the gadget is ready.<BR><B>EXAMPLE:  </B>self GadgetIsReady( slot )<BR></OL><P>
<HR><H1>void GadgetPowerChange(<I>&lt;slot&gt;</I>,<I>&lt;change&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slot&gt; The gadget slot apply the power change. (integer)<LI>        <B>[MANDATORY]</B>  &lt;change&gt; The amount to change the power by. (float)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Applies a power change to the gadget power.<BR><B>EXAMPLE:  </B>self GadgetPowerChange( slot, -20 )<BR></OL><P>
<HR><H1>void GadgetPowerGet(<I>&lt;slot&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slot&gt; The gadget slot (integer)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the power remaining for gadget.<BR><B>EXAMPLE:  </B>power = self GadgetPowerGet( slot )<BR></OL><P>
<HR><H1>void GadgetPowerReset(<I>&lt;slot&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slot&gt; The gadget slot apply the power reset. (integer)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Applies a power reset.<BR><B>EXAMPLE:  </B>self GadgetPowerReset( slot )<BR></OL><P>
<HR><H1>void GadgetPowerSet(<I>&lt;slot&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slot&gt; The gadget slot apply the power change. (integer)<LI>        <B>[MANDATORY]</B>  &lt;value&gt; The amount to set power to. (float)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the power override to value. Works always.<BR><B>EXAMPLE:  </B>self GadgetPowerSet( slot, 100 )<BR></OL><P>
<HR><H1>entity &lt;entity&gt; GadgetPulseGetOwner()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the owner of the vision pulse you an entity is pulsed by if it exists<BR><B>EXAMPLE:  </B>entity GadgetPulseGetOwner(&lt;localclientnum&gt;)<BR></OL><P>
<HR><H1>void &lt;entity&gt; GadgetPulseResetReveal()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Resets the reveal on an entity for this player<BR><B>EXAMPLE:  </B>entity GadgetPulseResetReveal()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GadgetPulseRevealed()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Tests whether an enemy is currently revealed for this player<BR><B>EXAMPLE:  </B>reveal = entity GadgetPulseRevealed()<BR></OL><P>
<HR><H1>void GadgetSetActivateTime(<I>&lt;slot&gt;</I>,<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slot&gt; The gadget slot. (integer)<LI>        <B>[MANDATORY]</B>  &lt;time&gt; The activation time. (integer)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the activation time of this gadget.<BR><B>EXAMPLE:  </B>self GadgetSetActivateTime( slot, time )<BR></OL><P>
<HR><H1>void GadgetSetEntity(<I>&lt;slot&gt;</I>,<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slot&gt; The gadget slot.<LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The entity used by the gadget.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the entity used by this gadget.<BR><B>EXAMPLE:  </B>self GadgetSetEntity( slot, ent )<BR></OL><P>
<HR><H1>void GadgetSetInfrared(<I>&lt;localClientNum&gt;</I>,<I>&lt;bool&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number.<LI>        <B>[MANDATORY]</B>  &lt;bool&gt; 0 disables infrared, 1 enables it.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Enables or disables infrared for the gadget<BR><B>EXAMPLE:  </B>GadgetSetInfrared( localclientnum, newVal )<BR></OL><P>
<HR><H1>void GadgetStateChange(<I>&lt;slot&gt;</I>,<I>&lt;weapon&gt;</I>,<I>&lt;state&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slot&gt; The gadget slot to activate. (integer)<LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The gadget weapon<LI>        <B>[MANDATORY]</B>  &lt;state&gt; The state to change it to</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>changes the gadget state in a slot.<BR><B>EXAMPLE:  </B>self GadgetStateChange( slot )<BR></OL><P>
<HR><H1>void GadgetTargetResult(<I>&lt;hit_miss&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;hit_miss&gt; hit or miss</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>EXAMPLE:  </B>GadgetTargetResult(true)<BR></OL><P>
<HR><H1>void GameModeIsMode(<I>&lt;gamemode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;gamemode&gt; (int)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true/false if the current game mode is the given mode<BR><B>EXAMPLE:  </B>if ( GameModeIsMode( level.GAMEMODE_WAGER_MATCH ) )<BR></OL><P>
<HR><H1>void GeneratePointsAroundCenter(<I>&lt;origin&gt;</I>,<I>&lt;maxSearchRadius&gt;</I>,<I>&lt;innerSpacing&gt;</I>,<I>[minRadius]</I>,<I>&lt;innerSpacing&gt;</I>,<I>[distributionBias]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; Position to start the search around.<LI>        <B>[MANDATORY]</B>  &lt;maxSearchRadius&gt; the maximum radius away from origin.<LI>        <B>[MANDATORY]</B>  &lt;innerSpacing&gt; the distance between points at the minRadius.<LI>        <B>[OPTIONAL]</B>  [minRadius] the minimum radius away from origin. should be between 0 and maxRadius (both inclusive).<LI>        <B>[OPTIONAL]</B>  [outerSpacing] if defined, the distance between points will be Lerped from &lt;innerSpacing&gt; to [outerSpacing], to create a gradual distribution from minRadius to maxRadius.<LI>        <B>[OPTIONAL]</B>  [distributionBias] (vec2) if defined, the density of the points will be changed gradually along the direction of this vector. the magnitude will be use as scalar, with 1 being the norm scale.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>generate uniformly distributed points around a center in 2D (XY) plane<BR><B>EXAMPLE:  </B>array = GeneratePointsAroundCenter( enemy.origin, 500, 80, 100, 40, (-0.3,0,0) )<BR></OL><P>
<HR><H1>void &lt;actor&gt; GenerateScriptEvent(<I>[origin]</I>,<I>[radius]</I>,<I>[name]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [origin] Source position of the event.<LI>        <B>[OPTIONAL]</B>  [radius] Size of the event.<LI>        <B>[OPTIONAL]</B>  [name] Name of the event.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Creates a script event at the actor's origin, with default radius<BR><B>EXAMPLE:  </B>self GenerateScriptEvent()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetAbsMaxs()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get absolute maximum bounds of the entity in world space.<BR><B>EXAMPLE:  </B>absMaxs = wallModel GetAbsMaxs()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetAbsMins()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get absolute minimum bounds of the entity in world space.<BR><B>EXAMPLE:  </B>absMins = wallModel GetAbsMins()<BR></OL><P>
<HR><H1>void GetActiveLocalClients()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the number of active local clients<BR><B>EXAMPLE:  </B>active_clients = GetActiveLocalClients()<BR></OL><P>
<HR><H1>void GetActorArray(<I>[name]</I>,<I>[key]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [name] Name to search for.<LI>        <B>[OPTIONAL]</B>  [key] The key to search for.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of the human AI<BR><B>EXAMPLE:  </B>aiarray = GetActorArray( "ralph", "targetname" )<BR></OL><P>
<HR><H1>void GetActorSpawnerArray(<I>[name]</I>,<I>[key]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [name] Name to search for.<LI>        <B>[OPTIONAL]</B>  [key] The key to search for.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of all of the actor spawners in a level.<BR><B>EXAMPLE:  </B>spawners = GetSpawnerArray()<BR></OL><P>
<HR><H1>entity GetActorSpawnerTeamArray(<I>&lt;team&gt;</I>,<I>[team]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; a team name, either 'axis', 'allies', or 'neutral'<LI>        <B>[OPTIONAL]</B>  [team] any number of additional team names may be added, either 'axis', 'allies', or 'neutral'</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of all of the spawners in a level<BR><B>EXAMPLE:  </B>enemies = GetActorSpawnerTeamArray( "axis", "neutral" )<BR></OL><P>
<HR><H1>entity GetActorTeamArray(<I>&lt;team&gt;</I>,<I>[team]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; a team name, either 'axis', 'allies', or 'neutral'<LI>        <B>[OPTIONAL]</B>  [team] any number of additional team names may be added, either 'axis', 'allies', or 'neutral'</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of the human AI<BR><B>EXAMPLE:  </B>aiarray = GetActorTeamArray( "axis", "neutral" )<BR></OL><P>
<HR><H1>void GetActorTeamCountRadius(<I>&lt;origin&gt;</I>,<I>&lt;radius&gt;</I>,<I>[team]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; Center of sphere<LI>        <B>[MANDATORY]</B>  &lt;radius&gt; Radius of sphere<LI>        <B>[OPTIONAL]</B>  [team] any number of team names may be added, either 'axis', 'allies', or 'neutral' (no team implies all teams)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns number of human actor AI within a sphere on a given set of teams<BR><B>EXAMPLE:  </B>nearbyOthersCount = GetActorTeamCountRadius( self.origin, 500, "axis", "neutral" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetActorWeaponOptions()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Return's the actors current weapon options, ex: weapon camo option.<BR><B>EXAMPLE:  </B>self GetActorWeaponOptions()<BR></OL><P>
<HR><H1>entity GetAIArchetypeArray(<I>[team]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [team] a team name, either 'axis', 'allies', 'neutral', or 'all'. Defaults to 'all'.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of the AI for the given archetype and optionally given team<BR><B>EXAMPLE:  </B>aiarray = GetAIArchetypeArray( "human" )<BR></OL><P>
<HR><H1>void GetAIArray(<I>[name]</I>,<I>[key]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [name] Name to search for.<LI>        <B>[OPTIONAL]</B>  [key] The key to search for.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of the human AI<BR><B>EXAMPLE:  </B>aiarray = GetAIArray( "my_ai", "targetname" )<BR></OL><P>
<HR><H1>void GetAICount()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the current ai count.<BR><B>EXAMPLE:  </B>aicount = GetAICount()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetAIFxName(<I>&lt;localClientNum&gt;</I>,<I>&lt;aiFxBundleKey&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client to check<LI>        <B>[MANDATORY]</B>  &lt;aiFxBundleKey&gt; Script bundle key defined within the AI's aiFxTable.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns a FX name corresponding to the AI's aiFxBundle key/value pair.<BR><B>EXAMPLE:  </B>fxName = self GetAIFxName( localClientNum, surfaceTable )<BR></OL><P>
<HR><H1>void GetAILimit()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the max ai count set by script.<BR><B>EXAMPLE:  </B>ailimit = GetAILimit()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetAimAngles(<I>&lt;targetPos&gt;</I>,<I>&lt;aimTag&gt;</I>,<I>&lt;prevAimTagAngles&gt;</I>,<I>&lt;prevAimAngles&gt;</I>,<I>&lt;maxAngles&gt;</I>,<I>&lt;maxAimDeltas&gt;</I>,<I>&lt;maxTagDelta&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;targetPos&gt;<LI>        <B>[MANDATORY]</B>  &lt;aimTag&gt;<LI>        <B>[MANDATORY]</B>  &lt;prevAimTagAngles&gt;<LI>        <B>[MANDATORY]</B>  &lt;prevAimAngles&gt;<LI>        <B>[MANDATORY]</B>  &lt;maxAngles&gt;<LI>        <B>[MANDATORY]</B>  &lt;maxAimDeltas&gt;<LI>        <B>[MANDATORY]</B>  &lt;maxTagDelta&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array with the angles of the aimTag and the relative aiming delta angles from this orientation.<BR><B>EXAMPLE:  </B>aim_angles = ent GetAimAngles( shootPos, "tag_aim", (0, 30, 0), (15, 10, 0), (60, 60, 0), (5, 5, 0), 11 )<BR></OL><P>
<HR><H1>entity GetAISpeciesArray(<I>[team]</I>,<I>[species]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [team] a team name, either 'axis', 'allies', 'neutral', or 'all'. Defaults to 'all'.<LI>        <B>[OPTIONAL]</B>  [species] species of AI to get, 'human', 'dog', 'robot' or 'all'. Defaults to 'human'.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of the AI<BR><B>EXAMPLE:  </B>aiarray = GetAISpeciesArray( "axis", "all" )<BR></OL><P>
<HR><H1>entity GetAITeamArray(<I>&lt;team&gt;</I>,<I>[team]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; a team name, either 'axis', 'allies', or 'neutral'<LI>        <B>[OPTIONAL]</B>  [team] any number of additional team names may be added, either 'axis', 'allies', or 'neutral'</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of the human AI and vehicle AI<BR><B>EXAMPLE:  </B>aiarray = GetAITeamArray( "axis", "neutral" )<BR></OL><P>
<HR><H1>void GetAITriggerFlags()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the spawn flags that will allow AI to activate triggers<BR><B>EXAMPLE:  </B>spawn("trigger_radius", (0,0,0), GetAITriggerFlags())<BR></OL><P>
<HR><H1>void GetAllCharacterBodies(<I>&lt;sessionMode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;sessionMode&gt; Session Mode Index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns all character indices, even disabled ones, for the current session mode (or specified session mode)<BR><B>EXAMPLE:  </B>heroIndices = GetAllCharacterBodies()<BR></OL><P>
<HR><H1>void GetAllCharacterHeads(<I>&lt;sessionmode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;sessionmode&gt; Session Mode Index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns all character indices, even disabled ones, for the current session mode (or specified session mode)<BR><B>EXAMPLE:  </B>heroIndices = GetAllCharacterHeads()<BR></OL><P>
<HR><H1>pathnode GetAllNodes()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets all of the nodes in a level<BR><B>EXAMPLE:  </B>nodes = GetAllNodes()<BR></OL><P>
<HR><H1>void GetAmmoCount(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon for which we need ammo count</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the count of ammo left<BR><B>EXAMPLE:  </B>n_ammo = self GetAmmoCount( w_weapon )<BR></OL><P>
<HR><H1>void GetAngleDelta(<I>&lt;animation name&gt;</I>,<I>[start time]</I>,<I>[end time]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation name&gt; Name of the animation<LI>        <B>[OPTIONAL]</B>  [start time] Start time of the animation<LI>        <B>[OPTIONAL]</B>  [end time] End time of the animation</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the angle delta of the animation<BR><B>EXAMPLE:  </B>angleDelta = getAngleDelta( arrivalAnim, 0, normalizedLength )<BR></OL><P>
<HR><H1>void GetAngleFromBits()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the angle (0 - 360) from the (compressed) bits<BR><B>EXAMPLE:  </B>yaw = GetAngleFromBits( bits, 3 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetAngles()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the rotation of the entity<BR><B>EXAMPLE:  </B>angles = self GetAngles()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetAnimCurrFrameCount(<I>&lt;animation&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; a primitive animation: calling this function on a non-primitive animation will fail</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get current frame for the given animation when its running.<BR><B>EXAMPLE:  </B>CurrFrameNum = GetAnimCurrFrameCount(climbAnim)<BR></OL><P>
<HR><H1>void GetAnimForCharacter(<I>&lt;characterIndex&gt;</I>,<I>&lt;sessionmode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;characterIndex&gt; The index of the character in the current game-mode's character table<LI>        <B>[MANDATORY]</B>  &lt;sessionmode&gt; Session Mode Index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the name of the animation to use for the character pose in the frontend<BR><B>EXAMPLE:  </B>frontendVignetteAnim = GetAnimForCharacter( characterIndex, "mp" )<BR></OL><P>
<HR><H1>void GetAnimFrameCount(<I>&lt;animation&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; a primitive animation: calling this function on a non-primitive animation will fail</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get total number of frames for the given animation.<BR><B>EXAMPLE:  </B>FrameNum = GetAnimFrameCount(climbAnim)<BR></OL><P>
<HR><H1>void GetAnimLength(<I>&lt;animation&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; a primitive animation: calling this function on a non-primitive animation will fail</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the length of an animation<BR><B>EXAMPLE:  </B>cycleTime = GetAnimLength( climbAnim )<BR></OL><P>
<HR><H1>void GetAnimStateCategory()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the current anim state category for an Actor.<BR><B>EXAMPLE:  </B>category = GetAnimStateCategory( )<BR></OL><P>
<HR><H1>void GetAnimTagOrigin(<I>&lt;animation name&gt;</I>,<I>&lt;normalized time&gt;</I>,<I>&lt;tag name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation name&gt; Name of the animation.<LI>        <B>[MANDATORY]</B>  &lt;normalized time&gt; 0.0 to 1.0 time within the animation.<LI>        <B>[MANDATORY]</B>  &lt;tag name&gt; Name of the tag to look up within the animation.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the local tag position within the animation at the specified normalized time, has no consideration to bone hierarchy.<BR><B>EXAMPLE:  </B>tagPosition = GetAnimTagOrigin( arrivalAnim, 0, "tag_sync" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetAnimTime(<I>&lt;animation&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; animation to manipulate</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the normalized animation time for the given animation.<BR><B>EXAMPLE:  </B>if ( (self GetAnimTime( %walk_and_run_loops ) ) &lt; 0.5 )<BR></OL><P>
<HR><H1>pathnode GetAnyNodeArray(<I>&lt;pos&gt;</I>,<I>&lt;radius&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;pos&gt; search origin<LI>        <B>[MANDATORY]</B>  &lt;radius&gt; radius to search within</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets an array of nodes within given radius<BR><B>EXAMPLE:  </B>node = GetCoverNodeArray( self.origin, 256 )<BR></OL><P>
<HR><H1>void GetArchetypeFromClassname()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Given classname, returns archetype name if its an AITYPE or VEHICLE.<BR><B>EXAMPLE:  </B>GetArchetypeFromClassname("spawner_enemy_54i_human_sniper_sniperrifle")<BR></OL><P>
<HR><H1>void GetAssignedTeam(<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns the player's team as assigned by matchmaking. 0 = No Team, 1 = OpFor, 2 = Allies, 3 = Spectator.<BR><B>EXAMPLE:  </B>team = GetAssignedTeam( player )<BR></OL><P>
<HR><H1>void GetAssignedTeamName(<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns the player's team as assigned by matchmaking. 0 = No Team, 1 = OpFor, 2 = Allies, 3 = Spectator.<BR><B>EXAMPLE:  </B>team = GetAssignedTeam( player )<BR></OL><P>
<HR><H1>void GetAtrLoaded()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>return an array of anim tree name loaded onto the server.<BR><B>EXAMPLE:  </B>trees = GetAtrLoaded()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetAttachIgnoreCollision(<I>&lt;modelindex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;modelindex&gt; The index of the model attached to the entity, starting at 0, so for instance 3 will get the fourth model attached. (integer)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the ignore collision flag of the attached model at the given attachment slot<BR><B>EXAMPLE:  </B>model_ignore_collision = self GetAttachIgnoreCollision( index )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetAttachmentCosmeticVariantForWeapon(<I>&lt;custom Class&gt;</I>,<I>&lt;loadoutSlot&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;custom Class&gt; Class Num<LI>        <B>[MANDATORY]</B>  &lt;loadoutSlot&gt; Loadout Slot (primary or secondary)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the AttachmentCosmeticVariantIndexes data to be passed in to GetWeapon<BR><B>EXAMPLE:  </B>acvi = self GetAttachmentCosmeticVariantForWeapon( class_num, "primary" )<BR></OL><P>
<HR><H1>void GetAttachmentCosmeticVariantIndexes(<I>&lt;weaponname&gt;</I>,<I>[attachmentname_1]</I>,<I>[variantindex_1]</I>,<I>[attachmentname_2]</I>,<I>[variantindex_2]</I>,<I>[attachmentname_3]</I>,<I>[variantindex_3]</I>,<I>[attachmentname_4]</I>,<I>[variantindex_4]</I>,<I>[attachmentname_5]</I>,<I>[variantindex_5]</I>,<I>[attachmentname_6]</I>,<I>[variantindex_6]</I>,<I>[attachmentname_7]</I>,<I>[variantindex_7]</I>,<I>[attachmentname_8]</I>,<I>[variantindex_8]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weaponname&gt; the name of the base weapon to return<LI>        <B>[OPTIONAL]</B>  [attachmentname_1] the name of the first attachment<LI>        <B>[OPTIONAL]</B>  [variantindex_1] the index of the cosmetic variant to use for the first attachment<LI>        <B>[OPTIONAL]</B>  [attachmentname_2] the name of the second attachment<LI>        <B>[OPTIONAL]</B>  [variantindex_2] the index of the cosmetic variant to use for the second attachment<LI>        <B>[OPTIONAL]</B>  [attachmentname_3] the name of the third attachment<LI>        <B>[OPTIONAL]</B>  [variantindex_3] the index of the cosmetic variant to use for the third attachment<LI>        <B>[OPTIONAL]</B>  [attachmentname_4] the name of the fourth attachment<LI>        <B>[OPTIONAL]</B>  [variantindex_4] the index of the cosmetic variant to use for the fourth attachment<LI>        <B>[OPTIONAL]</B>  [attachmentname_5] the name of the fifth attachment<LI>        <B>[OPTIONAL]</B>  [variantindex_5] the index of the cosmetic variant to use for the fifth attachment<LI>        <B>[OPTIONAL]</B>  [attachmentname_6] the name of the sixth attachment<LI>        <B>[OPTIONAL]</B>  [variantindex_6] the index of the cosmetic variant to use for the sixth attachment<LI>        <B>[OPTIONAL]</B>  [attachmentname_7] the name of the seventh attachment<LI>        <B>[OPTIONAL]</B>  [variantindex_7] the index of the cosmetic variant to use for the seventh attachment<LI>        <B>[OPTIONAL]</B>  [attachmentname_8] the name of the eighth attachment<LI>        <B>[OPTIONAL]</B>  [variantindex_8] the index of the cosmetic variant to use for the eighth attachment</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the AttachmentCosmeticVariantIndexes data to be passed in to GetWeapon<BR><B>EXAMPLE:  </B>GetAttachmentCosmeticVariantIndexes( "mp7_mp", "acog", 2, "grip", 1 )<BR></OL><P>
<HR><H1>void GetAttachmentNames()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns array containing the names for each type of attachment.<BR><B>EXAMPLE:  </B>attachmentNames = GetAttachmentNames()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetAttachModelName(<I>&lt;modelindex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;modelindex&gt; The index of the model attached to the entity, starting at 0, so for instance 3 will get the fourth model attached. (integer)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the name of the attached model at the given attachment slot<BR><B>EXAMPLE:  </B>model_name = self GetAttachModelName( index )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetAttachSize()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the number of attached models for this entity.<BR><B>EXAMPLE:  </B>size = self GetAttachSize()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetAttachTagName(<I>&lt;modelindex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;modelindex&gt; The index of the model attached to the entity, starting at 0, so for instance 3 will get the fourth model attached. (integer)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the tagname of the attached model at the given attachment slot<BR><B>EXAMPLE:  </B>tag_name = self GetAttachTagName( index )<BR></OL><P>
<HR><H1>void GetBaseWeaponItemIndex(<I>&lt;weaponName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weaponName&gt; full weapon name e.g. m16_acog_mp.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the base weapon item index from the statstable<BR><B>EXAMPLE:  </B>baseWeaponName = GetBaseWeaponItemIndex( "m16_acog_mp" )<BR></OL><P>
<HR><H1>void &lt;ai&gt; GetBestInfluencepos(<I>&lt;index&gt;</I>,<I>&lt;low&gt;</I>,<I>&lt;high&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;index&gt; which influence map to use<LI>        <B>[MANDATORY]</B>  &lt;low&gt; the low threshold value to check against<LI>        <B>[MANDATORY]</B>  &lt;high&gt; the high threshold value to check against</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns the influence map position for ai, this is custom logic to return the closest posistion between the passed in thresholds<BR><B>EXAMPLE:  </B>dir = self GetBestInfluencePos( index, low, high)<BR></OL><P>
<HR><H1>entity GetBestSpawnPoint(<I>&lt;point team&gt;</I>,<I>&lt;influencer team&gt;</I>,<I>&lt;vis team&gt;</I>,<I>[player]</I>,<I>[predictedSpawn]</I>,<I>[array of lists]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;point team&gt; Team that we need the points for<LI>        <B>[MANDATORY]</B>  &lt;influencer team&gt; Influencer teams to compare the points against<LI>        <B>[MANDATORY]</B>  &lt;vis team&gt; Team mask to use for enemy vis tests<LI>        <B>[OPTIONAL]</B>  [player] Player that we want the points for.  The first parameter will still be used for the team.<LI>        <B>[OPTIONAL]</B>  [predictedSpawn] true if this is a predicted spawn request (used by texture streaming).<LI>        <B>[OPTIONAL]</B>  [array of lists] if provided, the spawn point will be chosen from one of these lists. If a list is disabled already for a given team, it will not be considered.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns a sorted array of spawnpoints in order from best to worst for the given team<BR><B>EXAMPLE:  </B>GetSortedSpawnPoints()<BR></OL><P>
<HR><H1>void GetBitsForAngle()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the compressed bits for an angle with &lt;num bits&gt; granularity<BR><B>EXAMPLE:  </B>bits = GetBitsForAngle( angle, 3 )<BR></OL><P>
<HR><H1>void GetBodyAccentColorCountForHero(<I>&lt;localClientNum&gt;</I>,<I>&lt;sessionMode&gt;</I>,<I>&lt;heroIndex&gt;</I>,<I>&lt;bodyIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;sessionMode&gt; The character's sessionMode<LI>        <B>[MANDATORY]</B>  &lt;heroIndex&gt; The index of the hero in the current game-mode's character table<LI>        <B>[MANDATORY]</B>  &lt;bodyIndex&gt; The index of the body for the specific hero</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the number of accents for the specified body model of a specific hero<BR><B>EXAMPLE:  </B>modelName = GetBodyAccentColorCountForHero( localClientNum, 0, 0 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetBodyRenderOptionsPacked()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Gets the packed value of body render options (body type, style, colors)<BR><B>EXAMPLE:  </B>gibEntity GetBodyRenderOptionsPacked()<BR></OL><P>
<HR><H1>void GetBrushModelCenter(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The brush model entity</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the center of the Brush Model entity<BR><B>EXAMPLE:  </B>center = GetBrushModelCenter( self )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetBuildKitAttachmentCosmeticVariantIndexes(<I>&lt;weapon&gt;</I>,<I>&lt;upgraded&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; weapon object<LI>        <B>[OPTIONAL]</B>  &lt;upgraded&gt; bool whether this should be the upgraded version. If so extclip and fmj will be added</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get attachment cosmetic variant indexes for the weapon from the player's build kit<BR><B>EXAMPLE:  </B>acvi = self GetBuildKitAttachmentCosmeticVariantIndexes( ar_standard )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetBuildKitWeapon(<I>&lt;weapon&gt;</I>,<I>&lt;upgraded&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; weapon object<LI>        <B>[OPTIONAL]</B>  &lt;upgraded&gt; bool whether this should be the upgraded version. If so extclip and fmj will be added</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get weapon object (including attachments) for the weapon from the player's build kit<BR><B>EXAMPLE:  </B>weapon = self GetBuildKitWeapon( ar_standard )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetBuildKitWeaponOptions(<I>&lt;weapon&gt;</I>,<I>[camo_index]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; weapon object<LI>        <B>[OPTIONAL]</B>  [camo_index] camo index to override the one from the build kit, typically a packapunch camo index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get weapon options for the weapon from the player's build kit<BR><B>EXAMPLE:  </B>weapon_options = self GetBuildKitWeaponOptions( ar_standard, packapunch_camo_index )<BR></OL><P>
<HR><H1>void GetCamAngles()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the camera view angles<BR><B>EXAMPLE:  </B>player GetCamPos()<BR></OL><P>
<HR><H1>void GetCamAnglesByLocalClientNum(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the camera angles of the local client given<BR><B>EXAMPLE:  </B>cam_angles = GetCamAnglesByLocalClientNum( 0 )<BR></OL><P>
<HR><H1>void GetCamAnimTime(<I>&lt;cam_anim&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;cam_anim&gt; The animation to play</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the duration of an xcam in milliseconds.<BR><B>EXAMPLE:  </B>GetCamAnimTime( "proto_melee_cam" )<BR></OL><P>
<HR><H1>void GetCamPos()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the camera position<BR><B>EXAMPLE:  </B>player GetCamPos()<BR></OL><P>
<HR><H1>void GetCamPosByLocalClientNum(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the camera position of the local client given<BR><B>EXAMPLE:  </B>cam_origin = GetCamPosByLocalClientNum( 0 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetCentroid()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the centroid of an entity<BR><B>EXAMPLE:  </B>centroid = self GetCentroid()<BR></OL><P>
<HR><H1>void GetCharacterAssetName(<I>&lt;characterIndex&gt;</I>,<I>&lt;sessionmode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;characterIndex&gt; The index of the character in the current game-mode's character table<LI>        <B>[MANDATORY]</B>  &lt;sessionmode&gt; Session Mode Index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the asset name for a character for the current session mode<BR><B>EXAMPLE:  </B>heroName = GetCharacterAssetName( characterIndex, "mp" )<BR></OL><P>
<HR><H1>void GetCharacterBodyModelColorCount(<I>&lt;characterIndex&gt;</I>,<I>&lt;bodyStyleIndex&gt;</I>,<I>&lt;sessionmode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;characterIndex&gt; The index of the character in the current game-mode's character table<LI>        <B>[MANDATORY]</B>  &lt;bodyStyleIndex&gt; The index of the body style in the character<LI>        <B>[MANDATORY]</B>  &lt;sessionmode&gt; Session Mode Index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the body model count for a character for the current session mode<BR><B>EXAMPLE:  </B>heroBodyModelCount = GetCharacterBodyModelCount( characterIndex, "mp" )<BR></OL><P>
<HR><H1>void GetCharacterBodyModelCount(<I>&lt;characterIndex&gt;</I>,<I>&lt;sessionMode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;characterIndex&gt; The index of the character in the current game-mode's character table<LI>        <B>[MANDATORY]</B>  &lt;sessionMode&gt; Session Mode Index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the body model count for a character for the current session mode<BR><B>EXAMPLE:  </B>heroBodyModelCount = GetCharacterBodyModelCount( characterIndex, "mp" )<BR></OL><P>
<HR><H1>void GetCharacterBodyStyleIndex(<I>&lt;gender&gt;</I>,<I>&lt;bodyStyleDisplayName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;gender&gt; Whether or not to use the male bodytype<LI>        <B>[MANDATORY]</B>  &lt;bodyStyleDisplayName&gt; The name of the body style</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the index of the body style designated by the given display name<BR><B>EXAMPLE:  </B>bodyStyleIndex = GetCharacterBodyStyleIndex( true, "Technomancer" )<BR></OL><P>
<HR><H1>void GetCharacterCustomizationForXUID(<I>&lt;localClientNum&gt;</I>,<I>&lt;xuid&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;xuid&gt; The xuid of the player to get customization for</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>EXAMPLE:  </B>GetCharacterCustomizationForXUID( &lt;xuid&gt;)<BR></OL><P>
<HR><H1>void GetCharacterDisplayName(<I>&lt;characterIndex&gt;</I>,<I>&lt;sessionmode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;characterIndex&gt; The index of the character in the current game-mode's character table<LI>        <B>[MANDATORY]</B>  &lt;sessionmode&gt; Session Mode Index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the display name for a character for the current session mode<BR><B>EXAMPLE:  </B>heroName = GetCharacterDisplayName( characterIndex, "mp" )<BR></OL><P>
<HR><H1>void GetCharacterFields(<I>&lt;characterIndex&gt;</I>,<I>&lt;sessionmode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;characterIndex&gt; The index of the character in the current game-mode's character table<LI>        <B>[MANDATORY]</B>  &lt;sessionmode&gt; Session Mode Index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns info for the character pose playerbodytype<BR><B>EXAMPLE:  </B>heroFields = GetCharacterFields( characterIndex, "mp" )<BR></OL><P>
<HR><H1>void GetCharacterHeadRenderOptions(<I>&lt;headIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;headIndex&gt; The index of the character in the current game-mode's character table</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Calculates the packed helmet render option - to be passed to SetBodyRenderOptions()<BR><B>EXAMPLE:  </B>helmetRenderOptions = GetCharacterHeadRenderOptions( 0 )<BR></OL><P>
<HR><H1>void GetCharacterHelmetHidesHead(<I>&lt;characterIndex&gt;</I>,<I>&lt;helmetIndex&gt;</I>,<I>&lt;sessionMode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;characterIndex&gt; The index of the character in the current game-mode's character table<LI>        <B>[MANDATORY]</B>  &lt;helmetIndex&gt; The index of the helmet belonging to that character<LI>        <B>[MANDATORY]</B>  &lt;sessionMode&gt; The session mode ( mp cp zm )</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns whether or not the characters head should be hidden based on the helmet<BR><B>EXAMPLE:  </B>hideHead = GetCharacterHelmetHidesHead( 0, 0, 0 )<BR></OL><P>
<HR><H1>void GetCharacterHelmetModelColorCount(<I>&lt;characterIndex&gt;</I>,<I>&lt;helmetStyleIndex&gt;</I>,<I>&lt;sessionmode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;characterIndex&gt; The index of the character in the current game-mode's character table<LI>        <B>[MANDATORY]</B>  &lt;helmetStyleIndex&gt; The index of the helmet style in the character<LI>        <B>[MANDATORY]</B>  &lt;sessionmode&gt; Session Mode Index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the helmet model count for a character for the current session mode<BR><B>EXAMPLE:  </B>heroHelmetModelCount = GetCharacterHelmetModelCount( characterIndex, "mp" )<BR></OL><P>
<HR><H1>void GetCharacterHelmetModelCount(<I>&lt;characterIndex&gt;</I>,<I>&lt;sessionmode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;characterIndex&gt; The index of the character in the current game-mode's character table<LI>        <B>[MANDATORY]</B>  &lt;sessionmode&gt; Session Mode Index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the helmet model count for a character for the current session mode<BR><B>EXAMPLE:  </B>heroHelmetModelCount = GetCharacterHelmetModelCount( characterIndex, "mp" )<BR></OL><P>
<HR><H1>void GetCharacterHelmetRenderOptions(<I>&lt;characterIndex&gt;</I>,<I>&lt;helmetIndex&gt;</I>,<I>&lt;colorIndex1&gt;</I>,<I>&lt;colorIndex2&gt;</I>,<I>&lt;colorIndex3&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;characterIndex&gt; The index of the character in the current game-mode's character table<LI>        <B>[MANDATORY]</B>  &lt;helmetIndex&gt; The index of the helmet belonging to that character<LI>        <B>[MANDATORY]</B>  &lt;colorIndex1&gt; The index of accent color 1<LI>        <B>[MANDATORY]</B>  &lt;colorIndex2&gt; The index of accent color 2<LI>        <B>[MANDATORY]</B>  &lt;colorIndex3&gt; The index of accent color 3</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Calculates the packed helmet render option - to be passed to SetBodyRenderOptions()<BR><B>EXAMPLE:  </B>helmetRenderOptions = GetCharacterHelmetRenderOptions( 0, 1, 1, 2, 3 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetCharacterIndex()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Gets the character index<BR><B>EXAMPLE:  </B>index = self GetCharacterIndex()<BR></OL><P>
<HR><H1>void GetCharacterModeRenderOptions(<I>&lt;session_mode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;session_mode&gt; Session Mode enum index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Calculates the packed mode render option - to be passed to SetBodyRenderOptions()<BR><B>EXAMPLE:  </B>modeRenderOptions = GetCharacterModeRenderOptions( SESSIONMODE_MULTIPLAYER )<BR></OL><P>
<HR><H1>void GetClassIndexFromName(<I>&lt;className&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;className&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the index in a particular class<BR><B>EXAMPLE:  </B>GScr_GetClassIndexFromName( "CLASS_SMG" )<BR></OL><P>
<HR><H1>void GetClientFieldVersion()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the version of the specifiec client field, in the specified client field set - or 0 if the field isn't registered.<BR><B>EXAMPLE:  </B>if(GetClientFieldVersion( "world", "fog_volume_active" ))<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetClientTime()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Gets the current client time in milliseconds<BR><B>EXAMPLE:  </B>currTime = ent GetClientTime()<BR></OL><P>
<HR><H1>entity GetClones(<I>&lt;local client num&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;local client num&gt; local client</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get an array of all the clones<BR><B>EXAMPLE:  </B>clones = GetClones( localClientNum )<BR></OL><P>
<HR><H1>void GetClosestPointOnNavMesh(<I>&lt;position&gt;</I>,<I>[searchRadius]</I>,<I>[distFromBoundary]</I>,<I>[materialFlags]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; Position to start the search around.<LI>        <B>[OPTIONAL]</B>  [searchRadius] Radius to search within. If not provided, a default value proximately equal to player size will be used.<LI>        <B>[OPTIONAL]</B>  [distFromBoundary] Distance to keep away from NavMesh boundary. This distance can NOT be guaranteed. If not provided, it will be treated as 15 (AI default radius).<LI>        <B>[OPTIONAL]</B>  [materialFlags] the flags marking whether a face type can be used</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get a point on NavMesh that's closest to the given position within radius. Returns the adjusted position if found one, or undefined if not found. If distFromBoundary is defined, the point found on NavMesh will then be moved again to get it away from boundary<BR><B>EXAMPLE:  </B>posOnNavMesh = GetClosestPointOnNavMesh( (10,20,30), 25, 15 )<BR></OL><P>
<HR><H1>void &lt;flying_ai&gt; GetClosestPointOnNavVolume(<I>&lt;position&gt;</I>,<I>[searchRadius]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; Position to start the search around.<LI>        <B>[OPTIONAL]</B>  [searchRadius] Radius to search within. If not provided, a default value proximately equal to player size will be used.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get a point on nav volume that's closest to the given position within radius. Returns the adjusted position if found one, or undefined if not found.<BR><B>EXAMPLE:  </B>posOnNavVolume = self GetClosestPointOnNavVolume( (10,20,30), 25 )<BR></OL><P>
<HR><H1>void GetContractName(<I>&lt;contractIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;contractIndex&gt; Contract ID</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the name of the specified contract<BR><B>EXAMPLE:  </B>contractName = GetContractName( contractIndex )<BR></OL><P>
<HR><H1>void GetContractRequiredCount(<I>&lt;contractIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;contractIndex&gt; Contract ID</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the required count for the specified contract<BR><B>EXAMPLE:  </B>contractName = GetContractRequiredCount( contractIndex )<BR></OL><P>
<HR><H1>void GetContractRequirements(<I>&lt;contractIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;contractIndex&gt; The index of the contract</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of contract requirements. Each requirement takes up two indices, 'reqType' and 'reqData'.<BR><B>EXAMPLE:  </B>mapNames = GetContractRequirements( contractIndex )<BR></OL><P>
<HR><H1>void GetContractResetConditions(<I>&lt;contractIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;contractIndex&gt; Contract ID</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the reset conditions of the specified contract<BR><B>EXAMPLE:  </B>resetConditions = GetContractResetConditions( contractIndex )<BR></OL><P>
<HR><H1>void GetControllerPosition(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the controller you want the position of</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>get current deflection of control, returns values via an array with vector values for "look" and "move" which correspond to those controls.  Values are -1 to 1 and represent the given axis on the vector<BR><B>EXAMPLE:  </B>pos = self GetControllerPosition() ...<BR></OL><P>
<HR><H1>void GetControllerType()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns the controller type of the player<BR><B>EXAMPLE:  </B>player GetControllerType()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetCorpseAnim()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the animation that the corpse will play<BR><B>EXAMPLE:  </B>deathAnim = self GetCorpseAnim()<BR></OL><P>
<HR><H1>entity GetCorpseArray()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of all of the items in a level.<BR><B>EXAMPLE:  </B>origins = GetCorpseArray()<BR></OL><P>
<HR><H1>void GetCounterTotal(<I>&lt;counterType&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;counterType&gt; The counter type</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the counter count for the given counter<BR><B>EXAMPLE:  </B>count = GetCounterTotal( "global_comebacks" )<BR></OL><P>
<HR><H1>pathnode GetCoverNodeArray(<I>&lt;pos&gt;</I>,<I>&lt;radius&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;pos&gt; search origin<LI>        <B>[MANDATORY]</B>  &lt;radius&gt; radius to search within</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets an array of cover nodes within given radius<BR><B>EXAMPLE:  </B>node = GetCoverNodeArray( self.origin, 256 )<BR></OL><P>
<HR><H1>void GetCrateHeadObjective(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the equipment head objective as described in the grenadeweapon gdt.<BR><B>EXAMPLE:  </B>crateObjective = GetCrateHeadObjective( uav )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetCurrentAnimScriptedName()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get current frame for the given animation when its running.<BR><B>EXAMPLE:  </B>animName = GetCurrentAnimScriptedName()<BR></OL><P>
<HR><H1>void &lt;ai_or_player&gt; GetCurrentEventId()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the id from the current event.<BR><B>EXAMPLE:  </B>eventId = self GetCurrentEventId()<BR></OL><P>
<HR><H1>void &lt;ai_or_player&gt; GetCurrentEventName()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the name of the current event.<BR><B>EXAMPLE:  </B>eventId = self GetCurrentEventName()<BR></OL><P>
<HR><H1>entity &lt;ai_or_player&gt; GetCurrentEventOriginator()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the originator from the current event if any<BR><B>EXAMPLE:  </B>target = self GetCurrentEventOriginator()<BR></OL><P>
<HR><H1>void &lt;ai_or_player&gt; GetCurrentEventType()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the type from the current event.<BR><B>EXAMPLE:  </B>type = self GetCurrentEventType()<BR></OL><P>
<HR><H1>void &lt;ai_or_player&gt; GetCurrentEventTypeName()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the type string name from the current event.<BR><B>EXAMPLE:  </B>type = self GetCurrentEventTypeName()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetCurrentGunRank(<I>&lt;index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;index&gt; the index of the gun to get</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the gun current rank<BR><B>EXAMPLE:  </B>rank - GetCurrentGunRank(0)<BR></OL><P>
<HR><H1>void GetCurrentWeaponIncludingMelee(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client number of the player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the name of the weapon being used by the specified local client, and will return the melee weapon if the client is in a melee state<BR><B>EXAMPLE:  </B>currentWeapon = GetCurrentWeapon( localClientNum )<BR></OL><P>
<HR><H1>void GetCustomTeamName(<I>&lt;teamid&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;teamid&gt; TeamID</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the team name<BR><B>EXAMPLE:  </B>name = GetCustomTeamName( teamid )<BR></OL><P>
<HR><H1>void GetCyberComAbilityName(<I>&lt;flag&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flag&gt;  flag field</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the cybercom ability name given the flag, type<BR><B>EXAMPLE:  </B>GetCyberComAbilityName(  flag, type )<BR></OL><P>
<HR><H1>void getCybercomType()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Gets the active cybercom type<BR><B>EXAMPLE:  </B>cybercom_type = player getCybercomType()<BR></OL><P>
<HR><H1>void GetCyberComWeapon(<I>&lt;flag&gt;</I>,<I>&lt;type&gt;</I>,<I>&lt;upgraded&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flag&gt;  flag field<LI>        <B>[MANDATORY]</B>  &lt;type&gt; type of weapon<LI>        <B>[MANDATORY]</B>  &lt;upgraded&gt; true if the weapon is upgraded</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the cybercom gadget weapon given the flag, type, and if upgraded<BR><B>EXAMPLE:  </B>GetCyberComWeapon(  flag, type, upgraded )<BR></OL><P>
<HR><H1>entity GetDamageableEntArray(<I>[origin]</I>,<I>[radius]</I>,<I>[checkZ]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [origin] origin to check against<LI>        <B>[OPTIONAL]</B>  [radius] max distance to origin<LI>        <B>[OPTIONAL]</B>  [checkZ] if true then check distance in 3d</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the entities that can be damaged. Can optionally take an origin, radius, and a flag to check 3D.<BR><B>EXAMPLE:  </B>entities = GetDamageableEntArray( maxDist, true )<BR></OL><P>
<HR><H1>void &lt;player or actor&gt; GetDebugEye()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the debug position of the eye for an AI or Player<BR><B>EXAMPLE:  </B>eyePos = player GetDebugEye()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetDecorations(<I>[ only_decorations_earned ]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [ only_decorations_earned ] Only get the decorations that the player has earned</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets an array of booleans that represents all the decorations the player has earned<BR><B>EXAMPLE:  </B>medals = e_player GetDecorationsEarned()<BR></OL><P>
<HR><H1>void GetDefaultClassSlot(<I>&lt;classname&gt;</I>,<I>&lt;slotname&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;classname&gt; the classname of the item<LI>        <B>[MANDATORY]</B>  &lt;slotname&gt; The slot to check</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the item in a particular default class slot<BR><B>EXAMPLE:  </B>GetDefaultClassSlot( "cqb", "primary" ); // Returns primary weapon reference<BR></OL><P>
<HR><H1>void GetDemoVersion()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the demo version value<BR><B>EXAMPLE:  </B>if ( GetDemoVersion() )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetDistanceFromScreenCenter(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client to check</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the distance from the screen center to the entity<BR><B>EXAMPLE:  </B>ent GetDistanceFromScreenCenter( localClientNum )<BR></OL><P>
<HR><H1>entity GetDroppedWeapons()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array containing all the dropped weapons in the level<BR></OL><P>
<HR><H1>void getdynent(<I>&lt;targetname&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;targetname&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the dynent with the specified targetname<BR><B>EXAMPLE:  </B>twig = getdynent("twig")<BR></OL><P>
<HR><H1>void getdynentarray(<I>targetname</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  targetname</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get a dynent array with the specified targetname<BR><B>EXAMPLE:  </B>twigs = getdynentarray("twig")<BR></OL><P>
<HR><H1>entity &lt;entity&gt; GetEnemies()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of enemies.<BR><B>EXAMPLE:  </B>enemies = self GetEnemies()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetEnemyScramblerAmount()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the amount alpha of the enemy scrambler applied<BR><B>EXAMPLE:  </B>alpha = player GetEnemyScramblerAmount( )<BR></OL><P>
<HR><H1>entity GetEnt(<I>&lt;name&gt;</I>,<I>&lt;key&gt;</I>,<I>[ignore spawners]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; name to search for<LI>        <B>[MANDATORY]</B>  &lt;key&gt; key that name goes with<LI>        <B>[OPTIONAL]</B>  [ignore spawners] if true then you won't get a spawner back</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Looks up entities by key and name<BR><B>EXAMPLE:  </B>spawner = GetEnt( "doorguy1", "targetname" )<BR></OL><P>
<HR><H1>entity GetEntArray(<I>[name]</I>,<I>[key]</I>,<I>[ignore spawners]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [name] name to search for<LI>        <B>[OPTIONAL]</B>  [key] key that name goes with<LI>        <B>[OPTIONAL]</B>  [ignore spawners] if true then you won't get a spawner back</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Looks up entities by key and name and a return an array of the matched entities<BR><B>EXAMPLE:  </B>spawners = GetEntArray( "doorguy1", "targetname" )<BR></OL><P>
<HR><H1>entity GetEntArrayByType(<I>&lt;localclientnum&gt;</I>,<I>&lt;type&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localclientnum&gt; Which local client's entity list to use.<LI>        <B>[MANDATORY]</B>  &lt;type&gt; Type of the entity. Look into shared.gsh for the ET enum</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Gets an array of entities that have the given the type of the entity ( for example, ET_MISSILE )<BR><B>EXAMPLE:  </B>grenades = GetEntArray( 0, ET_MISSILE )<BR></OL><P>
<HR><H1>entity GetEntArrayFromArray(<I>&lt;array&gt;</I>,<I>&lt;name&gt;</I>,<I>&lt;key&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;array&gt; array of entities<LI>        <B>[MANDATORY]</B>  &lt;name&gt; name to search for<LI>        <B>[MANDATORY]</B>  &lt;key&gt; key that name goes with</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Searches given array entities by key and name and a return an array of the matched entities<BR><B>EXAMPLE:  </B>spawners = GetEntArrayFromArray( array, "doorguy1", "targetname" )<BR></OL><P>
<HR><H1>entity GetEntByNum(<I>&lt;entity number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity number&gt;(integer) The number of the entity to get</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets an entity from its entity number<BR><B>EXAMPLE:  </B>entity = GetEntByNum( entnum )<BR></OL><P>
<HR><H1>void getEnterButton()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the enter button.<BR><B>EXAMPLE:  </B>getEnterButton()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetEntityAnimRate()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>get the entity animation rate - ZOMBIES ONLY<BR><B>EXAMPLE:  </B>rate = self GetEntityAnimRate()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetEntityNumber()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the entity number of the entity<BR><B>EXAMPLE:  </B>hitEntNum = hitEnt getEntityNumber()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetEntityType()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the type of entity<BR><B>EXAMPLE:  </B>inflictorEntType = grenade getEntityType()<BR></OL><P>
<HR><H1>void GetEntNavMaterial(<I>&lt;ai_or_vehicle&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;ai_or_vehicle&gt; An AI character or an AI vehicle</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>get NavMesh material at where the entity stands<BR><B>EXAMPLE:  </B>material = GetEntNavMaterial( ai_actor )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetEntNum()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the entity number for this entity<BR><B>EXAMPLE:  </B>self GetEntNum()<BR></OL><P>
<HR><H1>void GetEquipmentHeadObjective(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the equipment head objective as described in the grenadeweapon gdt.<BR><B>EXAMPLE:  </B>headObjective = GetEquipmentHeadObjective( bouncingbettty )<BR></OL><P>
<HR><H1>void GetEquippedBodyAccentColorForHero(<I>&lt;localClientNum&gt;</I>,<I>&lt;sessionMode&gt;</I>,<I>&lt;heroIndex&gt;</I>,<I>&lt;bodyIndex&gt;</I>,<I>&lt;colorIndex&gt;</I>,<I>[getForLobbyClient]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;sessionMode&gt; The character's session mode<LI>        <B>[MANDATORY]</B>  &lt;heroIndex&gt; The index of the hero in the current game-mode's character table or in case of lobby client, his queue position<LI>        <B>[MANDATORY]</B>  &lt;bodyIndex&gt; The index of the body<LI>        <B>[MANDATORY]</B>  &lt;colorIndex&gt; The index of the accent color<LI>        <B>[OPTIONAL]</B>  [getForLobbyClient] If this is set then we are supposed to retrieve for lobby client</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns an array of the equipped body accent colors of a specific hero<BR><B>EXAMPLE:  </B>colorArray = GetEquippedBodyAccentColorForHero( localClientNum, 0 )<BR></OL><P>
<HR><H1>void GetEquippedBodyForHero(<I>&lt;localClientNum&gt;</I>,<I>&lt;sessionMode&gt;</I>,<I>&lt;heroIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;sessionMode&gt; The character's sessionMode<LI>        <B>[MANDATORY]</B>  &lt;heroIndex&gt; The index of the hero in the current game-mode's character table</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the name of the equipped body model of a specific hero<BR><B>EXAMPLE:  </B>modelName = GetEquippedBodyForHero( localClientNum, SESSIONMODE_MULTIPLAYER, 0 )<BR></OL><P>
<HR><H1>void GetEquippedBodyIndexForHero(<I>&lt;localClientNum&gt;</I>,<I>&lt;sessionMode&gt;</I>,<I>&lt;heroIndex&gt;</I>,<I>[getForLobbyClient]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;sessionMode&gt;Character Session Mode<LI>        <B>[MANDATORY]</B>  &lt;heroIndex&gt; The index of the hero in the current game-mode's character table or in case of lobby client, his queue position<LI>        <B>[OPTIONAL]</B>  [getForLobbyClient] If this is set then we are supposed to retrieve for lobby client</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the index of the equipped body model of a specific hero<BR><B>EXAMPLE:  </B>bodyIndex = GetEquippedBodyIndexForHero( localClientNum, 0 )<BR></OL><P>
<HR><H1>void GetEquippedCharacterIndexForLobbyClientHero(<I>&lt;localClientNum&gt;</I>,<I>&lt;lobbyClientQueueIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;lobbyClientQueueIndex&gt; Queue index for lobby client, from which we get all his other information</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the name of the equipped helmet accents colors of a specific hero<BR><B>EXAMPLE:  </B>colorArray = GetEquippedHelmetAccentColorForHero( localClientNum, 0 )<BR></OL><P>
<HR><H1>void GetEquippedHeadIndexForHero(<I>&lt;localClientNum&gt;</I>,<I>&lt;sessionMode&gt;</I>,<I>&lt;getForLobbyClient&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;sessionMode&gt; The character's sessionMode<LI>        <B>[OPTIONAL]</B>  &lt;getForLobbyClient&gt; If this is set then check for the equipped head on the client in the lobbyQueueIndex position</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the index of the equipped head index<BR><B>EXAMPLE:  </B>helmetIndex = GetEquippedHeadIndexForHero( localClientNum )<BR></OL><P>
<HR><H1>void GetEquippedHelmetAccentColorForHero(<I>&lt;localClientNum&gt;</I>,<I>&lt;sessionMode&gt;</I>,<I>&lt;heroIndex&gt;</I>,<I>&lt;helmetIndex&gt;</I>,<I>&lt;colorIndex&gt;</I>,<I>[getForLobbyClient]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;sessionMode&gt; The character session mode<LI>        <B>[MANDATORY]</B>  &lt;heroIndex&gt; The index of the hero in the current game-mode's character table<LI>        <B>[MANDATORY]</B>  &lt;helmetIndex&gt; The index of the helmet<LI>        <B>[MANDATORY]</B>  &lt;colorIndex&gt; The index of the accent color<LI>        <B>[OPTIONAL]</B>  [getForLobbyClient] If this is set then we are supposed to retrieve for lobby client</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the name of the equipped helmet accents colors of a specific hero<BR><B>EXAMPLE:  </B>colorArray = GetEquippedHelmetAccentColorForHero( localClientNum, 0 )<BR></OL><P>
<HR><H1>void GetEquippedHelmetForHero(<I>&lt;localClientNum&gt;</I>,<I>&lt;sessionMode&gt;</I>,<I>&lt;heroIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;sessionMode&gt; The character's sessionMode<LI>        <B>[MANDATORY]</B>  &lt;heroIndex&gt; The index of the hero in the current game-mode's character table</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the name of the equipped helmet model of a specific hero<BR><B>EXAMPLE:  </B>modelName = GetEquippedHelmetForHero( localClientNum, SESSIONMODE_MULTIPLAYER, 0 )<BR></OL><P>
<HR><H1>void GetEquippedHelmetIndexForHero(<I>&lt;localClientNum&gt;</I>,<I>&lt;sessionMode&gt;</I>,<I>&lt;heroIndex&gt;</I>,<I>[getForLobbyClient]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;sessionMode&gt; The character's sessionMode<LI>        <B>[MANDATORY]</B>  &lt;heroIndex&gt; The index of the hero in the current game-mode's character table or in case of lobby client, his queue position<LI>        <B>[OPTIONAL]</B>  [getForLobbyClient] If this is set then we are supposed to retrieve for lobby client</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the index of the equipped helmet index of a specific hero<BR><B>EXAMPLE:  </B>helmetIndex = GetEquippedHelmetIndexForHero( localClientNum, 0 )<BR></OL><P>
<HR><H1>void GetEquippedHeroIndex(<I>&lt;localClientNum&gt;</I>,<I>&lt;sessionMode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;sessionMode&gt; The character's sessionMode</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the index of the equipped hero for the client<BR><B>EXAMPLE:  </B>heroIndex = GetEquippedHeroIndex( localClientNum )<BR></OL><P>
<HR><H1>void GetEquippedHeroMode(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the mode of the equipped hero for the client<BR><B>EXAMPLE:  </B>heroIndex = GetEquippedHeroMode( localClientNum )<BR></OL><P>
<HR><H1>void GetEquippedLoadoutItemForHero(<I>&lt;localClientNum&gt;</I>,<I>&lt;heroIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;heroIndex&gt; The index of the hero in the current game-mode's character table</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns 1 if the hero's ability is equipped, 0 if the weapon is equipped.<BR><B>EXAMPLE:  </B>isAbilityEquipped = GetEquippedLoadoutItemForHero( localClientNum, 0 )<BR></OL><P>
<HR><H1>void GetEquippedShowcaseWeaponForHero(<I>&lt;localClientNum&gt;</I>,<I>&lt;sessionMode&gt;</I>,<I>&lt;heroIndex&gt;</I>,<I>[getForLobbyClient]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;sessionMode&gt; The character's sessionMode<LI>        <B>[MANDATORY]</B>  &lt;heroIndex&gt; The index of the hero in the current game-mode's character table or in case of lobby client, his queue position<LI>        <B>[OPTIONAL]</B>  [getForLobbyClient] If this is set then we are supposed to retrieve for lobby client</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the showcase weapon of a specific hero<BR><B>EXAMPLE:  </B>showcaseWeapon = GetEquippedShowcaseWeaponForHero( localClientNum, 0 )<BR></OL><P>
<HR><H1>void &lt;ai_or_player&gt; GetEventPointOfInterest()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the point of interest from the current event.<BR><B>EXAMPLE:  </B>point = self GetEventPointOfInterest()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetEye()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the eye position of the entity.<BR><B>EXAMPLE:  </B>eye_pos = self GetEye()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetEyeApprox()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the eye position of the entity with some added offset.<BR><B>EXAMPLE:  </B>approx_eye_pos = self GetEyeGetEyeApprox()<BR></OL><P>
<HR><H1>void GetFirstHeadOfGender(<I>&lt;gender&gt;</I>,<I>[sessionmode]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;gender&gt; "male" or "female"<LI>        <B>[OPTIONAL]</B>  [sessionmode] The session mode (cp,mp,zm)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the first head of gender ("male" or "female")<BR><B>EXAMPLE:  </B>headIndex = GetFirstHeadOfGender( "male", "mp" )<BR></OL><P>
<HR><H1>void GetFirstHeroOfGender(<I>&lt;gender&gt;</I>,<I>[sessionmode]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;gender&gt; "male" or "female"<LI>        <B>[OPTIONAL]</B>  [sessionmode] The session mode (cp,mp,zm)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the first hero of gender ("male" or "female")<BR><B>EXAMPLE:  </B>characterIndex = GetFirstHeroOfGender( "male", "mp" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetFirstTouchFraction(<I>&lt;other entity&gt;</I>,<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;other entity&gt; Entity to check against<LI>        <B>[MANDATORY]</B>  &lt;start&gt; Starting point of the trace<LI>        <B>[MANDATORY]</B>  &lt;end&gt; Ending point of the trace</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the trace fraction of a capsule trace against the other entity<BR><B>EXAMPLE:  </B>fraction = GetFirstTouchFraction( player, trigger, old_origin, current_origin )<BR></OL><P>
<HR><H1>void GetFlowGraphDef(<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; The name of the flow graph asset</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>returns a struct representing the flow graph definition asset<BR><B>EXAMPLE:  </B>flowGraphDef = GetFlowGraphDef( "my_flow_graph" )<BR></OL><P>
<HR><H1>void GetFogSettings()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the current fog settings as an array.<BR><B>EXAMPLE:  </B>fogsettings = getfogsettings()<BR></OL><P>
<HR><H1>void GetFootstepStrings()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns an array containing all the footstep names<BR><B>EXAMPLE:  </B>footstepNameArray = GetFootstepStrings()<BR></OL><P>
<HR><H1>void GetFreeActorCount()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get number of free actors.<BR><B>EXAMPLE:  </B>GetFreeActorCount()<BR></OL><P>
<HR><H1>void GetFreerunTrackIndex(<I>[currentmap]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [currentmap] the name of the current map.  If ommitted, use Dvar sv_mapname</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the unique id for this mission<BR><B>EXAMPLE:  </B>level.index = GetFreerunTrackIndex( "mp_Freerun_01" )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetFriendlyScramblerAmount()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the amount alpha of the friendly scrambler applied<BR><B>EXAMPLE:  </B>alpha = player GetFriendlyScramblerAmount( )<BR></OL><P>
<HR><H1>void GetGadgetPower(<I>&lt;localClientNum&gt;</I>,<I>[slot]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the player<LI>        <B>[OPTIONAL]</B>  [slot] Slot of the gadget. Default is 0.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the current power level of the player gadget<BR><B>EXAMPLE:  </B>power = GetGadgetPower( localClientNum )<BR></OL><P>
<HR><H1>void GetGameTypeEnumFromName(<I>&lt;gameTypeName&gt;</I>,<I>&lt;isHardcore&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;gameTypeName&gt; game type name e.g. "tdm".<LI>        <B>[MANDATORY]</B>  &lt;isHardcore&gt; True if the hardcore mode is on</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the enum value corresponding to the current game type from global leaderboard gametype entries.<BR><B>EXAMPLE:  </B>gameTypeEnum = GetGameTypeEnumFromName( "tdm", false )<BR></OL><P>
<HR><H1>void GetGametypeSetting(<I>&lt;setting&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;setting&gt; The setting name as a string.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the value of a gametype setting.<BR><B>EXAMPLE:  </B>GetGametypeSetting( "scoreLimit" )<BR></OL><P>
<HR><H1>entity GetGrappleTargetArray()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of all of the grapple targets<BR><B>EXAMPLE:  </B>enemies = GetGrappleTargetArray()<BR></OL><P>
<HR><H1>entity &lt;entity&gt; GetGroundEnt()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the entity beneath the calling entity<BR><B>EXAMPLE:  </B>ground_ent = self GetGroundEnt()<BR></OL><P>
<HR><H1>void GetHeadGender(<I>&lt;headIndex&gt;</I>,<I>[sessionmode]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;headIndex&gt; The index of the head<LI>        <B>[OPTIONAL]</B>  [sessionmode] The session mode (cp,mp,zm)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the given head's gender ("male" or "female")<BR><B>EXAMPLE:  </B>gender = GetHeadGender( headIndex, "mp" )<BR></OL><P>
<HR><H1>void GetHealthOverlayTime(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the time the health overlay has been on<BR><B>EXAMPLE:  </B>power = GetHealthOverlayTime( localClientNum )<BR></OL><P>
<HR><H1>void GetHeliDamageState()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the damage state of the heli.<BR><B>EXAMPLE:  </B>vehicle GetHeliDamageState( )<BR></OL><P>
<HR><H1>void GetHelmetAccentColorCountForHero(<I>&lt;localClientNum&gt;</I>,<I>&lt;heroIndex&gt;</I>,<I>&lt;helmetIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;heroIndex&gt; The index of the hero in the current game-mode's character table<LI>        <B>[MANDATORY]</B>  &lt;helmetIndex&gt; The index of the helmet for the specific hero</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the number of accents for the specified helmet model of a specific hero<BR><B>EXAMPLE:  </B>accentColorCount = GetHelmetAccentColorCountForHero( localClientNum, 0, 0 )<BR></OL><P>
<HR><H1>void GetHeroBodyModelIndices(<I>&lt;heroIndex&gt;</I>,<I>[sessionmode]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;heroIndex&gt; The index of the hero<LI>        <B>[OPTIONAL]</B>  [sessionmode] The session mode (cp,mp,zm)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the given hero's body models for the current session mode<BR><B>EXAMPLE:  </B>heroBodyModelNames = GetHeroBodyModels( heroIndex, "mp" )<BR></OL><P>
<HR><H1>void GetHeroes(<I>[sessionmode]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [sessionmode] Session Mode (cp,mp,zm)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns all hero indices for the current session mode (or specified session mode)<BR><B>EXAMPLE:  </B>heroIndices = GetHeroes()<BR></OL><P>
<HR><H1>void GetHeroGender(<I>&lt;heroIndex&gt;</I>,<I>[sessionmode]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;heroIndex&gt; The index of the hero<LI>        <B>[OPTIONAL]</B>  [sessionmode] The session mode (cp,mp,zm)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the given hero's gender ("male" or "female")<BR><B>EXAMPLE:  </B>gender = GetHeroGender( heroIndex, "mp" )<BR></OL><P>
<HR><H1>void GetHeroHeadModelIndices()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns all hero indices for the current session mode<BR><B>EXAMPLE:  </B>heroHelmetModelNames = GetHeroHelmetModels( heroIndex, "mp" )<BR></OL><P>
<HR><H1>void GetHeroHelmetModelIndices(<I>&lt;heroIndex&gt;</I>,<I>[sessionmode]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;heroIndex&gt; The index of the hero<LI>        <B>[OPTIONAL]</B>  [sessionmode] The session mode (cp,mp,zm)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the given hero's helmet models for the current session mode<BR><B>EXAMPLE:  </B>heroHelmetModelNames = GetHeroHelmetModelIndices( heroIndex, "mp" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetHorizontalOffsetFromScreenCenter(<I>&lt;localClientNum&gt;</I>,<I>&lt;width&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client to check<LI>        <B>[OPTIONAL]</B>  &lt;width&gt; width to check against</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the distance from the screen center to the entity<BR><B>EXAMPLE:  </B>ent GetDistanceFromScreenCenter( localClientNum )<BR></OL><P>
<HR><H1>void GetInfluenceAt(<I>&lt;influenceMapIndex&gt;</I>,<I>&lt;origin&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;influenceMapIndex&gt; Index of the influence map<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The location to check for influence value</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the influence value at the origin position on the influence map, undefined if no value can be found.<BR><B>EXAMPLE:  </B>GetInfluenceAt(influenceMapIndex, origin)<BR></OL><P>
<HR><H1>void GetInfluenceFacePos()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the faces pos on the influence map<BR><B>EXAMPLE:  </B>pos = GetInfluenceFacePos( faceIndex )<BR></OL><P>
<HR><H1>void GetInfluenceNumFaces()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the number faces on the influence<BR><B>EXAMPLE:  </B>numFaces = GetInfluenceNumFaces()<BR></OL><P>
<HR><H1>void GetInfluencerPreset(<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; valid spawn influencer preset name.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Adds a new influencer of &lt;name&gt; at &lt;origin&gt; and &lt;angles&gt<BR><B>EXAMPLE:  </B>preset_array = GetInfluencerPreset( name )<BR></OL><P>
<HR><H1>void GetInfluencerTimeoutRemaining(<I>&lt;influencer id&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;influencer id&gt; The influencer id</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the remaining influencer timeout in milliseconds.  Returns a negative number if no timeout.<BR><B>EXAMPLE:  </B>GetInfluencerTimeout( influencer_id )<BR></OL><P>
<HR><H1>void GetInKillcam(<I>&lt;local_client_num&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;local_client_num&gt; The local client to check</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>returns if the client is in killcam or not.<BR></OL><P>
<HR><H1>void &lt;ai&gt; GetInterestPoolAwareness()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the current interest pool awareness level regardless of actual awareness level.<BR><B>EXAMPLE:  </B>interestAwareness = self GetInterestPoolAwareness()<BR></OL><P>
<HR><H1>void &lt;ai_or_player&gt; GetInterestPoolValue()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the sentient's interest pool value.<BR><B>EXAMPLE:  </B>value = self GetInterestPoolValue()<BR></OL><P>
<HR><H1>entity GetItemArray()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of all of the items in a level.<BR><B>EXAMPLE:  </B>origins = GetItemArray()<BR></OL><P>
<HR><H1>void GetItemAttachment(<I>&lt;itemIndex&gt;</I>,<I>&lt;attachmentNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;itemIndex&gt; The item index<LI>        <B>[MANDATORY]</B>  &lt;attachmentNum&gt; The attachment number for the index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the attachment for a particular item<BR><B>EXAMPLE:  </B>GetItemAttachment( 10, 1 ); // returns attachment 1 for item 10<BR></OL><P>
<HR><H1>void GetItemAttachmentAllocationCost(<I>&lt;itemIndex&gt;</I>,<I>&lt;attachmentNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;itemIndex&gt; The item index<LI>        <B>[MANDATORY]</B>  &lt;attachmentNum&gt; The attachment number for the index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the allocation cost of an attachment for a particular item<BR><B>EXAMPLE:  </B>GetItemAttachmentAllocationCost( 10, 1 ); // returns allocation cost of attachment 1 for item 10<BR></OL><P>
<HR><H1>void GetItemGroupForWeaponName(<I>&lt;weaponName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weaponName&gt; Name of weapon to get item group</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the ref for a specific weapon name<BR><B>EXAMPLE:  </B>ref = GetItemGroupForWeapon( weapon )<BR></OL><P>
<HR><H1>void GetItemGroupFromItemIndex(<I>&lt;itemIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;itemIndex&gt; Item index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the ref for a specified item index<BR><B>EXAMPLE:  </B>ref = GetItemGroupFromItemIndex( itemIndex )<BR></OL><P>
<HR><H1>entity GetKillCamEntity(<I>&lt;local_client_num&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;local_client_num&gt; The local client to check</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>returns the killcamentity.<BR></OL><P>
<HR><H1>void GetKnownLength(<I>&lt;playbackId&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;playbackId&gt; The sound id</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the known length of the sound<BR><B>EXAMPLE:  </B>length = GetKnownLength( level.mySnd )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetLastOutWaterTime()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the last time the player was not completely submerged<BR><B>EXAMPLE:  </B>time = player GetLastOutWaterTime()<BR></OL><P>
<HR><H1>void &lt;light&gt; GetLightColor()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the current color of the light, as an RGB vector.<BR><B>EXAMPLE:  </B>color = self GetLightColor()<BR></OL><P>
<HR><H1>void &lt;light&gt; GetLightExponent()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the current exponent of the light.<BR><B>EXAMPLE:  </B>exponent = self GetLightExponent()<BR></OL><P>
<HR><H1>void &lt;light&gt; GetLightFovOuter()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the current outer fov of a spot light.<BR><B>EXAMPLE:  </B>fov = self GetLightFovOuter()<BR></OL><P>
<HR><H1>void &lt;light&gt; GetLightIntensity()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the current intensity of the light.<BR><B>EXAMPLE:  </B>intensity = self GetLightIntensity()<BR></OL><P>
<HR><H1>void &lt;light&gt; GetLightRadius()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the current radius of the light.<BR><B>EXAMPLE:  </B>radius = self GetLightRadius()<BR></OL><P>
<HR><H1>entity &lt;entity&gt; GetLinkedEnt()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the entity that the calling entity is linked to<BR><B>EXAMPLE:  </B>linked_ent = self GetLinkedEnt()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetLoadoutAllocation(<I>&lt;custom Class&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;custom Class&gt; Class Num</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get how many allocation points are spent in the custom class<BR><B>EXAMPLE:  </B>allocationSpent = self GetLoadoutAllocation( 0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetLoadoutGunSmithVariantIndex(<I>&lt;custom Class&gt;</I>,<I>&lt;getSecondary&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;custom Class&gt; Class Num<LI>        <B>[OPTIONAL]</B>  &lt;getSecondary&gt; defaults to false, if set will get you the variant index of the secondary</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the GunSmith Variant index of the primary weapon, pass 1 as an option to get the secondary<BR><B>EXAMPLE:  </B>gunSmithPrimaryIndex = self GetLoadoutGunSmithVariantIndex( 0, 0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetLoadoutItem(<I>&lt;custom Class&gt;</I>,<I>&lt;loadoutSlot&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;custom Class&gt; Class Num<LI>        <B>[MANDATORY]</B>  &lt;loadoutSlot&gt; Loadout Slot</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the index of the item in the custom class<BR><B>EXAMPLE:  </B>primary = self GetLoadoutItem( 0, primary )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetLoadoutItemRef(<I>&lt;custom Class&gt;</I>,<I>&lt;loadoutSlot&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;custom Class&gt; Class Num<LI>        <B>[MANDATORY]</B>  &lt;loadoutSlot&gt; Loadout Slot</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the reference of the item in the custom class<BR><B>EXAMPLE:  </B>primary = self GetLoadoutItemRef( 0, primary )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetLoadoutPerks(<I>&lt;custom Class&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;custom Class&gt; Class Num</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the list of specialties in the custom class<BR><B>EXAMPLE:  </B>primary = self GetLoadoutPerks( 0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetLoadoutWeapon(<I>&lt;custom Class&gt;</I>,<I>&lt;loadoutSlot&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;custom Class&gt; Class Num<LI>        <B>[MANDATORY]</B>  &lt;loadoutSlot&gt; Loadout Slot (primary or secondary)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the full weapon name (including attachments) of the item in the custom class<BR><B>EXAMPLE:  </B>primary = self GetLoadoutWeapon( 0, primary )<BR></OL><P>
<HR><H1>void GetLobbyClientCount()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the number of connected or connecting clients<BR><B>EXAMPLE:  </B>clientCount = GetClientCount()<BR></OL><P>
<HR><H1>void GetLocalClientAngles(<I>&lt;client&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;client&gt; the client to get angles for</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the local client angles<BR><B>EXAMPLE:  </B>client_angles = GetLocalClientAngles()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetLocalClientDriver()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the local client index of the driver of the vehicle if the driver is a local client or undefined.<BR><B>EXAMPLE:  </B>driver = self GetLocalClientDriver( )<BR></OL><P>
<HR><H1>void GetLocalClientEyePos(<I>&lt;client&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;client&gt; the client to get eye pos for</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Gets the local client eye pos<BR><B>EXAMPLE:  </B>eye_pos = GetLocalClientEyePos( 0 )<BR></OL><P>
<HR><H1>void GetLocalClientFOV(<I>&lt;client&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;client&gt; the client index to get fov for</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the local client field of view in degrees<BR><B>EXAMPLE:  </B>client_fov = GetLocalClientFOV()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetLocalClientNumber()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the local client number.<BR><B>EXAMPLE:  </B>clientNum = self GetLocalClientNumber()<BR></OL><P>
<HR><H1>void GetLocalClientPos(<I>&lt;client&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;client&gt; the client to get position</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns pos of localclient<BR><B>EXAMPLE:  </B>origin = GetLocalClientPos( 0 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetLocalGunnerAngles(<I>&lt;gunnerIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;gunnerIndex&gt; The index of the gunner seat</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the angles of the specified gunner, local to the vehicle itself.<BR><B>EXAMPLE:  </B>localAngles = self GetLocalGunnerAngles( 0 )<BR></OL><P>
<HR><H1>entity GetLocalPlayer(<I>&lt;local client num&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;local client num&gt; local client</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the local player predicted centity.<BR><B>EXAMPLE:  </B>GetLocalPlayer( 0 )<BR></OL><P>
<HR><H1>entity GetLocalPlayers()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get an array of all the local players<BR><B>EXAMPLE:  </B>players = GetLocalPlayers()<BR></OL><P>
<HR><H1>void GetLocalPlayerTeam(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Number of the local client to check</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Gets the team of the local player<BR><B>EXAMPLE:  </B>team = GetLocalPlayerTeam( 0 )<BR></OL><P>
<HR><H1>void GetMapAtIndex(<I>&lt;index&gt;</I>,<I>&lt;dlcindex&gt;</I>,<I>&lt;sessionmodeabbrev&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;index&gt; the index of the map you're looking for.<LI>        <B>[OPTIONAL]</B>  &lt;dlcindex&gt; dlc1..N if DLC.  If ommitted, use "base".<LI>        <B>[OPTIONAL]</B>  &lt;sessionmodeabbrev&gt; cp,mp,zm.  If ommitted, use current game mode abbreviation</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Get the name of the map at the given index in a mode's maptable.  Returns undefined if the given index doesn't index the given maptable<BR><B>EXAMPLE:  </B>GetMapAtIndex( "cp_mi_sing_blackstation" )<BR></OL><P>
<HR><H1>void GetMapFields(<I>&lt;currentmap&gt;</I>,<I>&lt;dlcindex&gt;</I>,<I>&lt;sessionmodeabbrev&gt;</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  &lt;currentmap&gt; the name of the current map.  If ommitted, use Dvar sv_mapname<LI>        <B>[OPTIONAL]</B>  &lt;dlcindex&gt; dlc1..N if DLC.  If ommitted, use "base".<LI>        <B>[OPTIONAL]</B>  &lt;sessionmodeabbrev&gt; cp,mp,zm.  If ommitted, use current game mode abbreviation</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Get the outro movie of the current map in the maptable.  Returns undefined if currentmap wasn't found<BR><B>EXAMPLE:  </B>fields = GetMapFields( GetNextMap("cp_mi_sing_blackstation") )<BR></OL><P>
<HR><H1>void GetMapIntroMovie(<I>[currentmap]</I>,<I>[dlcindex]</I>,<I>[sessionmodeabbrev]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [currentmap] the name of the current map.  If ommitted, use Dvar sv_mapname<LI>        <B>[OPTIONAL]</B>  [dlcindex] dlc1..N if DLC.  If ommitted, use "base".<LI>        <B>[OPTIONAL]</B>  [sessionmodeabbrev] cp,mp,zm.  If ommitted, use current game mode abbreviation</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the intro movie of the current map in the maptable.  Returns undefined if currentmap wasn't found<BR><B>EXAMPLE:  </B>world.nextIntroMovie = GetMapIntroMovie( GetNextMap("cp_mi_sing_blackstation") )<BR></OL><P>
<HR><H1>void GetMapOrder(<I>[currentmap]</I>,<I>[dlcindex]</I>,<I>[sessionmodeabbrev]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [currentmap] the name of the current map.  If ommitted, use Dvar sv_mapname<LI>        <B>[OPTIONAL]</B>  [dlcindex] dlc1..N if DLC.  If ommitted, use "base".<LI>        <B>[OPTIONAL]</B>  [sessionmodeabbrev] cp,mp,zm.  If ommitted, use current game mode abbreviation</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the index of the current map in the maptable.  Returns -1 if currentmap wasn't found<BR><B>EXAMPLE:  </B>if( GetMapOrder( "cp_mi_sing_blackstation" ) &gt; GetMapOrder( world.highestMapCompletion ) { world.highestMapCompletion = "cp_mi_sing_blackstation"; }<BR></OL><P>
<HR><H1>void GetMapOutroMovie(<I>[currentmap]</I>,<I>[dlcindex]</I>,<I>[sessionmodeabbrev]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [currentmap] the name of the current map.  If ommitted, use Dvar sv_mapname<LI>        <B>[OPTIONAL]</B>  [dlcindex] dlc1..N if DLC.  If ommitted, use "base".<LI>        <B>[OPTIONAL]</B>  [sessionmodeabbrev] cp,mp,zm.  If ommitted, use current game mode abbreviation</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the outro movie of the current map in the maptable.  Returns undefined if currentmap wasn't found<BR><B>EXAMPLE:  </B>world.nextOutroMovie = GetMapIntroMovie( GetNextMap("cp_mi_sing_blackstation") )<BR></OL><P>
<HR><H1>void GetMaxLocalClients()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the max number of local clients<BR><B>EXAMPLE:  </B>max_clients = GetMaxLocalClients()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetMaxReverseSpeed()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get maximum reverse speed of a vehicle.<BR><B>EXAMPLE:  </B>speed = vehicle GetMaxReverseSpeed()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetMaxs()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get maximum bounds of the entity<BR><B>EXAMPLE:  </B>maxs = wallModel GetMaxs()<BR></OL><P>
<HR><H1>void GetMaxVehicles()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Return the maximum number of vehicles that can be instantiated simultaneously.  This is platform-specific.<BR><B>EXAMPLE:  </B>vehicleSlotsFree = GetMaxVehicles() - level.vehicles_list.size<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetMeleeChainCount()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the number of melee kills achieved by the player within their current streak.<BR><B>EXAMPLE:  </B>entity GetMeleeChainCount( )<BR></OL><P>
<HR><H1>void getmicrosecondsraw()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets raw system microseconds; used for profiling, only gives lower 32 bits as script doesn't support uint64_t properly right now<BR><B>EXAMPLE:  </B>start_time = GetMicrosecondsRaw()<BR></OL><P>
<HR><H1>void GetMigrationStatus()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR></OL><P>
<HR><H1>void GetMillisecondsRaw()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets raw system milliseconds; use for profiling long routines as it is only an integer<BR><B>EXAMPLE:  </B>start_time = GetMillisecondsRaw()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetMins()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get minimum bounds of the entity<BR><B>EXAMPLE:  </B>mins = wallModel GetMins()<BR></OL><P>
<HR><H1>entity &lt;missile&gt; GetMissileOwner()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the entity that owns this missile<BR><B>EXAMPLE:  </B>javelinOwner = GetMissileOwner( thisMissile )<BR></OL><P>
<HR><H1>void GetMissionName(<I>[currentmap]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [currentmap] the name of the current map.  If ommitted, use Dvar sv_mapname</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the name of the mission this map is part of<BR><B>EXAMPLE:  </B>level.mission = GetMissionName( "cp_mi_cairo_ramses2" )<BR></OL><P>
<HR><H1>void GetMissionUniqueID(<I>[currentmap]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [currentmap] the name of the current map.  If ommitted, use Dvar sv_mapname</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the unique id for this mission<BR><B>EXAMPLE:  </B>level.unique_id = GetMissionUniqueID( "cp_mi_cairo_ramses2" )<BR></OL><P>
<HR><H1>void GetMissionVersion(<I>[currentmap]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [currentmap] the name of the current map.  If ommitted, use Dvar sv_mapname</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the unique id for this mission<BR><B>EXAMPLE:  </B>level.unique_id = GetMissionVersion( "cp_mi_cairo_ramses2" )<BR></OL><P>
<HR><H1>void GetMoveDelta(<I>&lt;animation name&gt;</I>,<I>[start time]</I>,<I>[end time]</I>,<I>[entity]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation name&gt; Name of the animation<LI>        <B>[OPTIONAL]</B>  [start time] Normalized start time of the animation<LI>        <B>[OPTIONAL]</B>  [end time] Normalized end time of the animation<LI>        <B>[OPTIONAL]</B>  [entity] The entity should be passed if the animation name is a string to look up the animation from the entity's anim tree</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the move delta for the animation<BR><B>EXAMPLE:  </B>localDeltaVector = GetMoveDelta( animation, 0, 1, entity )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetMovementType()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the movement type for the entity<BR><B>EXAMPLE:  </B>movement_type = self GetMovementType()<BR></OL><P>
<HR><H1>entity &lt;player&gt; GetMoverEnt()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the moving entity the player is sitting on .<BR><B>EXAMPLE:  </B>if(player GetMoverEnt())<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetMoveSpeedScale()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the speed scale multiplier for the entity<BR><B>EXAMPLE:  </B>speed_modifier = self GetMoveSpeedScale()<BR></OL><P>
<HR><H1>void GetNavMeshFaceNormal(<I>&lt;position&gt;</I>,<I>&lt;searchRadius&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; Position to start the search around.<LI>        <B>[MANDATORY]</B>  &lt;searchRadius&gt; Radius to search within.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the face normal vector of the closest navmesh point to the passed in position, within the search radius.<BR><B>EXAMPLE:  </B>navmeshNormal = GetNavMeshFaceNormal( (10,20,30), 25 )<BR></OL><P>
<HR><H1>void GetNavMeshTriggersForPoint(<I>&lt;pos&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;pos&gt; The test position.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns a list of the names of navmesh triggers that a given point resides in<BR><B>EXAMPLE:  </B>targetNames = GetNavMeshTriggersForPoint( pos )<BR></OL><P>
<HR><H1>pathnode GetNearestNode(<I>&lt;origin&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; location to search for the nearest node</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the node nearest to this origin or undefined if no close node exists.<BR><B>EXAMPLE:  </B>node = GetNearestNode( guy.origin )<BR></OL><P>
<HR><H1>void GetNearestPathPoint(<I>&lt;origin&gt;</I>,<I>&lt;radius&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The point from which to search from<LI>        <B>[MANDATORY]</B>  &lt;radius&gt; The maximum radius in which to search</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the nearest point on the navmesh for the given origin and radius or undefined if no point can be found.<BR></OL><P>
<HR><H1>void GetNextMap(<I>[currentmap]</I>,<I>[dlcindex]</I>,<I>[sessionmodeabbrev]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [currentmap] the name of the current map.  If ommitted, use Dvar sv_mapname<LI>        <B>[OPTIONAL]</B>  [dlcindex] dlc1..N if DLC.  If ommitted, use "base".<LI>        <B>[OPTIONAL]</B>  [sessionmodeabbrev] cp,mp,zm.  If ommitted, use current game mode abbreviation</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the name of the next map in the maptable.  Returns "" if this is the last map, undefined if currentmap wasn't found<BR><B>EXAMPLE:  </B>GetNextMap( "cp_mi_sing_blackstation" )<BR></OL><P>
<HR><H1>pathnode GetNextTraversalNodeOnPath(<I>&lt;start&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt; the  index for the starting node</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>EXAMPLE:  </B>GetNextTraversalNodeOnPath(1)<BR></OL><P>
<HR><H1>pathnode GetNode(<I>&lt;name&gt;</I>,<I>&lt;key&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; name to search for<LI>        <B>[MANDATORY]</B>  &lt;key&gt; key that name goes with</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets a node with the given name, key pair<BR><B>EXAMPLE:  </B>node = GetNode( self.target, "targetname" )<BR></OL><P>
<HR><H1>pathnode GetNodeArray(<I>&lt;name&gt;</I>,<I>&lt;key&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; name to search for<LI>        <B>[MANDATORY]</B>  &lt;key&gt; key that name goes with</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets an array of nodes that have the given name, key pair<BR><B>EXAMPLE:  </B>node = GetNodeArray( self.target, "targetname" )<BR></OL><P>
<HR><H1>pathnode GetNodeArraySorted(<I>&lt;name&gt;</I>,<I>&lt;key&gt;</I>,<I>&lt;pos&gt;</I>,<I>&lt;r&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; name to search for<LI>        <B>[MANDATORY]</B>  &lt;key&gt; key that name goes with<LI>        <B>[MANDATORY]</B>  &lt;pos&gt; search origin<LI>        <B>[MANDATORY]</B>  &lt;r&gt; the radius to sort in</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets an array of nodes that have the given name, key pair, within given radius, sorts them<BR><B>EXAMPLE:  </B>nodes = GetNodeArraySorted(self.target, "targetname", self.origin, 256 )<BR></OL><P>
<HR><H1>void GetNodeEdge(<I>&lt;node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; node volume</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of points which corresponds to the node volume's traversal edge. The traversal edge is represented as a piecewise linear function.<BR><B>EXAMPLE:  </B>points = GetNodeEdge( myNode )<BR></OL><P>
<HR><H1>void GetNodeIndexOnPath(<I>&lt;node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; The node to get the other node for</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>EXAMPLE:  </B>GetNodeIndexOnPath(node)<BR></OL><P>
<HR><H1>entity GetNodeOwner(<I>&lt;node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; which node to get the owner of.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the owner of the node.<BR><B>EXAMPLE:  </B>node_owner = GetNodeOwner( node ) )<BR></OL><P>
<HR><H1>void GetNodeRegion(<I>&lt;node1&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node1&gt; pathnode to check</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the region of the give node, if there is one. Returns undefined otherwise.<BR><B>EXAMPLE:  </B>if ( GetNodeRegion( myNode ) )<BR></OL><P>
<HR><H1>void GetNodesInRadius(<I>&lt;origin&gt;</I>,<I>&lt;max radius&gt;</I>,<I>&lt;min radius&gt;</I>,<I>[max height]</I>,<I>[node type]</I>,<I>[max nodes]</I>,<I>[region index]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; location to search for nodes at<LI>        <B>[MANDATORY]</B>  &lt;max radius&gt; maximum distance of nodes to return<LI>        <B>[MANDATORY]</B>  &lt;min radius&gt; maximum distance of nodes to return<LI>        <B>[OPTIONAL]</B>  [max height] maximum height difference to origin. Defaults to 512<LI>        <B>[OPTIONAL]</B>  [node type] node type to search for, if not specified, returns all node types. 'Cover' will return all cover nodes<LI>        <B>[OPTIONAL]</B>  [max nodes] the maximum number of nodes to return up to 256<LI>        <B>[OPTIONAL]</B>  [region index] the region index the nodes should belong to</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets all of the nodes (max of 256) within a cylinder, in unsorted order<BR><B>EXAMPLE:  </B>nodes = GetNodesInRadius( guy.origin, 512, 0, 128, "Path" )<BR></OL><P>
<HR><H1>void GetNodesInRadiusSorted(<I>&lt;origin&gt;</I>,<I>&lt;max radius&gt;</I>,<I>&lt;min radius&gt;</I>,<I>[max height]</I>,<I>[node type]</I>,<I>[max nodes]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; location to search for nodes at<LI>        <B>[MANDATORY]</B>  &lt;max radius&gt; maximum distance of nodes to return<LI>        <B>[MANDATORY]</B>  &lt;min radius&gt; maximum distance of nodes to return<LI>        <B>[OPTIONAL]</B>  [max height] maximum height difference to origin. Defaults to 512<LI>        <B>[OPTIONAL]</B>  [node type] node type to search for, if not specified, returns all node types. 'Cover' will return all cover nodes<LI>        <B>[OPTIONAL]</B>  [max nodes] the maximum number of nodes to return up to 256</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets all of the nodes (max of 256) within a cylinder, sorted by closest to &lt;origin&gt<BR><B>EXAMPLE:  </B>nodes = GetNodesInRadiusSorted( guy.origin, 512, 0, 128, "Path" )<BR></OL><P>
<HR><H1>entity GetNonPredictedLocalPlayer(<I>&lt;local client num&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;local client num&gt; local client</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the local player non predicted centity.<BR><B>EXAMPLE:  </B>GetNonPredictedLocalPlayer( 0 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetNormalHealth()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get health in a normalized range of 0 to 1<BR><B>EXAMPLE:  </B>normal_health = self GetNormalHealth()<BR></OL><P>
<HR><H1>void GetNorthYaw()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get North Yaw<BR><B>EXAMPLE:  </B>northvector = (cos(getnorthyaw()), sin(getnorthyaw()), 0)<BR></OL><P>
<HR><H1>void GetNotetracksInDelta(<I>&lt;animation&gt;</I>,<I>&lt;time&gt;</I>,<I>[time_delta]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; the animation for which notetrack information is needed<LI>        <B>[MANDATORY]</B>  &lt;time&gt; The time in the animation around which notetrack information is needed in the range 0-1<LI>        <B>[OPTIONAL]</B>  [time_delta] The amount of time around the time provided to check for notetracks in seconds defaults to 0.15</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get a list of notetracks and times within a specific time delta of a specific time in an animation<BR><B>EXAMPLE:  </B>notetrackArray = GetNotetracksInDelta( anim, 0.4 )<BR></OL><P>
<HR><H1>void GetNotetrackTimes(<I>&lt;animation&gt;</I>,<I>&lt;note track&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; an animation<LI>        <B>[MANDATORY]</B>  &lt;note track&gt; a constant string with the name of the note track</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets an array of the times during an animation that the given notetrack occurs. The times returned are fractional (0 to 1).<BR><B>EXAMPLE:  </B>exitAlignTimes = GetNotetrackTimes( exitAnim, "exit_align" )<BR></OL><P>
<HR><H1>void GetNumberOfCollectiblesForLevel()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the number of collectibles for the given level<BR><B>EXAMPLE:  </B>collectibleCount = GetNumberOfCollectiblesForLevel( GetRootMapName() )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetNumChallengesComplete(<I>&lt;mission_name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;mission_name&gt; (string) The name of the mission to check completed challenges in</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the number of challenges completed in a given mission<BR><B>EXAMPLE:  </B>is_default = self GetNumChallengesComplete( "angola" )<BR></OL><P>
<HR><H1>void GetNumConnectedPlayers(<I>&lt;include bots&gt;</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  &lt;include bots&gt; The optional check to include test clients (bots). (bool)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the number of players that are connected to our game.  Ignores bots by default.<BR><B>EXAMPLE:  </B>num_players_and_bots = GetNumConnectedPlayers( true )<BR></OL><P>
<HR><H1>void GetNumExpectedPlayers()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the number of players that we're expecting to join our game.<BR><B>EXAMPLE:  </B>num_players = GetNumExpectedPlayers()<BR></OL><P>
<HR><H1>void GetNumFreeEntities(<I>&lt;local client number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;local client number&gt; Which local client to spawn the entity for.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the number of free fake entities<BR><B>EXAMPLE:  </B>numfree = GetNumFreeEntities( localClientNum )<BR></OL><P>
<HR><H1>void GetNumParts(<I>&lt;model&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;model&gt; The model to get parts for</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Return number of bones in the model<BR><B>EXAMPLE:  </B>numParts = GetNumParts( model )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetNumZBarrierPieces()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns number of pieces in specified zbarrier ent.<BR><B>EXAMPLE:  </B>numPieces = ent GetNumZBarrierPieces())<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetOrigin()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the origin of the entity<BR><B>EXAMPLE:  </B>origin = self GetOrigin()<BR></OL><P>
<HR><H1>pathnode GetOtherNodeInNegotiationPair(<I>&lt;node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; The node to get the other node for</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the other node of the passed in negotiation node. Returns the begin node if end is passed and vice versa.<BR><B>EXAMPLE:  </B>end_node = GetOtherNodeInNegotiationPair( begin_node )<BR></OL><P>
<HR><H1>entity &lt;entity&gt; GetOwner(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client to check</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get an entity's owner<BR><B>EXAMPLE:  </B>ent GetOwner( localClientNum )<BR></OL><P>
<HR><H1>entity &lt;entity&gt; GetParentEntity()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Gets the parent entity.  Requires client-side linking to be set up on the entity.<BR><B>EXAMPLE:  </B>parent = self GetParentEntity( )<BR></OL><P>
<HR><H1>void GetPartName(<I>&lt;model&gt;</I>,<I>&lt;index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;model&gt; The model to get parts for<LI>        <B>[MANDATORY]</B>  &lt;index&gt; The bone index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the bone name for the model and index<BR><B>EXAMPLE:  </B>boneName = GetPartName( model, 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetPathfindingRadius()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the radius used for pathfinding operations.<BR><B>EXAMPLE:  </B>radius = ent GetPathfindingRadius()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetPathMetric(<I>&lt;origin&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; the goal for the path</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get path metric for the path from the ai to origin<BR><B>EXAMPLE:  </B>path_metric = level.ai_for_pathing GetPathMetric( dropPos )<BR></OL><P>
<HR><H1>void GetPlaybackTime(<I>&lt;playbackId&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;playbackId&gt; The sound id</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the playback time for the sound given by playbackId<BR><B>EXAMPLE:  </B>time = GetPlaybackTime( level.mySnd )<BR></OL><P>
<HR><H1>entity GetPlayerCorpse()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Gets the most recent corpse fort he player<BR><B>EXAMPLE:  </B>cybercom_type = player GetPlayerCorpse()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetPlayerGibDef()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns string of gibdef for current player<BR></OL><P>
<HR><H1>void &lt;player&gt; GetPlayerGravity()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the gravity or gravity override value for the player.<BR><B>EXAMPLE:  </B>player GetPlayerGravity()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetPlayerLastOutWaterTime()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Gets the last time the player was not underwater<BR><B>EXAMPLE:  </B>waterTime = player GetPlayerLastOutWaterTime()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetPlayerName()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Gets the character index<BR><B>EXAMPLE:  </B>player_name = self GetPlayerName()<BR></OL><P>
<HR><H1>entity GetPlayers(<I>[team]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [team] - if specifed, returns lists of players on different teams, in team based game modes.  Valid values "allies", "axis", "neutral" & "all"</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of the currently connected players.  Used internally to the script call get_players().<BR><B>EXAMPLE:  </B>players = GetPlayers()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetPlayerSelectedGestureName(<I>&lt;gestureType&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;gestureType&gt; The type of gesture to get</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the equipped gesture animation name<BR><B>EXAMPLE:  </B>gesture = player GetPlayerSelectedGestureName( 0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetPlayerSelectedTauntName(<I>&lt;tauntType&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;tauntType&gt; The type of taunt to get</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the equipped taunt animation name<BR><B>EXAMPLE:  </B>taunt = player GetPlayerSelectedTauntName( 0 )<BR></OL><P>
<HR><H1>void GetPlayerSpawnId(<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player that we are spawning in</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the current spawn id for the player (used for debugging purposes only)<BR><B>EXAMPLE:  </B>spawnId = GetPlayerSpawnId( player )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetPlayerSpeed()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the speed value for the player.<BR><B>EXAMPLE:  </B>player GetPlayerSpeed()<BR></OL><P>
<HR><H1>entity GetPlayerVehicle(<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player to check vehicle for</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns undefined if the player is not in a vehicle<BR><B>EXAMPLE:  </B>vehicle = GetPlayerVehicle( self )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetPointInBounds(<I>&lt;ratio_ForwardBack&gt;</I>,<I>&lt;ratio_LeftRight&gt;</I>,<I>&lt;ratio_UpDown&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;ratio_ForwardBack&gt; 1.0 is full forward, -1.0 is full backwards.<LI>        <B>[MANDATORY]</B>  &lt;ratio_LeftRight&gt; 1.0 is full left, -1.0 is full right.<LI>        <B>[MANDATORY]</B>  &lt;ratio_UpDown&gt; 1.0 is full up, -1.0 is full down.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns a point within an entity's bounds.<BR><B>EXAMPLE:  </B>targetForwardPnt = helo GetPointInBounds( 1.0, 0.0, 0.0 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetPrimaryDeltaAnim()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the primary delta anim playing on this entity, or the name of the animation if the entity is in an animscripted state.<BR><B>EXAMPLE:  </B>anim = self GetPrimaryDeltaAnim()<BR></OL><P>
<HR><H1>void GetRandomCompatibleAttachmentsForWeapon(<I>&lt;weapon&gt;</I>,<I>&lt;num desired attachments&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon name.<LI>        <B>[OPTIONAL]</B>  &lt;num desired attachments&gt; Max number of compatible attachments desired. If the number is more than available attachments for the weapon, it will just not return that many.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of compatible attachments. If num desired attachments are specified then that many attachments will be returned if possible<BR><B>EXAMPLE:  </B>GetRandomCompatibleAttachmentsForWeapon( weaponObject, 4 )<BR></OL><P>
<HR><H1>void &lt;flying_ai&gt; GetRandomPointOnNavVolume()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get a random point on nav volume. Returns the position if found one, or undefined if not found.<BR><B>EXAMPLE:  </B>random = self GetRandomPointOnNavVolume()<BR></OL><P>
<HR><H1>void GetRealTime()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the real system time in milliseconds<BR><B>EXAMPLE:  </B>time = GetRealTime()<BR></OL><P>
<HR><H1>void GetRefFromItemIndex(<I>&lt;itemIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;itemIndex&gt; Item index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the ref for a specified item index<BR><B>EXAMPLE:  </B>ref = GetRefFromItemIndex( itemIndex )<BR></OL><P>
<HR><H1>void GetReflectionLocs()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets array of the locations of all of the reflection_probes in the level<BR><B>EXAMPLE:  </B>reflection_locs = GetReflectionLocs()<BR></OL><P>
<HR><H1>void GetReflectionOrigin()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Given a position, returns the position of the reflection probe in use there<BR><B>EXAMPLE:  </B>probe_pos = GetReflectionOrigin( camera_pos )<BR></OL><P>
<HR><H1>void GetRetrievableWeapons()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of weapons that need watchers so they can be retrieved by the player.<BR><B>EXAMPLE:  </B>retrievableWeapons = GetRetrievableWeapons()<BR></OL><P>
<HR><H1>void GetRevealPulseMaxRadius(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the max radius for the reveal vision pulse<BR><B>EXAMPLE:  </B>power = GetRevealPulseMaxRadius( localClientNum )<BR></OL><P>
<HR><H1>void GetRevealPulseOrigin(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the pulse origin for the local client reveal pulse<BR><B>EXAMPLE:  </B>power = GetRevealPulseOrigin( localClientNum )<BR></OL><P>
<HR><H1>void GetRevealPulseRadius(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the radius for the local client reveal pulse<BR><B>EXAMPLE:  </B>power = GetRevealPulseRadius( localClientNum )<BR></OL><P>
<HR><H1>void GetRootMapName(<I>[currentmap]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [currentmap] the name of the current map.  If ommitted, use Dvar sv_mapname</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the root map of a mission<BR><B>EXAMPLE:  </B>level.rootMap = GetRootMapName( "cp_mi_cairo_ramses2" )<BR></OL><P>
<HR><H1>void GetRope(<I>&lt;targetname&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;targetname&gt; The targetname of the rope you interested in</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the rope index based on targetname. Use it for ropes setuped in radiant. Returns -1, if not found.<BR><B>EXAMPLE:  </B>GetRope( "testrope" )<BR></OL><P>
<HR><H1>void GetRoundsPlayed(<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;value&gt; The number of rounds played</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get rounds played in match state<BR><B>EXAMPLE:  </B>GetRoundsPlayed( game["roundsplayed"] )<BR></OL><P>
<HR><H1>void GetScriptBundle()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the script bundle struct.<BR><B>EXAMPLE:  </B>settings = GetScriptBundle( "doorsettings" )<BR></OL><P>
<HR><H1>void GetScriptBundleList()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the script bundle list array.<BR><B>EXAMPLE:  </B>settings = GetScriptBundleList( "doorsettings" )<BR></OL><P>
<HR><H1>void GetScriptBundleNames()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns all the names of the script bundles of the specified type in an array.<BR><B>EXAMPLE:  </B>settings = GetScriptBundleNames( "scene" )<BR></OL><P>
<HR><H1>void GetScriptBundles()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns a list of script bundles based on the type.<BR><B>EXAMPLE:  </B>settings = GetScriptBundles( "scenes" )<BR></OL><P>
<HR><H1>entity GetScriptMoverArray()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of all of the script_origins in a level.<BR><B>EXAMPLE:  </B>origins = GetScriptMoverArray()<BR></OL><P>
<HR><H1>void GetServerHighestClientFieldVersion()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the server's highest clientfield version.<BR><B>EXAMPLE:  </B>if ( my_version &lt; GetServerHighestClientFieldVersion() )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetShootAtPos(<I>[attacker]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [attacker] The entity that will be shooting</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the position an attacker would shoot at to hit this entity.For AI or player this is the eye position.For other entities it's the tag_eye if there is one else the center of the entity bounding box.<BR><B>EXAMPLE:  </B>targetPos = self.enemy GetShootAtPos(self)<BR></OL><P>
<HR><H1>void GetShoutcasterSetting(<I>&lt;setting&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;setting&gt; The setting name as a string.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Gets the value of a shoutcaster setting.<BR><B>EXAMPLE:  </B>GetGametypeSetting( "who is going to win" )<BR></OL><P>
<HR><H1>void GetSkiptoName(<I>&lt;index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;index&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the skip to name with the given index<BR></OL><P>
<HR><H1>void GetSkipTos()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get all skip tos for the level<BR><B>EXAMPLE:  </B>skiptos = GetSkipTos()<BR></OL><P>
<HR><H1>void GetSnapshotIndexArray()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of the indices of current snapshots for all connected clients.<BR><B>EXAMPLE:  </B>snapindices = GetSnapshotIndexArray( )<BR></OL><P>
<HR><H1>void GetSoundFromSurfaceTable(<I>&lt;surfacefxtable&gt;</I>,<I>&lt;surface type&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;surfacefxtable&gt; Surface fx table.<LI>        <B>[MANDATORY]</B>  &lt;surface type&gt; Surface type</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the fx for a given surface type from the surfacefxtable.<BR><B>EXAMPLE:  </B>fx = GetSoundFromSurfaceTable( fx_surface_table, surface_type )<BR></OL><P>
<HR><H1>void GetSpawnerArray(<I>[name]</I>,<I>[key]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [name] Name to search for.<LI>        <B>[OPTIONAL]</B>  [key] The key to search for.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of all of the spawners in a level.<BR><B>EXAMPLE:  </B>spawners = GetSpawnerArray()<BR></OL><P>
<HR><H1>entity GetSpawnerTeamArray(<I>&lt;team&gt;</I>,<I>[team]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; a team name, either 'axis', 'allies', or 'neutral'<LI>        <B>[OPTIONAL]</B>  [team] any number of additional team names may be added, either 'axis', 'allies', or 'neutral'</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of all of the spawners in a level<BR><B>EXAMPLE:  </B>enemies = GetSpawnerTeamArray( "axis", "neutral" )<BR></OL><P>
<HR><H1>void GetSpawnStructForCharacter(<I>&lt;characterIndex&gt;</I>,<I>&lt;sessionmode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;characterIndex&gt; The index of the character in the current game-mode's character table<LI>        <B>[MANDATORY]</B>  &lt;sessionmode&gt; Session Mode Index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the targetname of the script_struct to use for the character pose in the frontend<BR><B>EXAMPLE:  </B>frontendVignetteAnim = GetSpawnStructForCharacter( characterIndex, "mp" )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetSpecialistIndex()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the specialist index for the player<BR><B>EXAMPLE:  </B>specialistIndex = player GetSpecialistIndex()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetStance()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the stance of the player. It only works for the player.<BR><B>EXAMPLE:  </B>stance = player GetStance()<BR></OL><P>
<HR><H1>void GetStartAngles(<I>&lt;origin&gt;</I>,<I>&lt;angle&gt;</I>,<I>&lt;animation&gt;</I>,<I>[animation time]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The current origin of the animation in world coordinates<LI>        <B>[MANDATORY]</B>  &lt;angle&gt; The current angle set of the animation in world coordinates<LI>        <B>[MANDATORY]</B>  &lt;animation&gt; The currently running animation<LI>        <B>[OPTIONAL]</B>  [animation time] The animation time in 0-1 range</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the starting angles for an animation, in world coordinates, given its current position, and angles<BR><B>EXAMPLE:  </B>org1 = GetStartAngles( climborg, climbang, buddyanim1, [0.5] )<BR></OL><P>
<HR><H1>void GetStartOrigin(<I>&lt;origin&gt;</I>,<I>&lt;angle&gt;</I>,<I>&lt;animation&gt;</I>,<I>[animation time]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The current origin of the animation in world coordinates<LI>        <B>[MANDATORY]</B>  &lt;angle&gt; The current angle set of the animation in world coordinates<LI>        <B>[MANDATORY]</B>  &lt;animation&gt; The currently running animation<LI>        <B>[OPTIONAL]</B>  [animation time] The starting animation time in 0-1 range</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the starting origin for an animation, in world coordinates, given its current position, and angles<BR><B>EXAMPLE:  </B>org1 = GetStartOrigin( climborg, climbang, buddyanim1, [0.5] )<BR></OL><P>
<HR><H1>void GetStartTime()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the start time for the current round.<BR><B>EXAMPLE:  </B>GetStartTime()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetStowedWeapon()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the stowed weapon for the player<BR><B>EXAMPLE:  </B>stowed = self GetStowedWeapon()<BR></OL><P>
<HR><H1>void GetStreamerRequestProgress(<I>&lt;slot&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slot&gt; Request slot</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the progress (between 0-100) of the streamer request slot<BR><B>EXAMPLE:  </B>getStreamerRequestProgress(0)<BR></OL><P>
<HR><H1>void GetStreamingProgress()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Gets a progress value between 0 (no progress) and 1 (complete) for all the models and meshes that the script is currently forcing<BR><B>EXAMPLE:  </B>progress = GetStreamingProgress()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetTagAngles()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the angles of the tag<BR><B>EXAMPLE:  </B>angles = self GetTagAngles( "tag" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetTagOrigin()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the origin of the tag<BR><B>EXAMPLE:  </B>origin = self GetTagOrigin( "tag" )<BR></OL><P>
<HR><H1>entity &lt;turret_or_vehicle&gt; GetTargetEntity(<I>[gunnerIndex]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [gunnerIndex] the gunner index if called on a vehicle</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the target entity of this turret or vehicle weapon<BR><B>EXAMPLE:  </B>target = roof_turret GetTargetEntity( ); target = tank GetTargetEntity( )<BR></OL><P>
<HR><H1>void GetTargetLockEntity(<I>&lt;localclientnum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localclientnum&gt; localclientnum</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get locked target<BR><B>EXAMPLE:  </B>target = self GetTargetLockEntity(&lt;localclientnum&gt;)<BR></OL><P>
<HR><H1>void GetTargetLockEntityArray()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get locked target<BR><B>EXAMPLE:  </B>target = self GetTargetLockEntityArray(&lt;localclientnum&gt;)<BR></OL><P>
<HR><H1>void &lt;turret_or_vehicle&gt; GetTargetOrigin(<I>[gunnerIndex]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [gunnerIndex] the gunner index if called on a vehicle (integer)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the target origin of this turret or vehicle weapon<BR><B>EXAMPLE:  </B>origin = roof_turret GetTargetOrigin( ); origin = tank GetTargetOrigin( )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetTeam()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Return true if the team of an entity if it can be found, undefined otherwise.<BR><B>EXAMPLE:  </B>orig_team = self GetTeam()<BR></OL><P>
<HR><H1>void GetTeamPlayersAlive(<I>&lt;team&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; A string value, either 'axis' or 'allies' or 'team3'</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the number of players still alive on a given team<BR></OL><P>
<HR><H1>void GetTeamSatellite(<I>&lt;team&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; The name of a team. Must be either Must be 'axis', 'allies', 'team3' or 'none'.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets whether a team has Satellite or not<BR><B>EXAMPLE:  </B>GetTeamSatellite( "allies" )<BR></OL><P>
<HR><H1>void GetTeamScore(<I>&lt;team&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; The name of a team. Must be either 'axis' or 'allies' or 'team3'.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get a team's score<BR><B>EXAMPLE:  </B>if ( GetTeamScore( "allies" ) &gt; getTeamScore("axis") ) ...<BR></OL><P>
<HR><H1>void GetTeamSpyplane(<I>&lt;team&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; The name of a team. Must be either Must be 'axis', 'allies', 'team3' or 'none'.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets whether a team has Spyplane or not<BR><B>EXAMPLE:  </B>GetTeamSpyplane( "allies" )<BR></OL><P>
<HR><H1>void GetTime()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the level time in Milliseconds from the start of the level.<BR><B>EXAMPLE:  </B>nextNodeTime = GetTime() + 500<BR></OL><P>
<HR><H1>void GetTopPlayersBodyModel(<I>&lt;localClientNum&gt;</I>,<I>&lt;topPlayerIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;topPlayerIndex&gt; The index of the top player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the name of the equipped body model of the top player in the game by index<BR><B>EXAMPLE:  </B>modelName = GetTopPlayersBodyModel( localClientNum, 2 )<BR></OL><P>
<HR><H1>void GetTopPlayersBodyRenderOptions(<I>&lt;localClientNum&gt;</I>,<I>&lt;topPlayerIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;topPlayerIndex&gt; The index of the top player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the render options for the body for the top player in the game by index<BR><B>EXAMPLE:  </B>renderOptions = GetTopPlayersBodyRenderOptions( localClientNum, 2 )<BR></OL><P>
<HR><H1>void GetTopPlayersGesture(<I>&lt;localClientNum&gt;</I>,<I>&lt;topPlayerIndex&gt;</I>,<I>&lt;CharacterGestureTypes&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;topPlayerIndex&gt; The index of the top player<LI>        <B>[MANDATORY]</B>  &lt;CharacterGestureTypes&gt; The CharacterGestureTypes enum value of the gesture to use</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the selected gesture of type CharacterGestureTypes for the given player<BR><B>EXAMPLE:  </B>gesture_anim = GetTopPlayersGesture( localClientNum, 2, 2 );	// GESTURE_TYPE_BOAST = 2<BR></OL><P>
<HR><H1>void GetTopPlayersHelmetModel(<I>&lt;localClientNum&gt;</I>,<I>&lt;topPlayerIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;topPlayerIndex&gt; The index of the top player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the name of the equipped helmet model of the top player in the game by index<BR><B>EXAMPLE:  </B>modelName = GetTopPlayersHelmetModel( localClientNum, 2 )<BR></OL><P>
<HR><H1>void GetTopPlayersHelmetRenderOptions(<I>&lt;localClientNum&gt;</I>,<I>&lt;topPlayerIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;topPlayerIndex&gt; The index of the top player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the render options for the body for the top player in the game by index<BR><B>EXAMPLE:  </B>renderOptions = GetTopPlayersHelmetRenderOptions( localClientNum, 2 )<BR></OL><P>
<HR><H1>void GetTopPlayersIndex(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the index of the client array or undefined if the client player is not a top scorer<BR><B>EXAMPLE:  </B>topPlayerIndex = self GetTopPlayersIndex( localClientNum )<BR></OL><P>
<HR><H1>void GetTopPlayersTaunt(<I>&lt;localClientNum&gt;</I>,<I>&lt;topPlayerIndex&gt;</I>,<I>&lt;CharacterGestureTypes&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;topPlayerIndex&gt; The index of the top player<LI>        <B>[MANDATORY]</B>  &lt;CharacterGestureTypes&gt; The CharacterTauntTypes enum value of the taunt to use</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the selected taunt of type CharacterTauntTypes for the given player<BR><B>EXAMPLE:  </B>taunt_anim = GetTopPlayersTaunt( localClientNum, 2, 0 );	// TAUNT_TYPE_FIRST_PLACE = 0<BR></OL><P>
<HR><H1>void GetTopPlayersTeam(<I>&lt;localClientNum&gt;</I>,<I>&lt;topPlayerIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;topPlayerIndex&gt; The index of the top player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the team of the player top player in the game by index<BR><B>EXAMPLE:  </B>team = GetTopPlayersTeam( localClientNum, 2 )<BR></OL><P>
<HR><H1>void GetTopPlayersWeaponInfo(<I>&lt;localClientNum&gt;</I>,<I>&lt;topPlayerIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;topPlayerIndex&gt; The index of the top player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the equipped weapon of the top player in the game<BR><B>EXAMPLE:  </B>weapon = GetTopPlayersWeaponInfo( localClientNum, 2 )<BR></OL><P>
<HR><H1>void GetTopPlayersWeaponModel(<I>&lt;localClientNum&gt;</I>,<I>&lt;topPlayerIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;topPlayerIndex&gt; The index of the top player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the name of the equipped weapon model of the top player in the game by index<BR><B>EXAMPLE:  </B>modelName = GetTopPlayersWeaponModel( localClientNum, 2 )<BR></OL><P>
<HR><H1>void GetTopPlayersWeaponRenderOptions(<I>&lt;localClientNum&gt;</I>,<I>&lt;topPlayerIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question<LI>        <B>[MANDATORY]</B>  &lt;topPlayerIndex&gt; The index of the top player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the render options for the weapon for the top player in the game by index<BR><B>EXAMPLE:  </B>renderOptions = GetTopPlayersWeaponRenderOptions( localClientNum, 2 )<BR></OL><P>
<HR><H1>void GetTopScorerCount(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the player in question</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the number of clients in the top scorers array<BR><B>EXAMPLE:  </B>numClients = GetTopScorerCount( localClientNum )<BR></OL><P>
<HR><H1>void GetTotalAmmo(<I>&lt;localClientNum&gt;</I>,<I>&lt;weaponName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the player<LI>        <B>[MANDATORY]</B>  &lt;weaponName&gt; Name of the desired weapon to check</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the total amount of ammo the client has for the currently equipped weapon<BR><B>EXAMPLE:  </B>ammoCount = GetTotalAmmo( localClientNum, "ak47_mp" )<BR></OL><P>
<HR><H1>void GetTotalServerPauseTime()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the total time the server has been paused since the map started.<BR><B>EXAMPLE:  </B>val = GetTotalServerPauseTime()<BR></OL><P>
<HR><H1>void gettotalunlockedweaponattachments(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; weapon</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get total number of attachments that are unlocked for the weapon specified<BR><B>EXAMPLE:  </B>player GetTotalUnlockedWeaponAttachements( weapon )<BR></OL><P>
<HR><H1>entity GetTouchingVolume(<I>&lt;origin&gt;</I>,<I>&lt;mins&gt;</I>,<I>&lt;maxs&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; Position of bounding box<LI>        <B>[MANDATORY]</B>  &lt;mins&gt; The minimum extents of the bounding box<LI>        <B>[MANDATORY]</B>  &lt;maxs&gt; The maximum extents of the bounding box</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the entities that are inside the bounds given<BR><B>EXAMPLE:  </B>entities = GetTouchingVolume( self.origin, mins, maxs )<BR></OL><P>
<HR><H1>void &lt;trigger&gt; GetTriggerAccumulate()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the accumulate value from the trigger<BR><B>EXAMPLE:  </B>self GetTriggerAccumulate()<BR></OL><P>
<HR><H1>void &lt;turret&gt; GetTurretArcLimits()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Return turret info for arc mins and maxs<BR><B>EXAMPLE:  </B>limits turret GetTurretArcLimits()<BR></OL><P>
<HR><H1>void &lt;turret&gt; GetTurretOwner()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the "owner" of this turret<BR><B>EXAMPLE:  </B>turret_user = roof_turret GetTurretOwner()<BR></OL><P>
<HR><H1>void &lt;turret&gt; GetTurretTarget()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the current target of this turret<BR><B>EXAMPLE:  </B>target = roof_turret GetTurretTarget()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetUpgradedPieceNumLives(<I>&lt;piece number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;piece number&gt; The piece index.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the number of lives, or pull reps it should take a zombie to dislodge this piece, if it's upgraded.<BR><B>EXAMPLE:  </B>piece.numLives = ent GetUpgradedPieceNumLives(1)<BR></OL><P>
<HR><H1>void GetUTC()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the UTC time.<BR><B>EXAMPLE:  </B>val = GetUTC()<BR></OL><P>
<HR><H1>void &lt;pathnode&gt; GetValidCoverPeekOuts()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of directions an AI can peek out from a cover node. Possible values are 'over', 'left', and 'right'.<BR><B>EXAMPLE:  </B>GetValidCoverPeekOuts( node )<BR></OL><P>
<HR><H1>void GetVehicleArray(<I>[name]</I>,<I>[key]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [name] Name to search for.<LI>        <B>[OPTIONAL]</B>  [key] The key to search for.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of all of the vehicles in a level<BR><B>EXAMPLE:  </B>enemies = GetVehicleArray( "drones", "targetname" )<BR></OL><P>
<HR><H1>void GetVehicleSpawnerArray(<I>[name]</I>,<I>[key]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [name] Name to search for.<LI>        <B>[OPTIONAL]</B>  [key] The key to search for.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of all of the vehicle spawners in a level<BR><B>EXAMPLE:  </B>enemies = GetVehicleSpawnerArray( "bob", "targetname" )<BR></OL><P>
<HR><H1>void GetVehicleSpawnerTeamArray(<I>&lt;team&gt;</I>,<I>[team]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; a team name, either 'axis', 'allies', or 'neutral'<LI>        <B>[OPTIONAL]</B>  [team] any number of teams names may be added, either 'axis', 'allies', or 'neutral'</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of all of the vehicle spawners in a level with the specified team<BR><B>EXAMPLE:  </B>enemies = GetVehicleSpawnerTeamArray( "axis", "neutral" )<BR></OL><P>
<HR><H1>void GetVehicleTeamArray(<I>[team]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [team] any number of teams names may be added, either 'axis', 'allies', or 'neutral'</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of all of the vehicles in a level that are not sentients<BR><B>EXAMPLE:  </B>enemies = GetVehicleTeamArray( "axis", "neutral" )<BR></OL><P>
<HR><H1>void GetVehicleTriggerFlags()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the spawn flags that will allow vehicles to activate triggers<BR><B>EXAMPLE:  </B>spawn("trigger_radius", (0,0,0), GetVehicleTriggerFlags())<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetVelocity(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the entity's velocity.<BR><B>EXAMPLE:  </B>vel = thing GetVelocity()<BR></OL><P>
<HR><H1>void GetVisibleNode(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>,<I>[ignore entity]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt; starting origin of the path<LI>        <B>[MANDATORY]</B>  &lt;end&gt; ending origin of the path<LI>        <B>[OPTIONAL]</B>  [ignore entity] An entity to ignore during pathnode trace checks</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the farthest visible node on the path from &lt;start&gt; to &lt;end&gt; or undefined if no path exists.<BR><B>EXAMPLE:  </B>node = GetVisibleNode( guy.origin, enemy.origin, guy )<BR></OL><P>
<HR><H1>pathnode GetVisibleNodes(<I>&lt;node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; pathnode to check</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of nodes visible to this node<BR><B>EXAMPLE:  </B>nodes = GetVisibleNodes( cover.node )<BR></OL><P>
<HR><H1>void GetVisionPulseMaxRadius(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the max radius for the localClients vision pulse<BR><B>EXAMPLE:  </B>power = GetVisionPulseMaxRadius( localClientNum )<BR></OL><P>
<HR><H1>void GetVisionPulseRadius(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the current radius for the localClients vision pulse<BR><B>EXAMPLE:  </B>power = GetVisionPulseRadius( localClientNum )<BR></OL><P>
<HR><H1>void getvrcamangles()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the VR camera angles of the player<BR></OL><P>
<HR><H1>void GetVRCamAnglesByLocalClientNum(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the camera angles of the local client given<BR><B>EXAMPLE:  </B>cam_angles = GetVRCamAnglesByLocalClientNum( 0 )<BR></OL><P>
<HR><H1>void getvrcampos()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the VR camera position of the player<BR></OL><P>
<HR><H1>void GetVRCamPosByLocalClientNum(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the camera position of the local client given<BR><B>EXAMPLE:  </B>cam_origin = GetVRCamPosByLocalClientNum( 0 )<BR></OL><P>
<HR><H1>void GetVRControllerAngles(<I>&lt;localClientNum&gt;</I>,<I>&lt;handIdx&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the controller you want the orientation of<LI>        <B>[MANDATORY]</B>  &lt;handIdx&gt; 0 for dominant hand, 1 for secondary hand. Secondary hand is not guaranteed to exist</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>gets the world-space angles of the tracked VR controller<BR><B>EXAMPLE:  </B>pos = self GetVRControllerAngles( 0, (60, 0, 0) ) ...<BR></OL><P>
<HR><H1>void GetVRControllerGripButton(<I>&lt;localClientNum&gt;</I>,<I>&lt;handIdx&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the controller you want<LI>        <B>[MANDATORY]</B>  &lt;handIdx&gt; 0 for dominant hand, 1 for secondary hand. Secondary hand is not guaranteed to exist</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>returns true if the grip button is pressed<BR><B>EXAMPLE:  </B>holding = self GetVRControllerGripButton( 0 ) ...<BR></OL><P>
<HR><H1>void GetVRControllerPosition(<I>&lt;localClientNum&gt;</I>,<I>&lt;handIdx&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the controller you want the position of<LI>        <B>[MANDATORY]</B>  &lt;handIdx&gt; 0 for dominant hand, 1 for secondary hand. Secondary hand is not guaranteed to exist</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>gets the world-space position of the tracked VR controller<BR><B>EXAMPLE:  </B>pos = self GetVRControllerPosition( 0 ) ...<BR></OL><P>
<HR><H1>void GetVRControllerXButton(<I>&lt;localClientNum&gt;</I>,<I>&lt;handIdx&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the controller you want<LI>        <B>[MANDATORY]</B>  &lt;handIdx&gt; 0 for dominant hand, 1 for secondary hand. Secondary hand is not guaranteed to exist</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>returns true if the grip button is pressed<BR><B>EXAMPLE:  </B>holding = self GetVRControllerXButton( 0 ) ...<BR></OL><P>
<HR><H1>void &lt;player&gt; GetWallRunWallNormal()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the normal of the wall the player is running on (or was running on)<BR><B>EXAMPLE:  </B>wall_normal = player GetWallRunWallNormal()<BR></OL><P>
<HR><H1>void GetWatcherWeapons()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns array of weapons that need watchers so they will die when the player respawns<BR><B>EXAMPLE:  </B>watcherWeapons = GetWatcherWeapons()<BR></OL><P>
<HR><H1>void GetWaterHeight(<I>&lt;pos&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;pos&gt; Query position</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the height of the water at this position<BR><B>EXAMPLE:  </B>height = getwaterheight( self.origin )<BR></OL><P>
<HR><H1>void GetWeapon(<I>&lt;weaponname&gt;</I>,<I>[attachmentname_1 or array of attachments]</I>,<I>[attachmentname_2]</I>,<I>[attachmentname_3]</I>,<I>[attachmentname_4]</I>,<I>[attachmentname_5]</I>,<I>[attachmentname_6]</I>,<I>[attachmentname_7]</I>,<I>[attachmentname_8]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weaponname&gt; the name of the base weapon to return<LI>        <B>[OPTIONAL]</B>  [attachmentname_1 or array of attachments] the name of the first attachment to return<LI>        <B>[OPTIONAL]</B>  [attachmentname_2] the name of the second attachment to return<LI>        <B>[OPTIONAL]</B>  [attachmentname_3] the name of the third attachment to return<LI>        <B>[OPTIONAL]</B>  [attachmentname_4] the name of the fourth attachment to return<LI>        <B>[OPTIONAL]</B>  [attachmentname_5] the name of the fifth attachment to return<LI>        <B>[OPTIONAL]</B>  [attachmentname_6] the name of the sixth attachment to return<LI>        <B>[OPTIONAL]</B>  [attachmentname_7] the name of the seventh attachment to return<LI>        <B>[OPTIONAL]</B>  [attachmentname_8] the name of the eighth attachment to return</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the requested weapon object based on game mode agnostic weapon name string<BR><B>EXAMPLE:  </B>GetWeapon( "ar_standard", "acog" )<BR></OL><P>
<HR><H1>void GetWeaponAccuracy(<I>&lt;entity&gt;</I>,<I>&lt;weapon name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity. Must be AI.<LI>        <B>[MANDATORY]</B>  &lt;weapon name&gt; The weapon name.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns accuracy at the distance from the current enemy.<BR><B>EXAMPLE:  </B>getweaponaccuracy( self, "ak47" ), getweaponaccuracy( ai, ai.primaryweapon )<BR></OL><P>
<HR><H1>void GetWeaponAttachments()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR></OL><P>
<HR><H1>void GetWeaponChargeLevel()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the current charge level for charged shot weapons<BR><B>EXAMPLE:  </B>charge = player GetWeaponChargeLevel()<BR></OL><P>
<HR><H1>void GetWeaponForCharacter(<I>&lt;characterIndex&gt;</I>,<I>&lt;sessionmode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;characterIndex&gt; The index of the character in the current game-mode's character table<LI>        <B>[MANDATORY]</B>  &lt;sessionmode&gt; Session Mode Index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the weapon at the given index<BR><B>EXAMPLE:  </B>modelName = GetWeaponForCharacter( 0, "mp" )<BR></OL><P>
<HR><H1>void &lt;weapon&gt; GetWeaponForwardDir()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the weapon's forward direction<BR><B>EXAMPLE:  </B>weapon GetWeaponForwardDir()<BR></OL><P>
<HR><H1>void GetWeaponHackRatio(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the players hack completion ratio<BR><B>EXAMPLE:  </B>GetWeaponHackRatio(localClientNum, 1, "hotgun_zm")<BR></OL><P>
<HR><H1>void GetWeaponModelForCharacter(<I>&lt;characterIndex&gt;</I>,<I>&lt;sessionmode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;characterIndex&gt; The index of the character in the current game-mode's character table<LI>        <B>[MANDATORY]</B>  &lt;sessionmode&gt; Session Mode Index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the name of the weapon model of at the given index<BR><B>EXAMPLE:  </B>modelName = GetWeaponModelForCharacter( 0, "mp" )<BR></OL><P>
<HR><H1>void &lt;weapon&gt; GetWeaponMuzzlePoint()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the weapon's muzzle point<BR><B>EXAMPLE:  </B>weapon GetWeaponMuzzlePoint()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetWeaponOptic(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; Weapon name</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the weapon optic attachment name<BR><B>EXAMPLE:  </B>attachmentName = player GetWeaponOptic( weapon )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetWeaponPosFrac(<I>&lt;local client num&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;local client num&gt; Player to get weapon pos frac for.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Gets the weapon pos frac of the player. It only works for the player.<BR><B>EXAMPLE:  </B>if ( player GetWeaponPosFrac(0) &gt; 0.5 ) )...<BR></OL><P>
<HR><H1>void GetWeaponWithAttachments(<I>&lt;weaponname&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weaponname&gt; the name of the base weapon with attachments to return</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the requested weapon object<BR><B>EXAMPLE:  </B>GetWeapon( "mp7_mp+acog" )<BR></OL><P>
<HR><H1>void GetWeaponWorldModel(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns weaopn world model<BR><B>EXAMPLE:  </B>model = GetWeaponWorldModel("lmg")<BR></OL><P>
<HR><H1>void GetWeaponXCam(<I>&lt;weapon object&gt;</I>,<I>&lt;camera&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon object&gt; The weapon entity<LI>        <B>[MANDATORY]</B>  &lt;camera&gt; The camera to get</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the weapon XCam<BR><B>EXAMPLE:  </B>weapon GetWeaponXCam( GetWeapon( weaponName ), "cam_cac_weapon" )<BR></OL><P>
<HR><H1>void GetXCamForCharacter(<I>&lt;characterIndex&gt;</I>,<I>&lt;sessionmode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;characterIndex&gt; The index of the character in the current game-mode's character table<LI>        <B>[MANDATORY]</B>  &lt;sessionmode&gt; Session Mode Index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the name of the xcam to use for the character pose in the frontend<BR><B>EXAMPLE:  </B>frontendVignetteAnim = GetXCamForCharacter( characterIndex, "mp" )<BR></OL><P>
<HR><H1>void GetXCamMouseControl(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the controller you want the mouse yaw/pitch of</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the current "yaw" and "pitch" of the mouse xcam.  Returns an array with two keys, "yaw" and "pitch".<BR><B>EXAMPLE:  </B>xcammouse = GetXCamMouseControl( localclientnum ) ...<BR></OL><P>
<HR><H1>void GetXModelCenterOffset(<I>&lt;modelname&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;modelname&gt; The name of the xmodel</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Calculates the offset to the center of the model from the origin<BR><B>EXAMPLE:  </B>offset = GetXModelCenterOffset( "modelname" )<BR></OL><P>
<HR><H1>entity GetZBarrierArray()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of all of the zbarrier objects in a level.<BR><B>EXAMPLE:  </B>zbarriers = GetZBarrierArray()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetZBarrierAttackSlotHorzOffset()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the horizontal offset used to offset the position of each attack slot relative to the zbarrier object.  Odd numbers will start in the center of the barrier and offset to each side.  Even numbers will start each side of the center - with no central spot specified.<BR><B>EXAMPLE:  </B>horzOffset = ent GetZBarrierAttackSlotHorzOffset()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetZBarrierNumAttackSlots()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the number of attack slots used by this zbarrier.<BR><B>EXAMPLE:  </B>numSlots = ent GetZBarrierNumAttackSlots()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetZBarrierPieceAnimLengthForState(<I>&lt;index&gt;</I>,<I>&lt;state&gt;</I>,<I>[scalar]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;index&gt; The index of the piece we care about.<LI>        <B>[MANDATORY]</B>  &lt;state&gt; Name of state of interest - choices are 'open', 'closed', 'opening', 'closing'.<LI>        <B>[OPTIONAL]</B>  [scalar] Scalar applied to animation length.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the length in seconds for the animation associated with the supplied state for a piece, in seconds.<BR><B>EXAMPLE:  </B>wait(ent GetZBarrierPieceAnimLengthForState(0, "opening", 0.9))<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetZBarrierPieceAnimState(<I>&lt;piece number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;piece number&gt; The piece index.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the anim state name to be used for zombies tearing this board down.<BR><B>EXAMPLE:  </B>anim_state = ent GetZBarrierPieceAnimState(1)<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetZBarrierPieceAnimSubState(<I>&lt;piece number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;piece number&gt; The piece index.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the anim sub-state name to be used for zombies tearing this board down.<BR><B>EXAMPLE:  </B>anim_state = ent GetZBarrierPieceAnimSubState(1)<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetZBarrierPieceIndicesInState(<I>&lt;state&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;state&gt; Name of state of interest - choices are 'open', 'closed', 'opening', 'closing'.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of integer indices of the zbarriers pieces that are in the specified state.<BR><B>EXAMPLE:  </B>open_pieces = ent GetZBarrierPieceIndicesInState("open")<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetZBarrierPieceState(<I>&lt;piece number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;piece number&gt; The piece index.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the state of the piece indexed in the zbarrier ent. States are open, opening, closed and closing.<BR><B>EXAMPLE:  </B>pieceState = ent GetZBarrierPieceState(1)<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetZBarrierReachThroughAttackAnimState()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the anim state name for reach through attacks used by this zbarrier.<BR><B>EXAMPLE:  </B>attackStateName = ent GetZBarrierReachThroughAttackAnimState()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetZBarrierTauntAnimState()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the anim state name for taunts used by this zbarrier.<BR><B>EXAMPLE:  </B>tauntStateName = ent GetZBarrierTauntAnimState()<BR></OL><P>
<HR><H1>void &lt;entity&gt; Ghost()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Used when the entity should be sent over the network to clients but not be drawn<BR><B>EXAMPLE:  </B>model Ghost()<BR></OL><P>
<HR><H1>void &lt;entity&gt; Gib(<I>&lt;gibtype&gt;</I>,<I>&lt;parent&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;gibtype&gt; Type of gib<LI>        <B>[MANDATORY]</B>  &lt;parent&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gib an entity<BR><B>EXAMPLE:  </B>self gib( "normal", temp_array )<BR></OL><P>
<HR><H1>void GlassRadiusDamage(<I>&lt;origin&gt;</I>,<I>&lt;radius&gt;</I>,<I>&lt;max_damage&gt;</I>,<I>&lt;min_damage&gt;</I>,<I>[means_of_death]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; Origin of damage<LI>        <B>[MANDATORY]</B>  &lt;radius&gt; Radius of damage<LI>        <B>[MANDATORY]</B>  &lt;max_damage&gt; Max damage, this is the damage at the origin<LI>        <B>[MANDATORY]</B>  &lt;min_damage&gt;Max damage, this is the damage at the edge of the radius<LI>        <B>[OPTIONAL]</B>  [means_of_death] Means of death passed to the glass system from script, defaults to MOD_EXPLOSIVE</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Damages glass in the radius<BR><B>EXAMPLE:  </B>GlassRadiusDamage( origin, range, max_damage, min_damage, means_of_damage )<BR></OL><P>
<HR><H1>void GrenadeExplosionEffect(<I>&lt;position&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; Position of the fx</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Create a grenade explosion effect at the position<BR></OL><P>
<HR><H1>entity GroundTrace(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>,<I>&lt;hit characters&gt;</I>,<I>&lt;ignore entity&gt;</I>,<I>[ignore water]</I>,<I>[ignore glass]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt; The bullet start point<LI>        <B>[MANDATORY]</B>  &lt;end&gt; The bullet end point<LI>        <B>[MANDATORY]</B>  &lt;hit characters&gt; When set to true, this will trace for character hits<LI>        <B>[MANDATORY]</B>  &lt;ignore entity&gt; An entity to ignore<LI>        <B>[OPTIONAL]</B>  [ignore water] Optionally ignore water. (bool)<LI>        <B>[OPTIONAL]</B>  [ignore glass] Optionally ignore glass. (bool)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Allows script to do a point trace with MASK_SHOT + MASK_ITEM. Returns hit position, hit entity, hit surface normal.<BR><B>EXAMPLE:  </B>trace = GroundTrace(magicBulletOrigin.origin, eyePos, true, undefined)<BR></OL><P>
<HR><H1>void &lt;entity&gt; HasAnimTree()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if the entity has an anim tree<BR><B>EXAMPLE:  </B>self HasAnimTree()<BR></OL><P>
<HR><H1>void &lt;entity&gt; HasASM()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if this entity has an ASM.<BR><B>EXAMPLE:  </B>if ( HasASM( self ) ) {<BR></OL><P>
<HR><H1>void &lt;entity&gt; HasDObj(<I>&lt;local client number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;local client number&gt; number of the local client on the machine.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns 1 if the entity currently has a dobj.<BR><B>EXAMPLE:  </B>if(ent HasDObj(0))<BR></OL><P>
<HR><H1>void &lt;entity&gt; HasPart(<I>&lt;tagname&gt;</I>,<I>[modelname]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;tagname&gt; The tag to search for. (string)<LI>        <B>[OPTIONAL]</B>  [modelname] The optional model name to help specify the part location. (string)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns whether the entity has the given tagname as part of its skeleton.<BR><B>EXAMPLE:  </B>has_part = self HasPart( "tag_weapon", "weapon_saw" )<BR></OL><P>
<HR><H1>void HeliTurretDogTrace(<I>&lt;position&gt;</I>,<I>&lt;dog&gt;</I>,<I>&lt;hitNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; place that check if you can see if being performed<LI>        <B>[MANDATORY]</B>  &lt;dog&gt; the dog that the helicopter wants to see<LI>        <B>[MANDATORY]</B>  &lt;hitNum&gt; if you run this more than once make sure to populate this with the return of the last as it will increase efficiency</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Determines if you helicopter turret can see the dog.<BR><B>EXAMPLE:  </B>if (0 == (copter HeliTurretSightTrace(heli_turret_point, dog, lastHit))<BR></OL><P>
<HR><H1>void HeliTurretSightTrace(<I>&lt;position&gt;</I>,<I>&lt;player&gt;</I>,<I>&lt;hitNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; place that check if you can see if being performed<LI>        <B>[MANDATORY]</B>  &lt;player&gt; the player that the helicopter wants to see<LI>        <B>[MANDATORY]</B>  &lt;hitNum&gt; if you run this more than once make sure to populate this with the return of the last as it will increase efficiency</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Determines if you helicopter turret can see an the players eyes.<BR><B>EXAMPLE:  </B>if (0 == (copter HeliTurretSightTrace(heli_turret_point, player, lastHit))<BR></OL><P>
<HR><H1>void &lt;entity&gt; Hide()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Hide the entity<BR><B>EXAMPLE:  </B>self Hide()<BR></OL><P>
<HR><H1>void &lt;entity&gt; HideFromTeam(<I>&lt;team&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; The team to show the entity to.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Hides the entity from a particular team<BR><B>EXAMPLE:  </B>self HideFromTeam( friend_team )<BR></OL><P>
<HR><H1>void hideinfovolume(<I>&lt;entnum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entnum&gt; the entity number of the info volume</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stops an info volume from being drawn<BR><B>EXAMPLE:  </B>InfoVolumeDebug_HideVolume( info_volume GetEntityNumber() )<BR></OL><P>
<HR><H1>void HideMiscModels(<I>&lt;targetname&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;targetname&gt; targetname of misc model(s).</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Hide all misc models with this targetname<BR><B>EXAMPLE:  </B>HideMiscModels( "crash_destruct" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; HidePart(<I>&lt;tagname&gt;</I>,<I>[modelname]</I>,<I>[bApplyToChildren]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;tagname&gt; The tag to hide. All surfaces with a vertex weighted to the tag will be hidden and have no bullet collision. (string)<LI>        <B>[OPTIONAL]</B>  [modelname] The optional model name to help specify the part location. (string)<LI>        <B>[OPTIONAL]</B>  [bApplyToChildren] Optional flag to specify if we should apply the operation to children bones as well. (boolean)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Hide part of an entity.<BR><B>EXAMPLE:  </B>self HidePart( "tag_weapon", "weapon_saw" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; HideZBarrierPiece(<I>&lt;piece number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;piece number&gt; The piece index.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stops the indexed piece from being drawn.<BR><B>EXAMPLE:  </B>ent HideZBarrierPiece(1)<BR></OL><P>
<HR><H1>void IncrementCounter(<I>&lt;counterType&gt;</I>,<I>&lt;increment&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;counterType&gt; The counter type<LI>        <B>[MANDATORY]</B>  &lt;increment&gt; The increment type</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Increments the counter<BR><B>EXAMPLE:  </B>IncrementCounter( "global_comebacks", level.globalComebacks )<BR></OL><P>
<HR><H1>void &lt;player&gt; incrementSpecificWeaponPickedUpCount(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; the weapon</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>increment the count of the times we've picked up this weapon (uniquely identified by weapon+attachemnts; see function: areWeaponsEqual )<BR><B>EXAMPLE:  </B>self incrementSpecificWeaponPickedUpCount( weapon )<BR></OL><P>
<HR><H1>void InfoVolumeDebugInit()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Initializes the info volume debug array<BR><B>EXAMPLE:  </B>DebugInfoVolume()<BR></OL><P>
<HR><H1>void InitClientObjectives(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; client on which to clear the objectives.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Delete a spawned effect.<BR><B>EXAMPLE:  </B>InitObjectives( 0 )<BR></OL><P>
<HR><H1>void &lt;client&gt; InLastStand()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check the last stand state for the client<BR><B>EXAMPLE:  </B>if ( self InLastStand() )<BR></OL><P>
<HR><H1>void IPrintLn(<I>&lt;text&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;text&gt; text to be written</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Write line to the screen<BR><B>EXAMPLE:  </B>IPrintLn( "Where have all the cowboys gone?" )<BR></OL><P>
<HR><H1>void IPrintLnBold(<I>&lt;text&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;text&gt; text to be written</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>write bold line to the screen<BR><B>EXAMPLE:  </B>IPrintLnBold( "Mitchell!" )<BR></OL><P>
<HR><H1>void IsActor(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity object that may be an ai character</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this entity is an ai character<BR><B>EXAMPLE:  </B>if ( IsActor( gun_owner ) ) ...<BR></OL><P>
<HR><H1>void IsActorCorpse(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity object that might be a corpse</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this entity is an actor corpse<BR><B>EXAMPLE:  </B>if ( IsActorCorpse( corpse ) ) ...<BR></OL><P>
<HR><H1>void IsActorSpawner(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity object that may be an actor spawner</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this entity is an actor spawner<BR><B>EXAMPLE:  </B>if ( IsActorSpawner( ent ) ) ...<BR></OL><P>
<HR><H1>void IsADS(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if this local client is in ADS, false otherwise<BR><B>EXAMPLE:  </B>IsADS( 0 )<BR></OL><P>
<HR><H1>void IsAI(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity object that may be an ai character</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this entity is an ai character<BR><B>EXAMPLE:  </B>if ( IsAI( gun_owner ) ) ...<BR></OL><P>
<HR><H1>void IsAirborne(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity object</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this entity is an airborne unit<BR><B>EXAMPLE:  </B>if ( IsAirborne( gun_owner ) ) ...<BR></OL><P>
<HR><H1>void IsAlive(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity object that might be alive or dead</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this entity is alive<BR><B>EXAMPLE:  </B>if ( IsAlive( gun_owner ) ) ...<BR></OL><P>
<HR><H1>void IsAnimLooping(<I>&lt;animation&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; an animation that needs to be identified as a looping or not</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets whether an animation is looped or not<BR><B>EXAMPLE:  </B>boolLoop = IsAnimLooping( climbAnim )<BR></OL><P>
<HR><H1>void IsArchetypeLoaded()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if a given archetype is loaded in the level.<BR><B>EXAMPLE:  </B>if ( IsArchetypeLoaded( ARCHETYPE_WARLORD ) )<BR></OL><P>
<HR><H1>void IsArenaMode()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if we are in arena mode<BR><B>EXAMPLE:  </B>if ( IsArenaMode() ) ...<BR></OL><P>
<HR><H1>void IsAssetLoaded(<I>&lt;assetType&gt;</I>,<I>&lt;assetName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;assetType&gt; "weapon" or "material"<LI>        <B>[MANDATORY]</B>  &lt;assetName&gt; The name of the asset - should match zone_source</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check whether or not an asset is loaded.<BR><B>EXAMPLE:  </B>IsAssetLoaded( "weapon", "rpg" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsAttached(<I>&lt;modelname&gt;</I>,<I>[tagname]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;modelname&gt; The name of the model to test if attached.<LI>        <B>[OPTIONAL]</B>  [tagname] The tag to test</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if the model is attached to the entity<BR><B>EXAMPLE:  </B>self IsAttached( "somemodel", "tag_origin" )<BR></OL><P>
<HR><H1>void &lt;player&gt; IsBonusCardActive(<I>&lt;bonuscard&gt;</I>,<I>&lt;classnum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;bonuscard&gt; BonusCard index from bonuscard.gsh<LI>        <B>[MANDATORY]</B>  &lt;classnum&gt; The current class num of the player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns if the bonus card is enabled and active in the class, cannot be called on a larry<BR><B>EXAMPLE:  </B>primary = self IsBonusCardActive( BONUSCARD_PRIMARY_GUNFIGHTER_INDEX, self.class_num )<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsBot()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the entity is a bot controlled player<BR><B>EXAMPLE:  </B>if( self IsBot() )<BR></OL><P>
<HR><H1>void IsCamAnimLooping(<I>&lt;cam_anim&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;cam_anim&gt; The animation to play</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns whether or not a specific camera anim loop.<BR><B>EXAMPLE:  </B>IsCamAnimLooping( "proto_melee_cam" )<BR></OL><P>
<HR><H1>void IsCameraSpikeToggled(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the camera spike owner</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns 1 if the camera spike is toggled to be active, 0 otherwise<BR><B>EXAMPLE:  </B>if ( IsCameraSpikeToggled( 0 ) )<BR></OL><P>
<HR><H1>void &lt;player&gt; IsClientCacheStable()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Is the players client cache stable, have we loaded all other clients' resources.<BR><B>EXAMPLE:  </B>player IsClientCacheStable()<BR></OL><P>
<HR><H1>void &lt;player&gt; IsContentScreenFilterPlaying()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns whether or not this player is playing a Graphics Content blocking filter at this moment or not.<BR></OL><P>
<HR><H1>void IsCorpse(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity object that might be a corpse</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this entity is a corpse<BR><B>EXAMPLE:  </B>if ( IsCorpse( gun_owner ) ) ...<BR></OL><P>
<HR><H1>void IsCoverNode(<I>&lt;node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; The node to delete</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns true if the node is of type NODE_TYPEFLAGS_COVER_ONLY<BR><B>EXAMPLE:  </B>IsCoverNode( node )<BR></OL><P>
<HR><H1>void &lt;pathnode&gt; IsDangerous(<I>&lt;team&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; Name of the team.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the pathnode is dangerous for the given team<BR><B>EXAMPLE:  </B>if ( node IsDangerous( team ) ) { //do something }<BR></OL><P>
<HR><H1>void IsDedicated()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true/false if we are running on the dedicated server<BR><B>EXAMPLE:  </B>if ( IsDedicated() )<BR></OL><P>
<HR><H1>void IsDemoPlaying()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if a demo is currently playing back<BR><B>EXAMPLE:  </B>if ( IsDemoPlaying() )<BR></OL><P>
<HR><H1>void &lt;player&gt; IsDoubleJumping()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player is double jumping.<BR><B>EXAMPLE:  </B>if(player DoubleJumping())<BR></OL><P>
<HR><H1>void &lt;player&gt; IsDriving(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the caller</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if the player is driving a vehicle.<BR><B>EXAMPLE:  </B>if ( self IsDriving( &lt;localClientNum&gt; ) )<BR></OL><P>
<HR><H1>void IsDynEntValid(<I>&lt;dynent&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;dynent&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns if the dynEnt still valid or not<BR><B>EXAMPLE:  </B>if( IsDynEntValid( dyn_id) )<BR></OL><P>
<HR><H1>void IsEMPJammed()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if this player is jammed by the emp, false otherwise<BR><B>EXAMPLE:  </B>if ( player IsEMPJammed() )<BR></OL><P>
<HR><H1>void IsEntity(<I>&lt;variable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;variable&gt; variable to test</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether given variable is of type entity.<BR><B>EXAMPLE:  </B>if ( IsEntity( variable ) ) ...<BR></OL><P>
<HR><H1>void &lt;parententity&gt; IsEntityLinkedToTag(<I>&lt;entity&gt;</I>,<I>[tag]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The entity that we are checking<LI>        <B>[OPTIONAL]</B>  [tag] The tag we are checking</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns is the entity is linked to the parententity, ( on a specific tag optional )<BR><B>EXAMPLE:  </B>if ( player IsEntityLinkedToTag( grenade, "j_head" ) )<BR></OL><P>
<HR><H1>void &lt;ai&gt; IsEventServiced(<I>&lt;eventId&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;eventId&gt; The identifier of the event (integer)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the specified event to serviced.<BR><B>EXAMPLE:  </B>serviced = self IsEventServiced( 100 )<BR></OL><P>
<HR><H1>void &lt;turret&gt; IsFiringTurret()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this turret is firing. The entity must be a turret<BR><B>EXAMPLE:  </B>turret IsFiringTurret()<BR></OL><P>
<HR><H1>void IsFlared()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check is a player is under the influence of a flare<BR><B>EXAMPLE:  </B>if ( player IsFlared() )<BR></OL><P>
<HR><H1>void IsFriendly(<I>&lt;localclientnum&gt;</I>,<I>[predicted]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localclientnum&gt; Local client number of the local client you want to test against<LI>        <B>[OPTIONAL]</B>  [predicted] Test against predicted version, false by default</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if entity is friendly<BR><B>EXAMPLE:  </B>if ( entity IsFriendly( &lt;localClientNum&gt;, [predicted] ) )<BR></OL><P>
<HR><H1>void IsGadgetMeleeCharging()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Is the player in the process of melee charging <BR><B>EXAMPLE:  </B>self IsGadgetMeleeCharging()<BR></OL><P>
<HR><H1>void IsGlobalStatsServer()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the game is a global stats ranked server<BR><B>EXAMPLE:  </B>level.ranked |= IsGlobalStatsServer()<BR></OL><P>
<HR><H1>void IsGodMode(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity object to check for god mode</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this entity is in god mode<BR><B>EXAMPLE:  </B>if ( IsGodMode( player ) ) ...<BR></OL><P>
<HR><H1>void &lt;grenade&gt; isGrenadeDud()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns if a grenade is a dud<BR><B>EXAMPLE:  </B>if ( grenade isGrenadeDud() )<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsHidden()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>return true if entity is hidden<BR><B>EXAMPLE:  </B>self IsHidden()<BR></OL><P>
<HR><H1>void IsInHelicopter(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number to check</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if the client is in a helicopter.<BR><B>EXAMPLE:  </B>if( IsInHelicopter( 0 ) )<BR></OL><P>
<HR><H1>void IsInScrCam(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Check if the camera of local client is in scripted camera<BR><B>EXAMPLE:  </B>inScrCam = IsInScrCam( 0 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsInScritpedAnim()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns 1 if the entity currently has scripted animation playing.<BR><B>EXAMPLE:  </B>if(ent IsInScritpedAnim())<BR></OL><P>
<HR><H1>void IsInSecondChance()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>To check if player is needs revive<BR><B>EXAMPLE:  </B>if ( self IsInSecondChance() )<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsInsideHeightLock()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns whether the entity is inside the height lock or not<BR><B>EXAMPLE:  </B>if( self IsInsideHeightLock() ) { //do something }<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsLaserOn()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>check if the entity has laser turned on.<BR><B>EXAMPLE:  </B>if ( IsLaserOn( entity ) ) { ...<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsLinkedTo(<I>&lt;other&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;other&gt; Entity</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the entity is linked to the other entity<BR><B>EXAMPLE:  </B>if (ent IsLinkedTo( other )) { // dostuff }<BR></OL><P>
<HR><H1>void &lt;player&gt; IsLoadingCinematicPlaying()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Is the player playing the loading cinematic<BR><B>EXAMPLE:  </B>player IsLoadingCinematicPlaying()<BR></OL><P>
<HR><H1>void IsLocalClientDead()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Checks if the pm_type &gt; PM_DEAD<BR><B>EXAMPLE:  </B>IsLocalClientDead()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; IsLocalClientDriver(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the caller</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the driver of the vehicle.<BR><B>EXAMPLE:  </B>driver = self IsLocalClientDriver(0)<BR></OL><P>
<HR><H1>void IsLocalGame()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the game local only<BR><B>EXAMPLE:  </B>level.local = IsLocalGame()<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsLocalPlayer()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if the ent it's called on is a local player.<BR></OL><P>
<HR><H1>void &lt;player&gt; IsLocalPlayerViewLinked(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum of the caller</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns whether or not this entity is linked to the given local client<BR><B>EXAMPLE:  </B>if ( script_mover IsLocalPlayerWeaponViewOnlyLinked( localClientIndex ) ) { ... }<BR></OL><P>
<HR><H1>void &lt;player&gt; IsLocalPlayerWeaponViewOnlyLinked()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns whether or not this player is linked to an enity with weapon view only linking.<BR><B>EXAMPLE:  </B>weaponviewonlylinked = self IsLocalPlayerWeaponViewOnlyLinked()<BR></OL><P>
<HR><H1>void &lt;player&gt; IsMantling()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Return true if the player is mantling, false otherwise.<BR><B>EXAMPLE:  </B>self IsMantling()<BR></OL><P>
<HR><H1>void IsMapSubLevel(<I>[currentmap]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [currentmap] the name of the current map.  If ommitted, use Dvar sv_mapname</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns whether or not the map is a sublevel of a mission<BR><B>EXAMPLE:  </B>level.isSubLevel = IsMapSubLevel( "cp_mi_cairo_ramses2" )<BR></OL><P>
<HR><H1>void IsMature(<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player to check if his Graphic Content Flag is on</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks if a player has his Graphic Content Flag is on<BR><B>EXAMPLE:  </B>IsMature( player )<BR></OL><P>
<HR><H1>void &lt;entity&gt; ismissileinsideheightlock()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns whether the entity is inside the height lock or not<BR><B>EXAMPLE:  </B>if( self IsInsideHeightLock() ) { //do something }<BR></OL><P>
<HR><H1>void IsMovingPlatform()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns whether platform is a moving platform or not<BR><B>EXAMPLE:  </B>platform IsMovingPlatform()<BR></OL><P>
<HR><H1>void IsNavVolumeLoaded()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether nav volume is loaded<BR><B>EXAMPLE:  </B>if ( IsNavVolumeLoaded() ) ...<BR></OL><P>
<HR><H1>void IsNodeEnabled(<I>&lt;node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; The node to check</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns true if the node is enabled, false otherwise<BR><B>EXAMPLE:  </B>IsNodeEnabled( node )<BR></OL><P>
<HR><H1>void IsNodeOccupied(<I>&lt;node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; which node to check.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>See if anyone has claimed a particular node.<BR><B>EXAMPLE:  </B>if ( IsNodeOccupied( node ) )<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsOnGround()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if entity is on ground<BR><B>EXAMPLE:  </B>if( self IsOnGround() ) { //do something }<BR></OL><P>
<HR><H1>void &lt;player&gt; IsOnLadder()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Return true if the player is on a ladder, false otherwise.<BR><B>EXAMPLE:  </B>self IsOnLadder()<BR></OL><P>
<HR><H1>void &lt;player&gt; IsOnSlide()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Return true if the player is in the player movement slide.<BR><B>EXAMPLE:  </B>self IsOnSlide()<BR></OL><P>
<HR><H1>void IsOnTurret(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if the player is currently on a turret<BR><B>EXAMPLE:  </B>if( IsOnTurret( 0 ) )<BR></OL><P>
<HR><H1>void IsPathfinder(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity to check</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this entity is registered with navigation system so it can do pathfinding and position query<BR><B>EXAMPLE:  </B>if ( IsPathfinder( tank ) ) ...<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsPaused()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns whether a given entity is paused as part of a world pause.<BR><B>EXAMPLE:  </B>if ( ent IsPaused() )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; IsPeelingOut()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if the vehicle is currently peeling out.<BR><B>EXAMPLE:  </B>if ( self IsPeelingOut() ) { }<BR></OL><P>
<HR><H1>void IsPlayer(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity object that may be the player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this entity is the player<BR><B>EXAMPLE:  </B>if ( IsPlayer( gun_owner ) ) ...<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsPlayerCorpse()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if the ent it's called on is a player corpse.<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsPlayerDead()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns 1 if the entity currently has health of 0 or less<BR><B>EXAMPLE:  </B>if(ent IsPlayerDead())<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsPlayerDoubleJumping()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns 1 if the player is currently double jumping (boosting)<BR><B>EXAMPLE:  </B>if(ent IsPlayerDoubleJumping())<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsPlayerFiring()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns 1 if the player is currently firing<BR><B>EXAMPLE:  </B>if(ent IsDead())<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsPlayerJumping()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns 1 if the player is currently jumping<BR><B>EXAMPLE:  </B>if(ent IsPlayerJumping())<BR></OL><P>
<HR><H1>void IsPlayerNumber()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the passed in int is a valid client number<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsPlayerSliding()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns 1 if the player is currently sliding<BR><B>EXAMPLE:  </B>if(ent IsPlayerSliding())<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsPlayerSprinting()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns 1 if the player is currently sprinting<BR><B>EXAMPLE:  </B>if(ent IsPlayerSprinting())<BR></OL><P>
<HR><H1>void &lt;player&gt; IsPlayerSwimming()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Return if a player is swimming<BR><B>EXAMPLE:  </B>depth = get_players()[0] IsPlayerSwimming()<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsPlayerSwimmingOnSurface()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Return if a player is swimming<BR><B>EXAMPLE:  </B>swimming = player IsPlayerSwimmingOnSurface()<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsPlayerSwimmingUnderwater()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Return if a player is swimming<BR><B>EXAMPLE:  </B>swimming = player IsPlayerSwimmingUnderwater()<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsPlayerTalking()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns 1 if the player is talking<BR><B>EXAMPLE:  </B>if(ent IsPlayerTalking())<BR></OL><P>
<HR><H1>void &lt;player&gt; IsPlayerUnderwater()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Return if a player is underwater<BR><B>EXAMPLE:  </B>depth = get_players()[0] IsPlayerUnderwater()<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsPlayerWallRunning()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns 1 if the player is currently wall running<BR><B>EXAMPLE:  </B>if(ent IsPlayerWallRunning())<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsPlayerWallRunningRight()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns 1 if the player is currently wall running right<BR><B>EXAMPLE:  </B>if(ent IsPlayerWallRunning())<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsPlayingAnimScripted()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the entity is playing in scripted animation.<BR><B>EXAMPLE:  </B>if(player IsPlayingAnimScripted())<BR></OL><P>
<HR><H1>void IsPlayingLoopSound(<I>[alias]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [alias] specific alias to check for</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if the entity is playing a loop sound<BR><B>EXAMPLE:  </B>car IsPlayingLoopSound()<BR></OL><P>
<HR><H1>void IsPointInNavVolume(<I>&lt;position&gt;</I>,<I>&lt;navVolumeName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; Position to evaluate.<LI>        <B>[MANDATORY]</B>  &lt;navVolumeName&gt; Either "navvolume_small" or "navvolume_big".</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks if a given point is within the specified navigation volume.<BR><B>EXAMPLE:  </B>result = IsPointInNavVolume( (10,20,30), "small volume" )<BR></OL><P>
<HR><H1>void IsPointOnNavMesh(<I>&lt;position&gt;</I>,<I>[entity / radius]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; Position to evaluate.<LI>        <B>[OPTIONAL]</B>  [entity / radius] the point is for this entity to path to, or an estimate radius of the expected character radius. default to radius 0. Note: not passing in the entity can cause false positive when point is on NavMesh but too close to boundary / on wrong material / in disabled navmesh trigger; or false negative when big character's origin is far below NavMesh but still within tolerant height.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks if a given point is valid on the NavMesh. This check performs all the necessary validation such as away from boundary, correct material, navmesh trigger, etc.<BR><B>EXAMPLE:  </B>isValid = IsPointOnNavMesh( (10,20,30), self )<BR></OL><P>
<HR><H1>void IsPoisoned()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check is a player is under the influence of gas<BR><B>EXAMPLE:  </B>if ( player IsPoisoned() )<BR></OL><P>
<HR><H1>void &lt;player_or_playercorpse&gt; IsRagdoll()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Return true if the entity is a ragdoll body, false otherwise.<BR><B>EXAMPLE:  </B>if( player IsRagdoll() ) { //do something }<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsRobot()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if the ent it's called on is a sentient vehicle i.e. a Robot.<BR></OL><P>
<HR><H1>void &lt;player&gt; IsScrambled()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the if player is getting scrambled by an enemy<BR><B>EXAMPLE:  </B>if ( player IsScrambled( ) )<BR></OL><P>
<HR><H1>void IsSentient(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity object that may be a sentient character</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this entity is a sentient, that is normally either an ai actor, ai vehicle or the player<BR><B>EXAMPLE:  </B>if ( IsSentient( vehicle.riders[j] ) ) ...<BR></OL><P>
<HR><H1>void IsShoutcaster(<I>&lt;localClientNum&gt;</I>,<I>[checkFistPerson]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Number of the local client to check<LI>        <B>[OPTIONAL]</B>  [checkFistPerson] Check if we want first person spectating to be not considered as spectate</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns 1 if the local client is shoutcasting<BR><B>EXAMPLE:  </B>if ( IsSpectating( localClientNum, false ) )<BR></OL><P>
<HR><H1>void &lt;player&gt; IsSlamming()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player is slamming.<BR><B>EXAMPLE:  </B>if(player IsSlamming())<BR></OL><P>
<HR><H1>void &lt;player&gt; IsSliding()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player is sliding.<BR><B>EXAMPLE:  </B>if(player IsSliding())<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsSpawner(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity object that may be a spawner</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this entity is a spawner<BR><B>EXAMPLE:  </B>if ( IsSpawner( ent ) ) ...<BR></OL><P>
<HR><H1>void IsSpawnPointVisible(<I>&lt;point&gt;</I>,<I>&lt;angles&gt;</I>,<I>&lt;team&gt;</I>,<I>&lt;ignore player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;point&gt; Spawnpoint origin that needs to be checked<LI>        <B>[MANDATORY]</B>  &lt;angles&gt; Spawnpoint angles that needs to be checked<LI>        <B>[MANDATORY]</B>  &lt;team&gt; Team that we need to check against the point<LI>        <B>[MANDATORY]</B>  &lt;ignore player&gt; The player that we are spawning in</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true or false if a point is visible to the given team<BR><B>EXAMPLE:  </B>if ( IsSpawnPointVisible( point_position, point_angles, "axis", player ) )<BR></OL><P>
<HR><H1>void IsSpectating(<I>&lt;localClientNum&gt;</I>,<I>[checkFistPerson]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Number of the local client to check<LI>        <B>[OPTIONAL]</B>  [checkFistPerson] Check if we want first person spectating to be not considered as spectate</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns 1 if the local client is spectating<BR><B>EXAMPLE:  </B>if ( IsSpectating( localClientNum, false ) )<BR></OL><P>
<HR><H1>void IsSplitScreen()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the game is a splitscreen game<BR><B>EXAMPLE:  </B>level.splitscreen = IsSplitScreen()<BR></OL><P>
<HR><H1>void &lt;player&gt; IsSplitScreenHost()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if local player is the host<BR><B>EXAMPLE:  </B>if ( player IsSplitScreenHost() ) { }<BR></OL><P>
<HR><H1>void &lt;player&gt; IsSprinting()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player is sprinting.<BR><B>EXAMPLE:  </B>if(player IsSprinting())<BR></OL><P>
<HR><H1>void &lt;player&gt; IsStarterPack()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player has starter pack<BR><B>EXAMPLE:  </B>if ( self IsStarterPack() )<BR></OL><P>
<HR><H1>void &lt;player&gt; IsStartingClassDefault()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the starting class is the default class for the level<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsStreamed()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if this entity is fully streamed in<BR><B>EXAMPLE:  </B>thing isStream()<BR></OL><P>
<HR><H1>void &lt;player&gt; IsStreamerReady()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Is the players streamer ready.<BR><B>EXAMPLE:  </B>player IsStreamerReady()<BR></OL><P>
<HR><H1>void IsSwimming(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns 1 if the player is swimming.<BR><B>EXAMPLE:  </B>isSwimming = IsSwimming( localclientnum )<BR></OL><P>
<HR><H1>void &lt;player&gt; IsTestClient()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player is a test client (Does not have a remote user).<BR><B>EXAMPLE:  </B>if( self IsTestClient() )<BR></OL><P>
<HR><H1>void IsThirdPerson()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Checks if the camera mode to third person if true<BR><B>EXAMPLE:  </B>IsThirdPerson()<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsTouching(<I>&lt;other entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;other entity&gt;  Entity.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if &lt;other entity&gt; is touching &lt;entity&gt<BR><B>EXAMPLE:  </B>if( player IsTouching( e_goal_volume ) ) { //do something }<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsTouchingSwept(<I>&lt;other entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;other entity&gt;  Entity.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if &lt;other entity&gt; is touching &lt;entity&gt<BR><B>EXAMPLE:  </B>if( player IsTouchingSwept( e_goal_volume ) ) { //do something }<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsTouchingVolume(<I>&lt;origin&gt;</I>,<I>&lt;volume mins&gt;</I>,<I>&lt;volume maxs&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; Origin of the volume<LI>        <B>[MANDATORY]</B>  &lt;volume mins&gt; The min extents of the volume<LI>        <B>[MANDATORY]</B>  &lt;volume maxs&gt; The max extents of the volume</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if entity is touching the volume.<BR><B>EXAMPLE:  </B>if ( crate_ent IsTouchingVolume( origin + (0,0,40), mins, maxs ) )<BR></OL><P>
<HR><H1>void &lt;player&gt; IsTraversing()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player is traversing.<BR><B>EXAMPLE:  </B>if(player IsTraversing())<BR></OL><P>
<HR><H1>void &lt;trigger&gt; IsTriggerEnabled()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if trigger is enabled. False otherwise<BR><B>EXAMPLE:  </B>if( trig isTriggerEnabled() )<BR></OL><P>
<HR><H1>void &lt;turret&gt; IsTurretFiring()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks if this turret is firing<BR><B>EXAMPLE:  </B>if( IsTurretFiring( roof_turret ) )<BR></OL><P>
<HR><H1>void &lt;turret&gt; IsTurretLockedOn()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this turret is locked onto a target. The entity must be a turret<BR><B>EXAMPLE:  </B>turret IsTurretLockedOn()<BR></OL><P>
<HR><H1>void IsUnderwater(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns 1 if the player is underwater.<BR><B>EXAMPLE:  </B>clipCount = IsUnderwater( localclientnum )<BR></OL><P>
<HR><H1>void IsUsingNavVolume(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity object</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this entity is using Nav Volume. Note this is a relatively low level check. For general gameplay check whether an entity is flying, consider using IsAirborne.<BR><B>EXAMPLE:  </B>if ( IsUsingNavVolume( gun_owner ) ) ...<BR></OL><P>
<HR><H1>void isUsingT7Melee()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true T7 Melee system is being used<BR></OL><P>
<HR><H1>void IsValidGametype(<I>&lt;game type&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;game type&gt; a string to check</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the string is a valid game type<BR></OL><P>
<HR><H1>void IsVehicle(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity object that may be an ai character</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this entity is an ai character<BR><B>EXAMPLE:  </B>if ( IsVehicle( gun_owner ) ) ...<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsVehicleSpawner(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity object that may be a vehicle spawner</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this entity is a vehicle spawner<BR><B>EXAMPLE:  </B>if ( IsVehicleSpawner( ent ) ) ...<BR></OL><P>
<HR><H1>void IsVisibleByPlayer()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns 1 if the actor can be seen by a player<BR><B>EXAMPLE:  </B>if( IsVisibleByPlayer(ent) )<BR></OL><P>
<HR><H1>void isvr()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>check if this player has VR enabled<BR></OL><P>
<HR><H1>void &lt;player&gt; IsWallRunning()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player is wall running.<BR><B>EXAMPLE:  </B>if(player IsWallRunning())<BR></OL><P>
<HR><H1>void IsWallrunNode(<I>&lt;node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; The node to check</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns true if the node has the PNF_WALLRUN flag set<BR><B>EXAMPLE:  </B>IsWallrunNode( node )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; IsWheelColliding(<I>&lt;wheel&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;wheel&gt; The wheel position, can be 'front_left', 'front_right', 'back_left', 'back_right', 'middle_left', 'middle_right'</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns if the given wheel is on the ground.<BR><B>EXAMPLE:  </B>colliding = self IsWheelColliding( front_left )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; IsWheelPeelingOut(<I>&lt;wheel&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;wheel&gt; The wheel position, can be 'front_left', 'front_right', 'back_left', 'back_right', 'middle_left', 'middle_right'</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns if the given wheel is sliding.<BR><B>EXAMPLE:  </B>peeling = self IsWheelPeelingOut( front_left )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; IsWheelSliding(<I>&lt;wheel&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;wheel&gt; The wheel position, can be 'front_left', 'front_right', 'back_left', 'back_right', 'middle_left', 'middle_right'</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns if the given wheel is sliding.<BR><B>EXAMPLE:  </B>sliding = self IsWheelSliding( front_left )<BR></OL><P>
<HR><H1>void IsWorldPaused()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns whether or not the world is currently paused<BR><B>EXAMPLE:  </B>if ( IsWorldPaused() )<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsZBarrier()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the entity called on is a zbarrier.<BR><B>EXAMPLE:  </B>if(ent IsZBarrier())<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsZBarrierClosed()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the state of all of the zbarrier's pieces is 'closed'.<BR><B>EXAMPLE:  </B>closed = ent IsZBarrierClosed())<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsZBarrierOpen()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the state of all of the zbarrier's pieces is 'open'.<BR><B>EXAMPLE:  </B>open = ent IsZBarrierOpen())<BR></OL><P>
<HR><H1>void &lt;item&gt; ItemWeaponSetAmmo(<I>&lt;clipAmmo&gt;</I>,<I>&lt;reserveAmmo&gt;</I>,<I>[altIndex]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;clipAmmo&gt; Ammo for the clip<LI>        <B>[MANDATORY]</B>  &lt;reserveAmmo&gt; Reserve ammo<LI>        <B>[OPTIONAL]</B>  [altIndex] Alternate weapon index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the weapon ammo to the given clip ammo and reserve ammo. Can give an alternate weapon index<BR><B>EXAMPLE:  </B>weap ItemWeaponSetAmmo( clip, extra, 1 )<BR></OL><P>
<HR><H1>void Kick(<I>&lt;clientnum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;clientnum&gt; The client number of the player to kick.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Kicks the specified player.<BR><B>EXAMPLE:  </B>Kick( 2 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; Kill(<I>[source position]</I>,<I>[attacker]</I>,<I>[inflictor]</I>,<I>[weapon]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [source position] The position that the damage comes from. Defaults to entity's origin<LI>        <B>[OPTIONAL]</B>  [attacker] The entity that dealt the damage (such as an AI or player)<LI>        <B>[OPTIONAL]</B>  [inflictor] The entity that the damage came from (such as a grenade or turret)<LI>        <B>[OPTIONAL]</B>  [weapon]weapon to do damage with</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Kills this entity. If the entity could not be killed, errors. Automatically sets setCanDamage( true ).<BR><B>EXAMPLE:  </B>level.player kill()<BR></OL><P>
<HR><H1>void KillClientRadiantExploder(<I>&lt;exploder id&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;exploder id&gt; string id of exploder to deactivate</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Deactivates a client side radiant exploder<BR><B>EXAMPLE:  </B>DeactivateClientRadiantExploder( "light_switch" )<BR></OL><P>
<HR><H1>void KillServer()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>kills the server<BR><B>EXAMPLE:  </B>KillServer()<BR></OL><P>
<HR><H1>void &lt;entity&gt; LaserOff()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Turns off entity's laser sight.<BR><B>EXAMPLE:  </B>self LaserOff()<BR></OL><P>
<HR><H1>void &lt;entity&gt; LaserOn()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Turns on entity's laser sight.<BR><B>EXAMPLE:  </B>self LaserOn()<BR></OL><P>
<HR><H1>void &lt;entity&gt; Launch(<I>&lt;initial velocity&gt;</I>,<I>[initial angular velocity]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;initial velocity&gt; The initial velocity of the launch.<LI>        <B>[OPTIONAL]</B>  [initial angular velocity] The initial angular velocity of the launch.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Launch an object that interacts with the world, using an initial velocity. From this point on this object will no longer block either missiles or bullets.<BR><B>EXAMPLE:  </B>self Launch( (x, y, z) )<BR></OL><P>
<HR><H1>void launchdynent(<I>&lt;dynent&gt;</I>,<I>&lt;force&gt;</I>,<I>[hitp]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;dynent&gt;<LI>        <B>[MANDATORY]</B>  &lt;force&gt; the direction and magnitude of the force applied<LI>        <B>[OPTIONAL]</B>  [hitp] the location of the hitpoint in world space</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Launch a dynent<BR><B>EXAMPLE:  </B>launchdynent( brick, (0,0,200) )<BR></OL><P>
<HR><H1>void &lt;entity&gt; LaunchRagdoll(<I>&lt;force&gt;</I>,<I>[bonename]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;force&gt; launch force<LI>        <B>[OPTIONAL]</B>  [bonename] bone name to apply the force to</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Launch this ragdoll.<BR><B>EXAMPLE:  </B>self LaunchRagdoll( (0,0,100) )<BR></OL><P>
<HR><H1>void &lt;entity&gt; LaunchVehicle(<I>&lt;force&gt;</I>,<I>bone name to apply the force to</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;force&gt; launch force<LI>        <B>[OPTIONAL]</B>  bone name to apply the force to</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Launch this physics vehicle.<BR><B>EXAMPLE:  </B>panzer LaunchVehicle( (0,0,100) )<BR></OL><P>
<HR><H1>void &lt;player&gt; LerpViewAngleClamp(<I>&lt;time&gt;</I>,<I>&lt;accel time&gt;</I>,<I>&lt;decel time&gt;</I>,<I>&lt;right arc&gt;</I>,<I>&lt;left arc&gt;</I>,<I>&lt;top arc&gt;</I>,<I>&lt;bottom arc&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; Lerp duration in seconds. A value of 0 means instantaneous.<LI>        <B>[MANDATORY]</B>  &lt;accel time&gt; Acceleration time.<LI>        <B>[MANDATORY]</B>  &lt;decel time&gt; Decelaration time.<LI>        <B>[MANDATORY]</B>  &lt;right arc&gt; Angle to clamp view to the right.<LI>        <B>[MANDATORY]</B>  &lt;left arc&gt; Angle to clamp view to the left.<LI>        <B>[MANDATORY]</B>  &lt;top arc&gt; Angle to clamp view to the top.<LI>        <B>[MANDATORY]</B>  &lt;bottom arc&gt; Angle to clamp view to the bottom.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Only works if the player is currently linked to another entity and angles aren't locked. Lerps the current view angle constraints to the provided ones over the specified time.<BR></OL><P>
<HR><H1>void LinkNodes(<I>&lt;node1&gt;</I>,<I>&lt;node2&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node1&gt; first node to link<LI>        <B>[MANDATORY]</B>  &lt;node2&gt; second node to link</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Connects node1 to node2. Call it again with arguments flipped if you want a two-way connection.<BR><B>EXAMPLE:  </B>LinkNodes( node_moving_elev_left, node_moving_elev_right )<BR></OL><P>
<HR><H1>void &lt;non_player_entity&gt; LinkTo(<I>&lt;linkto entity&gt;</I>,<I>[tag]</I>,<I>[originOffset]</I>,<I>[anglesOffset]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;linkto entity&gt; The entity to attach this thing to<LI>        <B>[OPTIONAL]</B>  [tag] The tag to attach the entity to<LI>        <B>[OPTIONAL]</B>  [originOffset] The positional offset from the base position<LI>        <B>[OPTIONAL]</B>  [anglesOffset] The angular offset from the base angles</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Attaches one entity to another<BR><B>EXAMPLE:  </B>self.rightturret LinkTo( self, "tag_gunRight", (0,0,0), (0,0,0) )<BR></OL><P>
<HR><H1>void &lt;non_player_entity&gt; LinkToBlendToTag(<I>&lt;linkto entity&gt;</I>,<I>[tag]</I>,<I>[only yaw]</I>,<I>[collision physics]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;linkto entity&gt; The entity to attach this thing to<LI>        <B>[OPTIONAL]</B>  [tag] The tag to attach the entity to<LI>        <B>[OPTIONAL]</B>  [only yaw] Tells if blending only the yaw. Default to true.<LI>        <B>[OPTIONAL]</B>  [collision physics] Sets whether we should use collision physics. Defaults to false.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Attaches one entity to another, gradually lerping entity to the parents orientation<BR><B>EXAMPLE:  </B>self.rightturret LinkToBlendToTag( self, "tag_gunRight" )<BR></OL><P>
<HR><H1>void LinkToCamera(<I>&lt;linkType&gt;</I>,<I>[offset]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;linkType&gt;, 0 - pitch only, 1 - yaw only, 2 - roll only, 3 - swimming, 4 - full, 5 - 3d compass.  Full is the default if not specified."<LI>        <B>[OPTIONAL]</B>  [offset] Vector of the offset</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Links an entity directly to the camera.  Good for scripted player arms.<BR><B>EXAMPLE:  </B>swimming_arms LinkToCamera()<BR></OL><P>
<HR><H1>void &lt;non_player_entity&gt; LinkToUpdateOffset(<I>&lt;origin_offset&gt;</I>,<I>[angles_offset]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin_offset&gt; The origin offset<LI>        <B>[OPTIONAL]</B>  [angles_offset] The angles offset</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Attaches one entity to another, gradually lerping entity to the parents orientation<BR><B>EXAMPLE:  </B>self.rightturret LinkToUpdateOffset( originsOffset, anglesOffset )<BR></OL><P>
<HR><H1>void LinkTraversal(<I>&lt;node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; Negotiation begin node</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Creates a user edge connecting two path nodes<BR><B>EXAMPLE:  </B>LinkTraversal( beginNode )<BR></OL><P>
<HR><H1>void LoadSentientEventParameters(<I>&lt;scriptBundle&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;scriptBundle&gt; String name of the script bundle to load</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Loads the global sentient event parameters for a given scriptbundle sentient events asset. (all AI will use these)<BR><B>EXAMPLE:  </B>LoadSentientEventParameters( "sentientevents" )<BR></OL><P>
<HR><H1>void LoadSiegeAnim(<I>&lt;anim_name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;anim_name&gt; Name of the siege anim to load</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Load a siege anim into memory<BR><B>EXAMPLE:  </B>LoadSiegeAnim( "flappy_bird" )<BR></OL><P>
<HR><H1>void LocalClientActive(<I>&lt;client&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;client&gt; the client to check if it is active</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Return whether local client is active<BR><B>EXAMPLE:  </B>active = LocalClientActive( 0 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; LocalToWorldCoords(<I>&lt;local coordinate&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;local coordinate&gt; The point in local coordinates (vector3)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Transform the given local coordinate point to a world coordinate point<BR><B>EXAMPLE:  </B>ramboPoint = self LocalToWorldCoords( delta )<BR></OL><P>
<HR><H1>void &lt;actor&gt; LookAtEntity(<I>[otherguy]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [otherguy] the other guy to look at</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set this actor to look at the specified entity. Call this function without any entity specified to turn it off.<BR><B>EXAMPLE:  </B>guy LookAtEntity( otherguy )<BR></OL><P>
<HR><H1>void &lt;actor&gt; LookAtPos(<I>[pos]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [pos] the position to look at</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set this actor to look at the specified position. Call this function without any position specified to turn it off.<BR><B>EXAMPLE:  </B>guy LookAtPos( pos )<BR></OL><P>
<HR><H1>void &lt;player&gt; LUINotifyEvent(<I>[player]</I>,<I>&lt;lui event name&gt;</I>,<I>&lt;num of args&gt;</I>,<I>&lt;args&gt;</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [player] the player to notify. If not specified, all players are notified.<LI>        <B>[MANDATORY]</B>  &lt;lui event name&gt; as an IString<LI>        <B>[MANDATORY]</B>  &lt;num of args&gt; number of parameters<LI>        <B>[MANDATORY]</B>  &lt;args&gt; argument to pass to LUI</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sends a notify from script to LUI.<BR><B>EXAMPLE:  </B>LUINotifyEvent( &"update_objectives", 1, &"LEVEL_GOTO_NEXT_PLACE" )<BR></OL><P>
<HR><H1>void LUINotifyEventToSpectators(<I>&lt;lui event name&gt;</I>,<I>&lt;num of args&gt;</I>,<I>&lt;args&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;lui event name&gt; as an IString<LI>        <B>[MANDATORY]</B>  &lt;num of args&gt; number of parameters<LI>        <B>[MANDATORY]</B>  &lt;args&gt; argument to pass to LUI</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sends a notify from script to LUI.<BR><B>EXAMPLE:  </B>LUINotifyEventToSpectators( &"update_objectives", 1, &"LEVEL_GOTO_NEXT_PLACE" )<BR></OL><P>
<HR><H1>entity MagicBullet(<I>&lt;weapon&gt;</I>,<I>&lt;source&gt;</I>,<I>&lt;destination&gt;</I>,<I>[attacker]</I>,<I>[targetent]</I>,<I>[targetOffset]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; Weapon type of the bullet<LI>        <B>[MANDATORY]</B>  &lt;source&gt; Where the bullet will be spawned<LI>        <B>[MANDATORY]</B>  &lt;destination&gt; Where the bullet will be fired at<LI>        <B>[OPTIONAL]</B>  [attacker] Set the owner of the bullet to this<LI>        <B>[OPTIONAL]</B>  [targetent] The target of the bullet<LI>        <B>[OPTIONAL]</B>  [targetOffset] Offset the target by this vector</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Creates a magic bullet at the source<BR><B>EXAMPLE:  </B>MagicBullet( GetWeapon("sniper_hyperion"), level.sniper_loc.origin, target GetTagOrigin( "tag_eye" ), level.sniper_boss)<BR></OL><P>
<HR><H1>entity &lt;actor&gt; MagicGrenade(<I>&lt;origin&gt;</I>,<I>&lt;target position&gt;</I>,<I>[time to blow]</I>,<I>[weapon]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The starting point of the grenade toss<LI>        <B>[MANDATORY]</B>  &lt;target position&gt; The target point of the grenade toss<LI>        <B>[OPTIONAL]</B>  [time to blow] The grenade fuse time in seconds<LI>        <B>[OPTIONAL]</B>  [weapon] The grenade weapon to use (defaults to equipped grenade weapon)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Creates a "Magic" grenade from an actor.<BR><B>EXAMPLE:  </B>self MagicGrenade( self.origin, target.origin, 2.0 )<BR></OL><P>
<HR><H1>entity &lt;actor&gt; MagicGrenadeManual(<I>&lt;origin&gt;</I>,<I>&lt;velocity&gt;</I>,<I>[time to blow]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The starting point of the grenade toss<LI>        <B>[MANDATORY]</B>  &lt;velocity&gt; The initial velocity vector for the grenade movement<LI>        <B>[OPTIONAL]</B>  [time to blow] The grenade fuse time in seconds</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>creates a "Magic" grenade from an actor<BR><B>EXAMPLE:  </B>self MagicGrenadeManual( self.origin, target.origin, 2.0 )<BR></OL><P>
<HR><H1>entity &lt;player&gt; MagicGrenadeManualPlayer(<I>&lt;origin&gt;</I>,<I>&lt;velocity&gt;</I>,<I>&lt;weapon&gt;</I>,<I>[time to blow]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The starting point of the grenade toss<LI>        <B>[MANDATORY]</B>  &lt;velocity&gt; The initial velocity vector for the grenade movement<LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The grenade weapon to base on<LI>        <B>[OPTIONAL]</B>  [time to blow] The grenade fuse time in seconds</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>creates a "Magic" grenade from a player<BR><B>EXAMPLE:  </B>self MagicGrenadeManualPlayer( self.origin, target.origin, 2.0 )<BR></OL><P>
<HR><H1>entity &lt;player&gt; MagicGrenadePlayer(<I>&lt;weapon&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;velocity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The grenade weapon to use<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The starting point of the grenade toss<LI>        <B>[MANDATORY]</B>  &lt;velocity&gt; The initial velocity vector for the grenade movement</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Creates a "Magic" grenade from a player.<BR><B>EXAMPLE:  </B>MagicGrenadePlayer( "sticky_grenade_mp", self.origin, toss_velocity )<BR></OL><P>
<HR><H1>entity MagicGrenadeType(<I>&lt;weaponName&gt;</I>,<I>&lt;sourceLoc&gt;</I>,<I>&lt;velocity&gt;</I>,<I>[time to blow]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weaponName&gt; The name of the weapon<LI>        <B>[MANDATORY]</B>  &lt;sourceLoc&gt; The grenade starting point<LI>        <B>[MANDATORY]</B>  &lt;velocity&gt; The velocity of the grenade<LI>        <B>[OPTIONAL]</B>  [time to blow] The grenade fuse time in seconds</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Fire a 'magic grenade', from the source location towards the destination point.<BR><B>EXAMPLE:  </B>ent MagicGrenadeType( "fraggrenade", self.origin, myVelocity )<BR></OL><P>
<HR><H1>entity &lt;attacker&gt; MagicMissile(<I>&lt;weapon&gt;</I>,<I>&lt;position&gt;</I>,<I>&lt;velocity&gt;</I>,<I>[targetent]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; - Weapon name.<LI>        <B>[MANDATORY]</B>  &lt;position&gt; - Position to launch from.<LI>        <B>[MANDATORY]</B>  &lt;velocity&gt; - Direction and force of launch.<LI>        <B>[OPTIONAL]</B>  [targetent] The target of the bullet</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Launches a weapon from the given position with the given velocity.  Velocity determines direction.<BR><B>EXAMPLE:  </B>bomb = player MagicMissile( "artillery_mp", (100,100,0), ( 0.1, 0.1, 0.1 ) )<BR></OL><P>
<HR><H1>void &lt;script_model&gt; MakeFakeAI()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Create a drone from script model, that can be moved around with simple commands<BR><B>EXAMPLE:  </B>guy MakeFakeAI()<BR></OL><P>
<HR><H1>void &lt;grenade&gt; MakeGrenadeDud()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Turns a grenade into a dud<BR><B>EXAMPLE:  </B>grenade MakeGrenadeDud()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; MakePathfinder()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Register a vehicle with Havok so it can do pathfinding and position query<BR></OL><P>
<HR><H1>void &lt;entity&gt; MakeSentient()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Turn a vehicle or script mover into a sentient.<BR><B>EXAMPLE:  </B>heli MakeSentient()<BR></OL><P>
<HR><H1>void &lt;turret&gt; MakeTurretUnusable()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets a turret to be unable to be used<BR><B>EXAMPLE:  </B>roof_turret MakeTurretUnusable()<BR></OL><P>
<HR><H1>void &lt;turret&gt; MakeTurretUsable()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets a turret able to be used<BR><B>EXAMPLE:  </B>roof_turret MakeTurretUsable()<BR></OL><P>
<HR><H1>void &lt;entity&gt; MakeUnusable()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets this entity to be not usable by the player<BR><B>EXAMPLE:  </B>mover MakeUsable()<BR></OL><P>
<HR><H1>void &lt;entity&gt; MakeUsable(<I>[team]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [team] The team that is allowed to use the object. Only for script movers.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets this entity to be usable by the player<BR><B>EXAMPLE:  </B>mover MakeUsable()<BR></OL><P>
<HR><H1>void Map(<I>&lt;map name&gt;</I>,<I>[save persistent]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;map name&gt; The map to load<LI>        <B>[OPTIONAL]</B>  [save persistent] if true then player info is retained</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Loads a new map<BR></OL><P>
<HR><H1>void Map_Restart(<I>[save persistent]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [save persistent] if true then player info is retained</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Restarts the map<BR><B>EXAMPLE:  </B>Map_Restart( true )<BR></OL><P>
<HR><H1>void MapExists(<I>&lt;map name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;map name&gt; The map to check.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the map with the given name exists on the server<BR></OL><P>
<HR><H1>void MapShaderConstant(<I>&lt;localClientNum&gt;</I>,<I>&lt;index&gt;</I>,<I>&lt;constant name&gt;</I>,<I>[x]</I>,<I>[y]</I>,<I>[z]</I>,<I>[w]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client for which to map the shader constant<LI>        <B>[MANDATORY]</B>  &lt;index&gt; the index you want this shader constant to map to<LI>        <B>[MANDATORY]</B>  &lt;constant name&gt; a string that's the name of the shader constant<LI>        <B>[OPTIONAL]</B>  [x] initial value of x component<LI>        <B>[OPTIONAL]</B>  [y] initial value of y component<LI>        <B>[OPTIONAL]</B>  [z] initial value of z component<LI>        <B>[OPTIONAL]</B>  [w] initial value of w component</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Maps a shader constant to an index. Returns 1 if success, 0 on failure<BR><B>EXAMPLE:  </B>ent mapshaderconstant( 0, "shaderColor" ); ent mapshaderconstant( 0, "shaderColor", 1, 0, 1, 1 )<BR></OL><P>
<HR><H1>void MarkAsDirty()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Marks the entity as dirty<BR><B>EXAMPLE:  </B>MarkAsDirty( entity )<BR></OL><P>
<HR><H1>void &lt;destructible&gt; MarkDestructibleDestroyed()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>set destructible destroyed<BR><B>EXAMPLE:  </B>barrel MarkDestructibleDestroyed()<BR></OL><P>
<HR><H1>void MarkNoVehicleNavMeshFaces()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Update the novehicle flag on navmesh faces. This should only be used in MP map for now.<BR></OL><P>
<HR><H1>void matchRecordOvertimeRound()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>call after matchRecordRoundStart to mark the round as an overtime round (only first overtimee round is actually recorded)<BR><B>EXAMPLE:  </B>matchRecordOvertimeRound()<BR></OL><P>
<HR><H1>void matchRecordRoundStart()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>need a hook for round starts, to get time stamps<BR><B>EXAMPLE:  </B>matchRecordRoundStart()<BR></OL><P>
<HR><H1>void Matrix4x4TransformPoints()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR></OL><P>
<HR><H1>void MaySpawnEntity()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR></OL><P>
<HR><H1>void MaySpawnFakeEntity()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR></OL><P>
<HR><H1>void MisdirectionEnable(<I>&lt;localClientNum&gt;</I>,<I>&lt;bool&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number.<LI>        <B>[MANDATORY]</B>  &lt;bool&gt; 0 disables display, 1 enables it.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Enables or disables misdirection display<BR><B>EXAMPLE:  </B>MisdirectionEnable( localclientnum, newVal )<BR></OL><P>
<HR><H1>void &lt;entity&gt; Missile_DroneSetVisible(<I>&lt;flag&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flag&gt; True to set visible, false otherwise</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the missile or drone to be visible<BR><B>EXAMPLE:  </B>self Missile_DroneSetVisible( true )<BR></OL><P>
<HR><H1>entity &lt;missile&gt; Missile_GetTarget()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the target of the missile to the given entity, and resets if no entity is specified.<BR><B>EXAMPLE:  </B>target = missile Missile_GetTarget()<BR></OL><P>
<HR><H1>void &lt;missile&gt; missile_settarget(<I>[target]</I>,<I>[targetOffset]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [target] The target of the missile<LI>        <B>[OPTIONAL]</B>  [targetOffset] Offset to the target location (vector3)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the target of the missile to the given entity, and resets if no entity is specified.<BR><B>EXAMPLE:  </B>self missile_settarget( player )<BR></OL><P>
<HR><H1>void MissionFailed()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Restarts the map<BR><B>EXAMPLE:  </B>MissionFailed()<BR></OL><P>
<HR><H1>void MissionHasAccolades(<I>[currentmap]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [currentmap] the name of the current map.  If ommitted, use Dvar sv_mapname</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns whether or not this mission has any accolades associated with it<BR><B>EXAMPLE:  </B>level.has_accolades = MissionHasAccolades( "cp_mi_cairo_ramses2" )<BR></OL><P>
<HR><H1>void MissionHasCollectibles(<I>[currentmap]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [currentmap] the name of the current map.  If ommitted, use Dvar sv_mapname</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns whether or not this mission has any collectibles in it<BR><B>EXAMPLE:  </B>level.has_collectibles = MissionHasCollectibles( "cp_mi_cairo_ramses2" )<BR></OL><P>
<HR><H1>void MissionRestart()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Restarts the mission, which might take you to a different BSP if this is a sublevel<BR><B>EXAMPLE:  </B>MissionRestart()<BR></OL><P>
<HR><H1>void &lt;script_model, script_origin or script_brushmodel&gt; MoveGravity(<I>&lt;initial velocity&gt;</I>,<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;initial velocity&gt; The initial velocity to fling this entity at<LI>        <B>[MANDATORY]</B>  &lt;time&gt; The time to move the entity in seconds</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Fling this entity.<BR><B>EXAMPLE:  </B>self MoveGravity( break_vector, time )<BR></OL><P>
<HR><H1>void &lt;script_model, script_origin or script_brushmodel&gt; MoveSlide(<I>&lt;center&gt;</I>,<I>&lt;radius&gt;</I>,<I>&lt;initial velocity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;center&gt; The center of the entity's collision with the ground<LI>        <B>[MANDATORY]</B>  &lt;radius&gt; The radius of the entity's collision with the ground<LI>        <B>[MANDATORY]</B>  &lt;initial velocity&gt; The initial velocity to move the entity at</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Launches the entity in the given velocity. When on the ground it will slide smoothly. Call StopMoveSlide to make it stop moving.<BR><B>EXAMPLE:  </B>self MoveSlide( 16, anglesToForward( self.angles ) * 10 )<BR></OL><P>
<HR><H1>void &lt;script_model, script_origin or script_brushmodel&gt; MoveTo(<I>&lt;point&gt;</I>,<I>&lt;time&gt;</I>,<I>[acceleration time]</I>,<I>[deceleration time]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;point&gt; The point to move the entity to<LI>        <B>[MANDATORY]</B>  &lt;time&gt; The time to move the entity in seconds<LI>        <B>[OPTIONAL]</B>  [acceleration time] The time spent accelerating<LI>        <B>[OPTIONAL]</B>  [deceleration time] The time spent decelerating</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Move this entity to the given point.<BR><B>EXAMPLE:  </B>dummy MoveTo( dest_org, .5, .05, .05 )<BR></OL><P>
<HR><H1>void &lt;script_model, script_origin or script_brushmodel&gt; MoveX(<I>&lt;point&gt;</I>,<I>&lt;time&gt;</I>,<I>[acceleration time]</I>,<I>[deceleration time]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;point&gt; The x value to move the entity to, as a floating point number<LI>        <B>[MANDATORY]</B>  &lt;time&gt; The time to move the entity in seconds<LI>        <B>[OPTIONAL]</B>  [acceleration time] The time spent accelerating in seconds<LI>        <B>[OPTIONAL]</B>  [deceleration time] The time spent decelerating in seconds</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Move this entity to the given world x value<BR><B>EXAMPLE:  </B>train MoveX( -4400, 60, 15, 20 )<BR></OL><P>
<HR><H1>void &lt;script_model, script_origin or script_brushmodel&gt; MoveY(<I>&lt;point&gt;</I>,<I>&lt;time&gt;</I>,<I>[acceleration time]</I>,<I>[deceleration time]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;point&gt; The y value to move the entity to, as a floating point number<LI>        <B>[MANDATORY]</B>  &lt;time&gt; The time to move the entity in seconds<LI>        <B>[OPTIONAL]</B>  [acceleration time] The time spent accelerating in seconds<LI>        <B>[OPTIONAL]</B>  [deceleration time] The time spent decelerating in seconds</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>move this entity to the given world y value<BR><B>EXAMPLE:  </B>hangardoor MoveY( 320, 10 )<BR></OL><P>
<HR><H1>void &lt;script_model, script_origin or script_brushmodel&gt; MoveZ(<I>&lt;point&gt;</I>,<I>&lt;time&gt;</I>,<I>[acceleration time]</I>,<I>[deceleration time]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;point&gt; The z value to move the entity to, as a floating point number<LI>        <B>[MANDATORY]</B>  &lt;time&gt; The time to move the entity in seconds<LI>        <B>[OPTIONAL]</B>  [acceleration time] The time spent accelerating in seconds<LI>        <B>[OPTIONAL]</B>  [deceleration time] The time spent decelerating in seconds</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Move this entity to the given world z value<BR></OL><P>
<HR><H1>void NavPointSightFilter(<I>&lt;points&gt;</I>,<I>&lt;origin&gt;</I>,<I>[checksight]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;points&gt; Array of navmesh points<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; Origin to check visibility from<LI>        <B>[OPTIONAL]</B>  [checksight] True to check sight, false otherwise</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Given an array of navmesh points, filters the array based on navmesh visibility to an origin.<BR><B>EXAMPLE:  </B>points = NavPointSightFilter( points, nearest )<BR></OL><P>
<HR><H1>void NeedsRevive(<I>&lt;bool&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;bool&gt; does player need to be reived</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Used for mini maps to display compass icon<BR><B>EXAMPLE:  </B>self NeedsRevive( true )<BR></OL><P>
<HR><H1>void NodesAreLinked(<I>&lt;node1&gt;</I>,<I>&lt;node2&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node1&gt; first node<LI>        <B>[MANDATORY]</B>  &lt;node2&gt; second node</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if node1 is connected to node2.<BR><B>EXAMPLE:  </B>NodesAreLinked( node_moving_elev_left, node_moving_elev_right )<BR></OL><P>
<HR><H1>void NodesVisible(<I>&lt;node1&gt;</I>,<I>&lt;node2&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node1&gt; pathnode to check<LI>        <B>[MANDATORY]</B>  &lt;node2&gt; pathnode to check against node1</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if these nodes are visible to one another, false otherwise.<BR><B>EXAMPLE:  </B>if ( NodesVisible( cover, guy.node ) )<BR></OL><P>
<HR><H1>void &lt;ent&gt; NotSolid()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Unsets the solid flag, so that this object is no longer collidable.<BR><B>EXAMPLE:  </B>self NotSolid()<BR></OL><P>
<HR><H1>void NumRemoteClients()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the number of remote clients connected to the game.  Very useful for scaling content for coop play, and network balancing.<BR><B>EXAMPLE:  </B>num_remote_clients = NumRemoteClients()<BR></OL><P>
<HR><H1>void Obituary(<I>&lt;victim&gt;</I>,<I>&lt;attacker&gt;</I>,<I>&lt;weapon&gt;</I>,<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;victim&gt; The victim entity<LI>        <B>[MANDATORY]</B>  &lt;attacker&gt; The attacker entity<LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon name<LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The means of death as a string</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Create an obituary for a character<BR><B>EXAMPLE:  </B>Obituary( self, attacker, sWeapon, sMeansOfDeath )<BR></OL><P>
<HR><H1>void Objective_Add(<I>&lt;objective_number&gt;</I>,<I>&lt;state&gt;</I>,<I>&lt;entity&gt;</I>,<I>[displayName]</I>,<I>[entity]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The number of the objective to add<LI>        <B>[MANDATORY]</B>  &lt;state&gt; A string value representing the state of the objective. Valid states are "empty", "active", "invisible", "done", "current" and "failed"<LI>        <B>[OPTIONAL]</B>  [position/onEntity] The position of the objective - or - &lt;entity&gt; entity to be tracked.<LI>        <B>[OPTIONAL]</B>  [displayName] The text to use for the objective. This should be a valid localized text reference<LI>        <B>[OPTIONAL]</B>  [entity] The owner entity</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Add a new objective, with ability to specify all the info for the objective<BR><B>EXAMPLE:  </B>Objective_Add( objective_number, "active", closest.bomb.origin, objective_text, self.objective )<BR></OL><P>
<HR><H1>void Objective_ClearAllUsing(<I>&lt;objective_number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears the objective of all players using status.<BR></OL><P>
<HR><H1>void Objective_ClearEntity(<I>&lt;objective_number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears the entity previous set on the objective<BR></OL><P>
<HR><H1>void Objective_ClearPlayerUsing(<I>&lt;objective_number&gt;</I>,<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter<LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player who is no longer using the objective</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the objective to be not being used by the specified player.<BR></OL><P>
<HR><H1>void Objective_Delete(<I>&lt;objective_number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Deletes the objective<BR><B>EXAMPLE:  </B>Objective_Delete( objective_number )<BR></OL><P>
<HR><H1>void Objective_FlipIcon(<I>&lt;localClientNum&gt;</I>,<I>&lt;objectiveID&gt;</I>,<I>[shouldFlipMaterial]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number<LI>        <B>[MANDATORY]</B>  &lt;objectiveID&gt; The index of objective<LI>        <B>[OPTIONAL]</B>  [shouldFlipMaterial] 1 if the material should be flipped, 0 otherwise</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Flips the icon of the objective<BR><B>EXAMPLE:  </B>Objective_FlipIcon( self.friendlyObjID )<BR></OL><P>
<HR><H1>void Objective_GetGamemodeFlags(<I>&lt;objective_index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_index&gt; The ID of the objective.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the gamemode flags for the objective.<BR><B>EXAMPLE:  </B>flags = Objective_GetGamemodeFlags( myObjNumber )<BR></OL><P>
<HR><H1>void Objective_Icon(<I>&lt;objective_number&gt;</I>,<I>&lt;icon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter<LI>        <B>[MANDATORY]</B>  &lt;icon&gt; The icon name</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the objective icon<BR><B>EXAMPLE:  </B>objective_icon( crateObjID, "compass_supply_drop_black" )<BR></OL><P>
<HR><H1>void Objective_OnEntity(<I>&lt;objective_number&gt;</I>,<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter<LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The entity to set the objective to</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the objective to get its position from an entity.<BR></OL><P>
<HR><H1>void Objective_Position(<I>&lt;objective_number&gt;</I>,<I>&lt;position&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter<LI>        <B>[MANDATORY]</B>  &lt;position&gt; The position to set</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the objective position<BR><B>EXAMPLE:  </B>objective_position( self.objectiveID, self.curOrigin )<BR></OL><P>
<HR><H1>void Objective_Set3D(<I>&lt;objective_number&gt;</I>,<I>&lt;use3D&gt;</I>,<I>[unused]</I>,<I>[unused]</I>,<I>[unused]</I>,<I>[unused]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter<LI>        <B>[MANDATORY]</B>  &lt;use3D&gt; true if should render in hud<LI>        <B>[OPTIONAL]</B>  [unused] not used<LI>        <B>[OPTIONAL]</B>  [unused] not used<LI>        <B>[OPTIONAL]</B>  [unused] not used<LI>        <B>[OPTIONAL]</B>  [unused] not used</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets flag determining if 3D state for an objective is drawn.<BR><B>EXAMPLE:  </B>Objective_Set3D( myObjNum, true, undefined, undefined, undefined, (0,0,70) )<BR></OL><P>
<HR><H1>void Objective_SetColor(<I>&lt;objective_index&gt;</I>,<I>&lt;r/colorName&gt;</I>,<I>[g]</I>,<I>[b]</I>,<I>[a]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_index&gt; The ID of the objective.<LI>        <B>[MANDATORY]</B>  &lt;r/colorName&gt; Red float value for objective, or color name set from the UIEditor as an IString.<LI>        <B>[OPTIONAL]</B>  [g] Green float value for objective.<LI>        <B>[OPTIONAL]</B>  [b] Blue float value for objective.<LI>        <B>[OPTIONAL]</B>  [a] Alpha float value for objective. Default of 1.0 if not specified.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets a color for the objective that the icon will then be drawn with.<BR><B>EXAMPLE:  </B>Objective_SetColor( myObjNumber, 1.0, 0.0, 0.0, 1.0 )Objective_SetColor( myObjNumber, "FriendlyBlue" )<BR></OL><P>
<HR><H1>void Objective_SetFlag(<I>&lt;objective_index&gt;</I>,<I>&lt;flag&gt;</I>,<I>&lt;true/false&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_index&gt; The ID of the objective to alter<LI>        <B>[MANDATORY]</B>  &lt;flag&gt; - active, fadeoutonscreen, perk, drawdistance, drawname, in3d, clipToMap, primary<LI>        <B>[MANDATORY]</B>  &lt;true/false&gt; turn the flag on or off</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the gamemode flags for the objective.<BR><B>EXAMPLE:  </B>Objective_SetFlag( myObjNumber, "active", true )<BR></OL><P>
<HR><H1>void Objective_SetGamemodeFlags(<I>&lt;objective_index&gt;</I>,<I>&lt;flags&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_index&gt; The ID of the objective.<LI>        <B>[MANDATORY]</B>  &lt;flags&gt; script managed flags.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the gamemode flags for the objective.  This function only works for modes not using 3d objectives (mp).<BR><B>EXAMPLE:  </B>Objective_SetGamemodeFlags( myObjNumber, 0 )<BR></OL><P>
<HR><H1>void Objective_SetIcon(<I>&lt;localClientNum&gt;</I>,<I>&lt;objectiveNumber&gt;</I>,<I>&lt;materialName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client that is using the objective<LI>        <B>[MANDATORY]</B>  &lt;objectiveNumber&gt; The ID of the objective to alter<LI>        <B>[MANDATORY]</B>  &lt;materialName&gt; The material to set</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the icon for the objective<BR><B>EXAMPLE:  </B>Objective_SetIcon( localClientNum, clientObjID, "remotemissile_target" )<BR></OL><P>
<HR><H1>void Objective_SetIconSize(<I>&lt;localClientNum&gt;</I>,<I>&lt;objective_number&gt;</I>,<I>&lt;scale&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client that is using the objective<LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter<LI>        <B>[MANDATORY]</B>  &lt;scale&gt; The value to scale the objective icon</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the objective's scale for the icon.<BR><B>EXAMPLE:  </B>objective_SetIconSize( localClientNum, clientObjID, 50 )<BR></OL><P>
<HR><H1>void Objective_SetInvisibleToAll(<I>&lt;objective_number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the objective to be invisible to all players.<BR></OL><P>
<HR><H1>void Objective_SetInvisibleToPlayer(<I>&lt;objective_number&gt;</I>,<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter<LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player to whom the objective is now invisible</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the objective to be invisible to the specified player.<BR></OL><P>
<HR><H1>void Objective_SetInvisibleToPlayerByIndex(<I>&lt;objective_number&gt;</I>,<I>&lt;entnum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter<LI>        <B>[MANDATORY]</B>  &lt;entnum&gt; The entity number of the player to whom the objective is now invisible</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the objective to be invisible to the specified player.<BR></OL><P>
<HR><H1>void Objective_SetPlayerUsing(<I>&lt;objective_number&gt;</I>,<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter<LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player who is using the objective</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the objective to being used by the specified player.<BR></OL><P>
<HR><H1>void Objective_SetProgress(<I>&lt;objective_index&gt;</I>,<I>&lt;percent&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_index&gt; The ID of the objective.<LI>        <B>[MANDATORY]</B>  &lt;percent&gt; percent float value for objective [0-1].</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the progress for the objective.<BR><B>EXAMPLE:  </B>Objective_SetProgress( myObjNumber, 0.5 )<BR></OL><P>
<HR><H1>void Objective_SetSize(<I>&lt;objective_index&gt;</I>,<I>&lt;entity/float&gt;</I>,<I>[float]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_index&gt; The ID of the objective.<LI>        <B>[MANDATORY]</B>  &lt;entity/float&gt; The entity to get the size from or a sizeX.<LI>        <B>[OPTIONAL]</B>  [float] If sizeX was used in prvious arg, this is sizeY.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets a size for the objective that the icon will then be drawn at. Min is MIN_OBJECTIVE_ICON_SIZE = 5<BR><B>EXAMPLE:  </B>Objective_SetSize( myObjNumber, myTrigger )Objective_SetSize( myObjNumber, 20, 30 )<BR></OL><P>
<HR><H1>void Objective_SetStencil(<I>&lt;localClientNum&gt;</I>,<I>&lt;objective_number&gt;</I>,<I>&lt;stencil&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client that is using the objective<LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter<LI>        <B>[MANDATORY]</B>  &lt;stencil&gt; Set to true if you want the objective to stencil</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the objective's stencil for the icon.<BR><B>EXAMPLE:  </B>Objective_SetStencil( localClientNum, clientObjID, true )<BR></OL><P>
<HR><H1>void Objective_SetUIModelValue(<I>&lt;objective_number&gt;</I>,<I>&lt;lui menu data name&gt;</I>,<I>&lt;lui menu data value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter<LI>        <B>[MANDATORY]</B>  &lt;lui menu data name&gt; precached name string for the data which we're trying to set.<LI>        <B>[MANDATORY]</B>  &lt;lui menu data value&gt; value for the data which we're trying to set on the objective.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set a UI Model Value for an objective<BR><B>EXAMPLE:  </B>Objective_SetUIModelValue( 0, "killedCount", 4 ); or Objective_SetUIModelValue( 0, "killedCount", "Four" )<BR></OL><P>
<HR><H1>void Objective_SetVisibleToAll(<I>&lt;objective_number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the objective to be visible to all players.<BR></OL><P>
<HR><H1>void Objective_SetVisibleToPlayer(<I>&lt;objective_number&gt;</I>,<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter<LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player to whom the objective is now visible</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the objective to be visible to the specified player.<BR></OL><P>
<HR><H1>void Objective_SetVisibleToPlayerByIndex(<I>&lt;objective_number&gt;</I>,<I>&lt;entnum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter<LI>        <B>[MANDATORY]</B>  &lt;entnum&gt; The entity number of the player to whom the objective is now visible</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the objective to be visible to the specified player.<BR></OL><P>
<HR><H1>void Objective_State(<I>&lt;objective_number&gt;</I>,<I>&lt;state&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter<LI>        <B>[MANDATORY]</B>  &lt;state&gt; The state to set</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set a state for the objective<BR><B>EXAMPLE:  </B>Objective_State( obj_id, "active" )<BR></OL><P>
<HR><H1>void Objective_Team(<I>&lt;objective_number&gt;</I>,<I>&lt;team&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter<LI>        <B>[MANDATORY]</B>  &lt;team&gt; The team that the objective is for. Valid entries are 'allies', 'axis', 'team3', or 'none'</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the team that the objective is for. Allows having different objectives for each team<BR><B>EXAMPLE:  </B>Objective_Team( 0, "allies" )<BR></OL><P>
<HR><H1>void Objective_VisibleTeams(<I>&lt;objective_number&gt;</I>,<I>&lt;team&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_number&gt; The ID of the objective to alter<LI>        <B>[MANDATORY]</B>  &lt;team&gt; The team that the objective is for. Valid entries are 'allies', 'axis', 'team3', or 'none'</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the team that the objective is visible too for. Allows having different objectives for each team<BR><B>EXAMPLE:  </B>Objective_VisibleTeams( 0, 01101101 )<BR></OL><P>
<HR><H1>void &lt;player&gt; OffhandWeaponsEnabled()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Determine if offhand weapons are enabled for the player<BR><B>EXAMPLE:  </B>enabled = player OffhandWeaponsEnabled()<BR></OL><P>
<HR><H1>void &lt;entity&gt; OverrideLightingOrigin()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Uses the entity origin as the lighting origin instead of the center of the entity's bounding area<BR><B>EXAMPLE:  </B>door OverrideLightingOrigin()<BR></OL><P>
<HR><H1>void &lt;entity&gt; OverrideSpawnflags()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the spawnflags on this entity.  Used for patching.<BR><B>EXAMPLE:  </B>entity OverrideSpawnflags( 64 )<BR></OL><P>
<HR><H1>void PathDistance(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>,<I>&lt;generatePathForAccurateDist&gt;</I>,<I>&lt;pathEnt&gt;</I>,<I>&lt;pathDistanceType&gt;</I>,<I>&lt;maxCornerPredictions&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt;.<LI>        <B>[MANDATORY]</B>  &lt;end&gt;.<LI>        <B>[OPTIONAL]</B>  &lt;generatePathForAccurateDist&gt; If set to true, a real path will be generated and the total length of the path segments will be returned.<LI>        <B>[OPTIONAL]</B>  &lt;pathEnt&gt; Only used when generatePathForAccurateDist is set. pathEnt will be used for generating a path, so it will respect the movement type. Only supported for actors.<LI>        <B>[OPTIONAL]</B>  &lt;pathDistanceType&gt; The method of pathdistance calculation. Two options are PATHDIST_APPROXIMATE(using getApproximateFuturePositions), PATHDIST_CORNERPREDICTED (using getCornerPredictor).<LI>        <B>[OPTIONAL]</B>  &lt;maxCornerPredictions&gt; Maximum number of cornerPrediction steps when PATHDIST_CORNERPREDICTED is used. Handles the edge case when cornerPrediction may not ever finish stepping the path all the way.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the approximate/semi-accurate path distance between two points or undefined if no path can be found.<BR></OL><P>
<HR><H1>void PhysicsExplosionCylinder(<I>&lt;position&gt;</I>,<I>&lt;outer radius&gt;</I>,<I>&lt;inner radius&gt;</I>,<I>&lt;magnitude&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; The origin of the cylinder<LI>        <B>[MANDATORY]</B>  &lt;outer radius&gt; The outer radius of the cylinder<LI>        <B>[MANDATORY]</B>  &lt;inner radius&gt; The inner radius of the cylinder<LI>        <B>[MANDATORY]</B>  &lt;magnitude&gt; The magnitude of the explosion</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Created a physics explosion cylinder<BR><B>EXAMPLE:  </B>PhysicsExplosionCylinder( self.origin, 600, 240, 1 )<BR></OL><P>
<HR><H1>void PhysicsExplosionSphere(<I>&lt;position&gt;</I>,<I>&lt;outer radius&gt;</I>,<I>&lt;inner radius&gt;</I>,<I>&lt;magnitude&gt;</I>,<I>[outer damage]</I>,<I>[inner damage]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; The origin of the sphere<LI>        <B>[MANDATORY]</B>  &lt;outer radius&gt; The outer radius of the sphere<LI>        <B>[MANDATORY]</B>  &lt;inner radius&gt; The inner radius of the sphere<LI>        <B>[MANDATORY]</B>  &lt;magnitude&gt; The magnitude of the explosion<LI>        <B>[OPTIONAL]</B>  [outer damage] The optional outer damage<LI>        <B>[OPTIONAL]</B>  [inner damage] The optional inner damage</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Create a physics explosion sphere<BR><B>EXAMPLE:  </B>PhysicsExplosionSphere( origin, radius, radius, 5, max_damage, min_damage )<BR></OL><P>
<HR><H1>void PhysicsJetThrust(<I>&lt;origin&gt;</I>,<I>&lt;weapon facing dir&gt;</I>,<I>&lt;radius&gt;</I>,<I>&lt;magnitude&gt;</I>,<I>&lt;angle limit&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; origin of the thrust<LI>        <B>[MANDATORY]</B>  &lt;weapon facing dir&gt; The weapon facing direction<LI>        <B>[MANDATORY]</B>  &lt;radius&gt; The radius of the thrust<LI>        <B>[MANDATORY]</B>  &lt;magnitude&gt; The magnitude of the thrust<LI>        <B>[MANDATORY]</B>  &lt;angle limit&gt; The angle limit for the thrust</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Creates a physics jet thrust<BR><B>EXAMPLE:  </B>PhysicsJetThrust( self.origin, (0,0,1), 400, 1, 60)<BR></OL><P>
<HR><H1>void PhysicsJolt(<I>&lt;position&gt;</I>,<I>&lt;outer radius&gt;</I>,<I>&lt;inner radius&gt;</I>,<I>&lt;impulse&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; The origin of the jolt<LI>        <B>[MANDATORY]</B>  &lt;outer radius&gt; The outer radius of the jolt<LI>        <B>[MANDATORY]</B>  &lt;inner radius&gt; The inner radius of the jolt<LI>        <B>[MANDATORY]</B>  &lt;impulse&gt; The impulse created by the explosion</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Create a physics radius jolt<BR><B>EXAMPLE:  </B>PhysicsJolt( self.origin, 600, 240, 1 )<BR></OL><P>
<HR><H1>void &lt;script_model&gt; PhysicsLaunch(<I>[contact_point]</I>,<I>[initial_force]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [contact_point] The point to apply the initial force<LI>        <B>[OPTIONAL]</B>  [initial_force] The force vector to apply</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Permanently turn this entity into a physics object with an intial force vector at the specified point.<BR><B>EXAMPLE:  </B>dummy PhysicsLaunch( contact_point, initial_force )<BR></OL><P>
<HR><H1>entity PhysicsTrace(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>,<I>[mins]</I>,<I>[maxs]</I>,<I>[ignore entity]</I>,<I>[mask type]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt; starting position<LI>        <B>[MANDATORY]</B>  &lt;end&gt; ending position<LI>        <B>[OPTIONAL]</B>  [mins] minimum bounds<LI>        <B>[OPTIONAL]</B>  [maxs] maximum bounds<LI>        <B>[OPTIONAL]</B>  [ignore entity] the entity to not consider<LI>        <B>[OPTIONAL]</B>  [mask type] the trace modifier</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Does a physics trace from start to end. Returns hit position<BR><B>EXAMPLE:  </B>trace = PhysicsTrace( start, end, ( 0, 0, 0 ), ( 0, 0, 0 ), self, PHYSICS_TRACE_MASK_VEHICLE_CLIP )<BR></OL><P>
<HR><H1>entity PhysicsTraceEx(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>,<I>[mins]</I>,<I>[maxs]</I>,<I>[entity]</I>,<I>[player clip]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt; The start point<LI>        <B>[MANDATORY]</B>  &lt;end&gt; The end point<LI>        <B>[OPTIONAL]</B>  [mins] trace capsule min<LI>        <B>[OPTIONAL]</B>  [maxs] trace capsule max<LI>        <B>[OPTIONAL]</B>  [entity] entity to ignore<LI>        <B>[OPTIONAL]</B>  [player clip] collide with the player solid mask instead of ai solid mask</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Physics trace, ignoring characters. Returns the full trace structure.<BR><B>EXAMPLE:  </B>trace = PhysicsTraceEx( start, end, (-10,-10,0), (10,10,0) )<BR></OL><P>
<HR><H1>void &lt;spawn point&gt; PlaceSpawnPoint()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Raises the spawn point up to make sure it's not in the ground, then drops it back down into the ground.<BR><B>EXAMPLE:  </B>spawnpoints[i] PlaceSpawnPoint()<BR></OL><P>
<HR><H1>void &lt;entity&gt; PlayBattleChatterToTeam(<I>&lt;aliasname1&gt;</I>,<I>&lt;aliasname2&gt;</I>,<I>&lt;teamname&gt;</I>,<I>[ignoreplayer]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;aliasname1&gt; The first sound alias to play<LI>        <B>[MANDATORY]</B>  &lt;aliasname2&gt; The second sound alias to play<LI>        <B>[MANDATORY]</B>  &lt;teamname&gt; The team that will be able to hear the sound. Must be either 'axis' or 'allies' or 'team3'.<LI>        <B>[OPTIONAL]</B>  [ignoreplayer] If present, this player will not hear the sound.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Play the sound alias as if coming from the entity, so that only one team can hear it<BR><B>EXAMPLE:  </B>self PlaySoundToTeam( "frag_out", "axis", self )<BR></OL><P>
<HR><H1>entity PlayerBeingSpectated(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Number of the local client to check</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the player the local client is spectating or the player himself if no spectating is going on<BR><B>EXAMPLE:  </B>spectated = PlayerBeingSpectated( localClientNum )<BR></OL><P>
<HR><H1>entity PlayerBulletTrace(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>,<I>&lt;ignore entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt; The bullet start point<LI>        <B>[MANDATORY]</B>  &lt;end&gt; The bullet end point<LI>        <B>[MANDATORY]</B>  &lt;ignore entity&gt; An entity to ignore</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Allows script to do a bullet point trace with CONTENTS_PLAYER, collides with player hitboxes. Returns hit position, hit entity, hit surface normal.<BR><B>EXAMPLE:  </B>trace = PlayerBulletTrace( magicBulletOrigin.origin, eyePos, undefined )<BR></OL><P>
<HR><H1>void &lt;player&gt; PlayerCamLinkTo(<I>&lt;entity&gt;</I>,<I>&lt;tagname&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; Entity to look through.<LI>        <B>[MANDATORY]</B>  &lt;tagname&gt; Name of tag on host model to attach to.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the player's vision to look through another entity.<BR><B>EXAMPLE:  </B>level.player2 CameraLinkTo( cameraUpstairs, "tag_player" )<BR></OL><P>
<HR><H1>void &lt;player&gt; PlayerCamUnlink()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Unlinks the player's vision from an entity.<BR><B>EXAMPLE:  </B>level.player2 CameraUnlink( )<BR></OL><P>
<HR><H1>void PlayerGrappleTrace(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>,<I>[ignore entity]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt; starting position<LI>        <B>[MANDATORY]</B>  &lt;end&gt; ending position<LI>        <B>[OPTIONAL]</B>  [ignore entity] this entity should be ignored</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Trace to see if grapple is valid<BR><B>EXAMPLE:  </B>hitp = PlayerGrappleTrace(player.origin, player.origin + (0,0,-500))<BR></OL><P>
<HR><H1>void &lt;linked_player&gt; PlayerLinkedOffsetDisable()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>If disabled, the linked player's orientation will not use their link offset.<BR><B>EXAMPLE:  </B>ac130guy PlayerLinkedOffsetDisable()<BR></OL><P>
<HR><H1>void &lt;linked_player&gt; PlayerLinkedOffsetEnable()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>If enabled, the linked player's orientation will use their link offset. This is traditional (CoD4) LinkTo behavior for a player.<BR><B>EXAMPLE:  </B>ac130guy PlayerLinkedOffsetEnable()<BR></OL><P>
<HR><H1>void &lt;linked_player&gt; PlayerLinkedSetUseBaseAngleForViewClamp(<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;enable&gt; whether or not to enable using the base entity for the view angle clamp base.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the whether the player's view clamp is based on the entity (true) or the tag selected (false). Must be called after linking using WeaponViewToDelta<BR><B>EXAMPLE:  </B>player PlayerLinkedSetUseBaseAngleForViewClamp( true )<BR><B>NOTES:  </B>A Linked Player Entity using WeaponViewToDelta<BR></OL><P>
<HR><H1>void &lt;player&gt; PlayerLinkTo(<I>&lt;linkto entity&gt;</I>,<I>[tag]</I>,<I>[view fraction]</I>,<I>[right arc]</I>,<I>[left arc]</I>,<I>[top arc]</I>,<I>[bottom arc]</I>,<I>[use tag angles]</I>,<I>[auto recenter]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;linkto entity&gt; The entity to attach the player to.<LI>        <B>[OPTIONAL]</B>  [tag] The tag to attach the player to.<LI>        <B>[OPTIONAL]</B>  [view fraction] How much the change in the tag's rotation effects the players view. Defaults to 0.<LI>        <B>[OPTIONAL]</B>  [right arc] Angle to clamp view to the right. Defaults to 180.<LI>        <B>[OPTIONAL]</B>  [left arc] Angle to clamp view to the left. Defaults to 180.<LI>        <B>[OPTIONAL]</B>  [top arc] Angle to clamp view to the top. Defaults to 180.<LI>        <B>[OPTIONAL]</B>  [bottom arc] Angle to clamp view to the bottom. Defaults to 180.<LI>        <B>[OPTIONAL]</B>  [use tag angles] Determines how the player's view will be tilted. 'False' (default) means that the orientation of the tag when the player is linked will appear flat to the player. Any rotation from that orientation will tilt the player's view. 'True' means that only a tag angles of (0,0,0) will appear flat to the player. Any rotation from (0,0,0) will tilt the player's view.<LI>        <B>[OPTIONAL]</B>  [auto recenter] Players view will auto recenter to the tag he is linked to. use tag angles must be true.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Attaches the player to an entity. Any entity rotation is added to the player's view, allow the player to look around. Rotating the parent entity/tag will not move the player's eye position, but only the player's view angles. Thus, the player's eye position is locked in place, always directly above the parent tag.<BR><B>EXAMPLE:  </B>level.player PlayerLinkTo( vehicle, "tag_player", 0.5 )<BR></OL><P>
<HR><H1>void &lt;player&gt; PlayerLinkToAbsolute(<I>&lt;lockto entity&gt;</I>,<I>[tag]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;lockto entity&gt; The entity to attach the player to<LI>        <B>[OPTIONAL]</B>  [tag] The tag to attach the player to</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Attaches the player to an entity. No view movement is allowed.  The player's eye position will remain fixed relative to the parent entity/tag. Thus, pitching and rolling will cause the player's eye position to move. (But the player entity always remains vertical)<BR><B>EXAMPLE:  </B>player PlayerLinkToAbsolute( vehicle, "tag_player" )<BR></OL><P>
<HR><H1>void &lt;player&gt; PlayerLinkToBlend(<I>&lt;parent&gt;</I>,<I>[tag]</I>,<I>[pos time]</I>,<I>[pos accel time]</I>,<I>[pos decel time]</I>,<I>&lt;time&gt;</I>,<I>[angle accel time]</I>,<I>[angle decel time]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;parent&gt; The entity to attach the player to.<LI>        <B>[OPTIONAL]</B>  [tag] The tag to attach the player to.<LI>        <B>[OPTIONAL]</B>  [pos time] Lerp duration in seconds. Default is 1.<LI>        <B>[OPTIONAL]</B>  [pos accel time] Acceleration time. Default is 0.<LI>        <B>[OPTIONAL]</B>  [pos decel time] Decelaration time. Default is 0.<LI>        <B>[OPTIONAL]</B>  [angle time] angle Lerp duration in seconds. Default is &lt;time&gt;.<LI>        <B>[OPTIONAL]</B>  [angle accel time] angle Acceleration time. Default is 0.<LI>        <B>[OPTIONAL]</B>  [angle decel time] angle Decelaration time. Default is 0.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Only works if the player is currently linked to another entity and angles aren't locked. Lerps the current view angle constraints to the provided ones over the specified time.<BR><B>EXAMPLE:  </B>player PlayerLinkToBlend( ice_pick, "tag_origin<BR></OL><P>
<HR><H1>void &lt;player&gt; PlayerLinkToDelta(<I>&lt;linkto entity&gt;</I>,<I>[tag]</I>,<I>[view fraction]</I>,<I>[right arc]</I>,<I>[left arc]</I>,<I>[top arc]</I>,<I>[bottom arc]</I>,<I>[use tag angles]</I>,<I>[auto recenter]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;linkto entity&gt; The entity to attach the player to.<LI>        <B>[OPTIONAL]</B>  [tag] The tag to attach the player to.<LI>        <B>[OPTIONAL]</B>  [view fraction] How much the change in the tag's rotation effects the players view. Defaults to 0.<LI>        <B>[OPTIONAL]</B>  [right arc] Angle to clamp view to the right. Defaults to 180.<LI>        <B>[OPTIONAL]</B>  [left arc] Angle to clamp view to the left. Defaults to 180.<LI>        <B>[OPTIONAL]</B>  [top arc] Angle to clamp view to the top. Defaults to 180.<LI>        <B>[OPTIONAL]</B>  [bottom arc] Angle to clamp view to the bottom. Defaults to 180.<LI>        <B>[OPTIONAL]</B>  [use tag angles] Determines how the player's view will be tilted. 'False' (default) means that the orientation of the tag when the player is linked will appear flat to the player. Any rotation from that orientation will tilt the player's view. 'True' means that only a tag angles of (0,0,0) will appear flat to the player. Any rotation from (0,0,0) will tilt the player's view.<LI>        <B>[OPTIONAL]</B>  [auto recenter] Players view will auto recenter to the tag he is linked to. use tag angles must be true.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Attaches the player to an entity. Any entity rotation is added to the player's view, allow the player to look around. The player's eye position will remain fixed relative to the parent entity/tag. Thus, pitching and rolling will cause the player's eye position to move. (But the player entity always remains vertical)<BR><B>EXAMPLE:  </B>level.player PlayerLinkToDelta( vehicle, "tag_player", 0.5 )<BR></OL><P>
<HR><H1>void &lt;player&gt; PlayerLinkWeaponViewToDelta(<I>&lt;linkto entity&gt;</I>,<I>[tag]</I>,<I>[view fraction]</I>,<I>[right arc]</I>,<I>[left arc]</I>,<I>[top arc]</I>,<I>[bottom arc]</I>,<I>[use tag angles]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;linkto entity&gt; The entity to attach the player to.<LI>        <B>[OPTIONAL]</B>  [tag] The tag to attach the player to.<LI>        <B>[OPTIONAL]</B>  [view fraction] How much the change in the tag's rotation effects the players view. Defaults to 0.<LI>        <B>[OPTIONAL]</B>  [right arc] Angle to clamp view to the right. Defaults to 180.<LI>        <B>[OPTIONAL]</B>  [left arc] Angle to clamp view to the left. Defaults to 180.<LI>        <B>[OPTIONAL]</B>  [top arc] Angle to clamp view to the top. Defaults to 180.<LI>        <B>[OPTIONAL]</B>  [bottom arc] Angle to clamp view to the bottom. Defaults to 180.<LI>        <B>[OPTIONAL]</B>  [use tag angles] Determines how the player's view will be tilted. 'False' (default) means that the orientation of the tag when the player is linked will appear flat to the player. Any rotation from that orientation will tilt the player's view. 'True' means that only a tag angles of (0,0,0) will appear flat to the player. Any rotation from (0,0,0) will tilt the player's view.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Similar to PlayerLinkToDelta(), but the player's body stays behind. The player's view attaches to the tag, and any weapon fire will also come from there.<BR><B>EXAMPLE:  </B>level.player PlayerLinkToDelta( vehicle, "tag_player", 0.5 )<BR></OL><P>
<HR><H1>void PlayerPhysicsTrace(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt; starting position<LI>        <B>[MANDATORY]</B>  &lt;end&gt; ending position</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Does a physics trace and returns the hit point.<BR><B>EXAMPLE:  </B>hitp = PlayerPhysicsTrace(player.origin + (0,0,72), player.origin + (0,0,-500))<BR></OL><P>
<HR><H1>void PlayerPhysicsTraceIgnoreEnt(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt; starting position<LI>        <B>[MANDATORY]</B>  &lt;end&gt; ending position</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Does a physics trace and returns the hit point.<BR><B>EXAMPLE:  </B>hitp = PlayerPhysicsTraceIgnoreEnt(player.origin + (0,0,72), player.origin + (0,0,-500))<BR></OL><P>
<HR><H1>void PlayerPositionValid(<I>&lt;position&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; The position of the potential spawn point</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the passed in origin is valid for a spawn (ie not inside something).<BR><B>EXAMPLE:  </B>if(playerpositionvalid(spawnpoints[i].origin))...<BR></OL><P>
<HR><H1>void PlayerPositionValidIgnoreEnt(<I>&lt;position&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; The position of the potential spawn point</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the passed in origin is valid for a spawn (ie not inside something).<BR><B>EXAMPLE:  </B>if(PlayerPositionValidIgnoreEnt(spawnpoints[i].origin))...<BR></OL><P>
<HR><H1>void &lt;player&gt; PlayerSetGroundReferenceEnt(<I>&lt;ground reference entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;ground reference entity&gt; The entity used to rotate the player's view.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>The ground entity's rotation will be added onto the player's view.  In particular, this will cause the player's yaw to rotate around the entity's z-axis instead of the world z-axis.  You only need to call this function once.  After that, any rotation that the reference entity undergoes will affect the player.  Call this command again with undefined to turn it off.<BR><B>EXAMPLE:  </B>player PlayerSetGroundReferenceEnt( seaEnt )<BR></OL><P>
<HR><H1>void PlayerSightTrace(<I>&lt;position&gt;</I>,<I>&lt;maxDistance&gt;</I>,<I>&lt;hitNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; place that check if you can see if being performed<LI>        <B>[MANDATORY]</B>  &lt;maxDistance&gt; if the position is further than this -1 will be returned<LI>        <B>[MANDATORY]</B>  &lt;hitNum&gt; if you run this more than once make sure to populate this with the return of the last as it will increase efficiency</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Determines if you can see an item.  Checks distance and view cone before the trace to increase efficency.<BR><B>EXAMPLE:  </B>if (0 == (self Playersighttrace(positionOfFlare, 200, lastHit))<BR></OL><P>
<HR><H1>entity PlayFX(<I>&lt;fx name&gt;</I>,<I>&lt;position&gt;</I>,<I>[forward]</I>,<I>[up]</I>,<I>[ignore pause]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;fx name&gt; Name of the fx. Fx has to be cached<LI>        <B>[MANDATORY]</B>  &lt;position&gt; Position to play the fx at<LI>        <B>[OPTIONAL]</B>  [forward] The forward vector of the fx<LI>        <B>[OPTIONAL]</B>  [up] The up vector of the fx<LI>        <B>[OPTIONAL]</B>  [ignore pause] True if the fx should play even when the game is paused.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Plays the fx at the given location.<BR><B>EXAMPLE:  </B>PlayFX( level._effect["nuke_fx"], nuke_pos.origin, forward, up )<BR></OL><P>
<HR><H1>entity PlayFXOnCamera(<I>&lt;fx name&gt;</I>,<I>[offset]</I>,<I>[forward]</I>,<I>[up]</I>,<I>[ignore pause]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;fx name&gt; Name of the fx. Fx has to be cached<LI>        <B>[OPTIONAL]</B>  [offset] Offset from camera to play fx<LI>        <B>[OPTIONAL]</B>  [forward] The forward vector of the fx<LI>        <B>[OPTIONAL]</B>  [up] The up vector of the fx<LI>        <B>[OPTIONAL]</B>  [ignore pause] True if the fx should play even when the game is paused.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Plays the fx at the given offset from the camera.<BR><B>EXAMPLE:  </B>PlayFX( level._effect["bubbles"], offset, forward, up )<BR></OL><P>
<HR><H1>entity PlayFXOnTag(<I>&lt;fx name&gt;</I>,<I>&lt;entity&gt;</I>,<I>&lt;tag&gt;</I>,<I>[ignore pause]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;fx name&gt; Name of the fx. Fx has to be cached<LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The entity to play the fx on. Should have a model<LI>        <B>[MANDATORY]</B>  &lt;tag&gt; The tag to play the fx on<LI>        <B>[OPTIONAL]</B>  [ignore pause] True if the fx should play even when the game is paused.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Play fx on a particular tag of an entity<BR><B>EXAMPLE:  </B>PlayFxOnTag( level._effect["character_fire_death_torso"], self, "J_Spine1" )<BR></OL><P>
<HR><H1>entity PlayLoopedFX(<I>&lt;fx name&gt;</I>,<I>&lt;repeat&gt;</I>,<I>&lt;position&gt;</I>,<I>[cull distance]</I>,<I>[forward]</I>,<I>[up]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;fx name&gt; Name of the fx. Fx has to be cached<LI>        <B>[MANDATORY]</B>  &lt;repeat&gt; Time to repeat after<LI>        <B>[MANDATORY]</B>  &lt;position&gt; Position to play the fx at<LI>        <B>[OPTIONAL]</B>  [cull distance] The cull distance for the fx<LI>        <B>[OPTIONAL]</B>  [forward] The forward vector of the fx<LI>        <B>[OPTIONAL]</B>  [up] The up vector of the fx</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Play an fx which is looped<BR><B>EXAMPLE:  </B>PlayLoopedFX( level._effect[self.v["trailfx"]], self.v["trailfxdelay"], self.v["origin"], 0, self.v["forward"], self.v["up"] )<BR></OL><P>
<HR><H1>void &lt;entity&gt; PlayLoopSound(<I>&lt;aliasname&gt;</I>,<I>[fadetime]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;aliasname&gt; The sound alias to play<LI>        <B>[OPTIONAL]</B>  [fadetime] Time to fade the sound in. Range is between 1 and 31 inclusive.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Play a looping sound with an optional fadetime in seconds.<BR><B>EXAMPLE:  </B>fire_sound_ent playloopsound ("mpl_player_burn_loop")<BR></OL><P>
<HR><H1>void &lt;entity&gt; PlayRumbleLoopOnEntity(<I>&lt;rumble name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;rumble name&gt; The name of the rumble to play</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Plays a looping rumble on the given entity.<BR><B>EXAMPLE:  </B>self PlayRumbleLoopOnEntity( "damage_heavy" )<BR></OL><P>
<HR><H1>void PlayRumbleLoopOnPosition(<I>&lt;rumblename&gt;</I>,<I>&lt;position&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;rumblename&gt; The rumble name<LI>        <B>[MANDATORY]</B>  &lt;position&gt; The rumble position</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Play a looping rumble on the given position<BR><B>EXAMPLE:  </B>PlayRumbleLoopOnPosition( "grenade_rumble", origin )<BR></OL><P>
<HR><H1>void &lt;entity&gt; PlayRumbleOnEntity(<I>&lt;rumble name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;rumble name&gt; The name of the rumble to play</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Plays a rumble on the given entity.<BR><B>EXAMPLE:  </B>self PlayRumbleOnEntity( "damage_heavy" )<BR></OL><P>
<HR><H1>void PlayRumbleOnPosition(<I>&lt;rumblename&gt;</I>,<I>&lt;position&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;rumblename&gt; The rumble name<LI>        <B>[MANDATORY]</B>  &lt;position&gt; The rumble position</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Play a rumble on the given position<BR><B>EXAMPLE:  </B>PlayRumbleOnPosition( "grenade_rumble", origin )<BR></OL><P>
<HR><H1>void &lt;entity&gt; PlaySound(<I>&lt;aliasname&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;aliasname&gt; The sound alias to play</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Play the sound at the entity<BR><B>EXAMPLE:  </B>bomb PlaySound( "zmb_bomb_explode" )<BR></OL><P>
<HR><H1>void PlaySoundAtPosition(<I>&lt;aliasname&gt;</I>,<I>&lt;position&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;aliasname&gt; The sound alias to play<LI>        <B>[MANDATORY]</B>  &lt;position&gt; The point where the sound is played</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Play the sound alias from a position<BR><B>EXAMPLE:  </B>PlaySoundAtPosition("Dirt_skid", ( 100, 100, 0 ) )<BR></OL><P>
<HR><H1>void &lt;entity&gt; PlaySoundOnTag(<I>&lt;aliasname&gt;</I>,<I>[tag]</I>,<I>[team]</I>,<I>[ent]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;aliasname&gt; The sound alias to play, this can be the string name, or the integer hash<LI>        <B>[OPTIONAL]</B>  [tag] If present, the sound will play at the position of the given tag<LI>        <B>[OPTIONAL]</B>  [team] If present or not undefined the sound will only be heard by the specified team<LI>        <B>[OPTIONAL]</B>  [ent] If present the sound will also be heard on the specified entity</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Play the sound alias as if coming from the tag<BR><B>EXAMPLE:  </B>self PlaySoundOnTag( soundAlias, "J_Head")<BR></OL><P>
<HR><H1>void &lt;entity&gt; PlaySoundToAllButPlayer(<I>&lt;aliasname&gt;</I>,<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;aliasname&gt; The sound alias to play (string)<LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player that will not be able to hear the sound. (entity)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Play the sound alias as if coming from the entity, so that everyone but one player can hear it<BR><B>EXAMPLE:  </B>self PlaySoundToAllButPlayer( "frag_out", self )<BR></OL><P>
<HR><H1>void &lt;entity&gt; PlaySoundToPlayer(<I>&lt;aliasname&gt;</I>,<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;aliasname&gt; The sound alias to play (string) or the sound alias (int)<LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player that will be able to hear the sound. (entity)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Play the sound alias as if coming from the entity, so that only one player can hear it<BR><B>EXAMPLE:  </B>self PlaySoundToPlayer( "frag_out", self )<BR></OL><P>
<HR><H1>void &lt;entity&gt; PlaySoundToTeam(<I>&lt;aliasname&gt;</I>,<I>&lt;teamname&gt;</I>,<I>[ignoreplayer]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;aliasname&gt; The sound alias to play<LI>        <B>[MANDATORY]</B>  &lt;teamname&gt; The team that will be able to hear the sound. Must be either 'axis' or 'allies' or 'team3'.<LI>        <B>[OPTIONAL]</B>  [ignoreplayer] If present, this player will not hear the sound.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Play the sound alias as if coming from the entity, so that only one team can hear it<BR><B>EXAMPLE:  </B>self PlaySoundToTeam( "frag_out", "axis", self )<BR></OL><P>
<HR><H1>void &lt;entity&gt; PlaySoundWithNotify(<I>&lt;aliasname&gt;</I>,<I>[notification string]</I>,<I>[tag]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;aliasname&gt; The sound alias to play<LI>        <B>[OPTIONAL]</B>  [notification string] If present, the sound will notify this string on this entity when done.stopsounds<LI>        <B>[OPTIONAL]</B>  [tag] If present, the sound will play at the position of the given tag</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Play the sound alias as if coming from the entity<BR><B>EXAMPLE:  </B>self PlaySoundWithNotify("Dirt_skid","skidsound")<BR></OL><P>
<HR><H1>void PositionQuery_Filter_Directness(<I>&lt;queryStruct&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;target&gt;</I>,<I>[resultVarName]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;queryStruct&gt; result from PositionQuery_Source function. each point contained here will have direction info computed.<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; usually the position of AI before move.<LI>        <B>[MANDATORY]</B>  &lt;target&gt; the position AI is trying to approach.<LI>        <B>[OPTIONAL]</B>  [resultVarName] by default the result directness value will be stored in pointStruct.directness, but can be override by this string.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Directness filter compute the direction information for each of the positions, relative to &lt;origin&gt; and &lt;target&gt;.<BR><B>EXAMPLE:  </B>PositionQuery_Filter_Directness( queryResult, self.origin, self.enemy.origin )<BR><B>NOTES:  </B>The result includes:pointStruct.Directness = DistanceToTargetDifferenceAfterMove / DistanceMoved. Directness describes how efficient the point emerges to target. A close to 1.0 directness leads straight towards target; a close to 0.0 directness prefers strafing while maintain distance; a negative directness gets away from target.pointStruct.LeftDist = distance moved to the left using reference line passing &lt;origin&gt; and &lt;target&gt;. negative value means to the right.pointStruct.TargetDist = distance to &lt;target&gt;.<BR></OL><P>
<HR><H1>void PositionQuery_Filter_DistanceToGoal(<I>&lt;queryStruct&gt;</I>,<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;queryStruct&gt; result from PositionQuery_Source function."<LI>        <B>[MANDATORY]</B>  &lt;entity&gt; the entity used to check goal."</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Calculate the distance to &lt;entity&gt;.goalpos. If the point is in &lt;entity&gt;.goalradius, the distance will be 0. the result is in pointStruct.distToGoal<BR><B>EXAMPLE:  </B>PositionQuery_Filter_DistanceToGoal( queryResult, self )<BR></OL><P>
<HR><H1>void PositionQuery_Filter_InClaimedLocation(<I>&lt;queryStruct&gt;</I>,<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;queryStruct&gt; result from PositionQuery_Source function."<LI>        <B>[MANDATORY]</B>  &lt;entity&gt; the entity used to check goal."</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the locations are inside other sentients claimed locations &lt;entity&gt;.inClaimedLocation.<BR><B>EXAMPLE:  </B>PositionQuery_Filter_InClaimedLocation( queryResult, self )<BR></OL><P>
<HR><H1>void PositionQuery_Filter_Sight(<I>&lt;queryStruct&gt;</I>,<I>&lt;targetPosition&gt;</I>,<I>[offset]</I>,<I>[visibleBy_Ent]</I>,<I>[numOfPassedToEarlyOut]</I>,<I>[ignoreEnt]</I>,<I>[resultVarName]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;queryStruct&gt; result from PositionQuery_Source function. each point contained here will be used to check sight against &lt;targetPosition&gt;. "<LI>        <B>[MANDATORY]</B>  &lt;targetPosition&gt; the position to check sight."<LI>        <B>[OPTIONAL]</B>  [offset] offset to add on each point before sight checking. this is usually something like: offset = ai GetEye() - ai.origin. default to (0,0,0). "<LI>        <B>[OPTIONAL]</B>  [visibleBy_Ent] if defined, the corresponding sight check function on Actor or Vehicle will be called. Otherwise the checks just do simple bullet tracing."<LI>        <B>[OPTIONAL]</B>  [numOfPassedToEarlyOut] if defined and bigger than 0, the filter will early out after found this many passed sight checks. this is useful if the points are pre sorted by score and we don't care about lower scored ones."<LI>        <B>[OPTIONAL]</B>  [ignoreEnt] ignore entity during trace. if [visibleBy_Ent] is defined, it is already ignored internally. "<LI>        <B>[OPTIONAL]</B>  [resultVarName] by default the results will be stored in pointStruct.visibility, but can be override by this string. "</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sight filter do sight check on each of the positions to a target position, and store the result in pointStruct.visibility (boolean).<BR><B>EXAMPLE:  </B>PositionQuery_Filter_Sight( queryResult, self.enemy.origin, self GetEye() - self.origin, self, 30, self.enemy );<BR></OL><P>
<HR><H1>void PositionQuery_Source_Navigation(<I>&lt;origin&gt;</I>,<I>&lt;minSearchRadius&gt;</I>,<I>&lt;maxSearchRadius&gt;</I>,<I>&lt;halfHeight&gt;</I>,<I>&lt;innerSpacing&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;innerSpacing&gt;</I>,<I>[distributionBias]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; Position to start the search around.<LI>        <B>[MANDATORY]</B>  &lt;minSearchRadius&gt; the minimum radius away from origin.<LI>        <B>[MANDATORY]</B>  &lt;maxSearchRadius&gt; the maximum radius away from origin. can equal to minSearchRadius.<LI>        <B>[MANDATORY]</B>  &lt;halfHeight&gt; the max height difference (both positive and negative) away from origin.<LI>        <B>[MANDATORY]</B>  &lt;innerSpacing&gt; the distance between points in.<LI>        <B>[OPTIONAL]</B>  [reachableBy_Ent] if defined, it will be used to make sure all the points are reachable by this entity from &lt;origin&gt; (not the entity's current position). Can pass in a float number radius to get points on NavMesh. Can also pass in string 'navvolume_small' or 'navvolume_big' to get points on navvolume. Note passing in entity radius only gives rough estimate, not correct result.<LI>        <B>[OPTIONAL]</B>  [outerSpacing] if defined, the distance between points will be Lerped from &lt;innerSpacing&gt; to [outerSpacing], to create a gradual distribution.<LI>        <B>[OPTIONAL]</B>  [distributionBias] (vec2) if defined, the density of the points will be changed gradually along the direction of this vector. the magnitude will be use as scalar, with 1 being the norm scale.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Generate points around &lt;origin&gt;, between &lt;minSearchRadius&gt; and &lt;maxSearchRadius&gt; and within &lt;halfHeight&gt; height difference. For ground AI, the points will be on Nav Mesh; for flying AI, the points will be in Nav Volume. Only the points in pathable area will be kept. If the &lt;origin&gt; itself is in pathable area, all the points are guaranteed to be reachable from &lt;origin&gt;. If the &lt;origin&gt; is outside pathable area, all the points will still be in pathable areas surrounding &lt;origin&gt;, but reach-abilities cannot be guaranteed.<BR><B>EXAMPLE:  </B>queryResult = PositionQuery_Source_Navigation( goalpos, self.radius, self.radius * 8, heightRadius, AI_GOAL_POINT_STEP, self, AI_GOAL_POINT_STEP * 0.2 )if ( queryResult.centerOnNav ){foreach( pointStruct in queryResult.data ){position = pointStruct.origindist = pointStruct.distToOrigin2D...}}<BR><B>NOTES:  </B>The returned data will be in following structure:rootStruct{// meta data of the queryvec3 originfloat maxRadiusstring sourceTypebool centerOnNav...// points data arraypointStruct{vec3 originfloat scorefloat distToOrigin2D// filters will add additional values here later, e.g.bool visibilityfloat distanceToPoint...} data[]} returnValue<BR></OL><P>
<HR><H1>void PositionWouldTelefrag(<I>&lt;position&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; The position of the potential spawn point</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the passed in origin would telefrag a player if another player was spawned there.<BR><B>EXAMPLE:  </B>if ( PositionWouldTelefrag( spawnpoints[i].origin ) ) ...<BR></OL><P>
<HR><H1>void PrecacheLeaderboards(<I>&lt;leaderboard names&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;leaderboard names&gt; The name of the leaderboards to precache</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Precache a sp/mp leaderboard.<BR><B>EXAMPLE:  </B>PrecacheLeaderboards( "LB_KILLS LB_WINS LB_TOTALXP LB_ACCURACY" )<BR></OL><P>
<HR><H1>void &lt;grenade&gt; PredictGrenade()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Predict where the grenade (self) will explode.<BR><B>EXAMPLE:  </B>grenade PredictGrenade()<BR></OL><P>
<HR><H1>void PredictPosition(<I>&lt;ent&gt;</I>,<I>&lt;frames&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;ent&gt; The entity to predict position of<LI>        <B>[MANDATORY]</B>  &lt;frames&gt; The frame count</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Predict position of the entity at the end of the frames<BR><B>EXAMPLE:  </B>prediction = PredictPosition( ent, 4 )<BR></OL><P>
<HR><H1>void &lt;player&gt; PredictSpawnPoint(<I>&lt;origin&gt;</I>,<I>&lt;angles&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The origin to spawn at<LI>        <B>[MANDATORY]</B>  &lt;angles&gt; The angle.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Indicates to the Texture Streamer where we expect to spawn in.<BR><B>EXAMPLE:  </B>player predictSpawnPoint( origin, angles )<BR></OL><P>
<HR><H1>void Print(<I>&lt;text&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;text&gt; text to be written</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Development only - write to the console<BR><B>EXAMPLE:  </B>Print( "Stuff and things!" )<BR></OL><P>
<HR><H1>void PrintLn(<I>&lt;text&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;text&gt; text to be written</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Development only - write line to the console<BR><B>EXAMPLE:  </B>PrintLn( "I could be doing better!" )<BR></OL><P>
<HR><H1>void &lt;client&gt; ProcessClientFieldsAsIfNew()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Process the client fields again<BR><B>EXAMPLE:  </B>self ProcessClientFieldsAsIfNew()<BR></OL><P>
<HR><H1>void &lt;ai_or_player&gt; PropagateCurrentEvent()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Propagate the current event to other AI.<BR><B>EXAMPLE:  </B>point = self PropagateCurrentEvent()<BR></OL><P>
<HR><H1>void QSortScoredSpawnPointsAscending(<I>&lt;input_array&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;input_array&gt; The array of points</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sort the scored spawn points in an ascending order<BR><B>EXAMPLE:  </B>sorted_spawn_points = QSortScoredSpawnPointsAscending( scored_spawn_points )<BR></OL><P>
<HR><H1>void queuemeleeactionstate()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the queued action state to melee for the player's default hand.<BR><B>EXAMPLE:  </B>player QueueMeleeActionState()<BR></OL><P>
<HR><H1>void &lt;entity&gt; RadioActive_FX(<I>&lt;localClientNum&gt;</I>,<I>true/false. Default is true.</I>,<I>Blur. 0 - 5. Default is 0.</I>,<I>Speed. 0 - 2. Default is 1.</I>,<I>Intensity. 0 - 5. Default is 2.</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the player<LI>        <B>[OPTIONAL]</B>  true/false. Default is true.<LI>        <B>[OPTIONAL]</B>  Blur. 0 - 5. Default is 0.<LI>        <B>[OPTIONAL]</B>  Speed. 0 - 2. Default is 1.<LI>        <B>[OPTIONAL]</B>  Intensity. 0 - 5. Default is 2.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Plays RadioActive/Fire FX<BR><B>EXAMPLE:  </B>entity RadioActive_FX(0, true)<BR></OL><P>
<HR><H1>void RadiusDamage()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR></OL><P>
<HR><H1>void ReCacheLeaderboards()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>recaches local client leaderboard<BR><B>EXAMPLE:  </B>recacheleaderboards(0)<BR></OL><P>
<HR><H1>void RecordBreadcrumbDataForPlayer()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>record a breadcrumb data point for player at time<BR></OL><P>
<HR><H1>void &lt;player&gt; RefreshShieldAttachment()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Re-attach the shield model to the player.<BR><B>EXAMPLE:  </B>player RefreshShieldAttachment()<BR></OL><P>
<HR><H1>void RegisterClientField(<I>&lt;Client field pool name&gt;</I>,<I>&lt;name&gt;</I>,<I>&lt;version&gt;</I>,<I>&lt;num bits&gt;</I>,<I>&lt;type&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;Client field pool name&gt; Which pool the field is allocated from. Currently supported : "world", "actor", "vehicle", "scriptmover"<LI>        <B>[MANDATORY]</B>  &lt;name&gt; Unique name to identify the field.<LI>        <B>[MANDATORY]</B>  &lt;version&gt; Number indicating version this field was added in - see _version.gsh for defines.<LI>        <B>[MANDATORY]</B>  &lt;num bits&gt; How many bits to use for the field. Valid values are in the range of 1-32. Only ask for as many as you need.<LI>        <B>[MANDATORY]</B>  &lt;type&gt; Type of the field. Currently supported types "int" or "float"</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Register a client field. Client fields are variable bit length fields communicated from server to client.<BR><B>EXAMPLE:  </B>RegisterClientField("world", "my_field", 2, "int"); // registers a world int field with 2 bits of resolution, that can hold the values 0,1,2,3.<BR></OL><P>
<HR><H1>void RegisterSkipto(<I>&lt;skipto_name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;skipto_name&gt; The skipto name to register</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Register a new skipto name<BR><B>EXAMPLE:  </B>struct.code_index = RegisterSkipto( msg )<BR></OL><P>
<HR><H1>void &lt;trigger&gt; ReleaseClaimedTrigger()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Release a currently claimed trigger<BR><B>EXAMPLE:  </B>self.trigger releaseClaimedTrigger()<BR></OL><P>
<HR><H1>void &lt;player&gt; RemoveAllFriendlyScramblers()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>removes all friendly scramblers<BR><B>EXAMPLE:  </B>player RemoveAllFriendlyScramblers( )<BR></OL><P>
<HR><H1>void &lt;player&gt; RemoveAllSensorGrenadeAreas()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>removes all sensor grenade areas<BR><B>EXAMPLE:  </B>player RemoveAllSensorGrenadeAreas( )<BR></OL><P>
<HR><H1>void &lt;entity&gt; RemoveForceNoCull()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Removes the force-no-cull flag. Entity will now be culled by portals<BR><B>EXAMPLE:  </B>helicopter RemoveForceNoCull()<BR></OL><P>
<HR><H1>void &lt;player&gt; RemoveFriendlyScrambler(<I>&lt;handle&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;handle&gt; will be used to remove the scrambler</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>removes new friendly scrambler from the compass using the same handle you gave when creating it<BR><B>EXAMPLE:  </B>player RemoveFriendlyScrambler( scrambler.handle )<BR></OL><P>
<HR><H1>void RemoveInfluencer(<I>&lt;influencer id&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;influencer id&gt; The influencer to remove</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Removes the given influencer<BR><B>EXAMPLE:  </B>RemoveInfluencer( influencer_id )<BR></OL><P>
<HR><H1>void &lt;entity&gt; RemoveNoSunShadow()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Removes the no-sunshadow flag.<BR><B>EXAMPLE:  </B>helicopter RemoveNoSunShadow()<BR></OL><P>
<HR><H1>void &lt;player&gt; RemoveSensorGrenadeArea(<I>&lt;handle&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;handle&gt; will be used to remove the sensor</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Removes Sensor Grenade Area from the compass<BR><B>EXAMPLE:  </B>player RemoveSensorGrenadeArea( sensor.handle )<BR></OL><P>
<HR><H1>void RemoveZombieBoxWeapon(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to remove</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Removes a zombie box weapon<BR><B>EXAMPLE:  </B>RemoveZombieBoxWeapon( weapon )<BR></OL><P>
<HR><H1>void RenderHealthOverlay(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the whether the health overlay should be rendered or not<BR><B>EXAMPLE:  </B>yesno = RenderHealthOverlay( localClientNum )<BR></OL><P>
<HR><H1>void RenderHealthOverlayHealth(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the whether the health overlay health ratio<BR><B>EXAMPLE:  </B>yesno = RenderHealthOverlayHealth( localClientNum )<BR></OL><P>
<HR><H1>void ReportUser()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR></OL><P>
<HR><H1>void ResetAILimit()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears any previous restrictions on the max number of AI.<BR></OL><P>
<HR><H1>void &lt;entity&gt; ResetDestructible()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Resets the destructible entity back to its start state<BR><B>EXAMPLE:  </B>vehicle ResetDestructible()<BR></OL><P>
<HR><H1>void &lt;player&gt; ResetDoubleJumpRechargeTime()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Resets the double jump recharge timer as if the player had just used it<BR><B>EXAMPLE:  </B>player ResetDoubleJumpRechargeTime()<BR></OL><P>
<HR><H1>void &lt;player&gt; ResetFOV()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Replace the current FOV by the default FOV<BR><B>EXAMPLE:  </B>player ResetFOV()<BR></OL><P>
<HR><H1>void ResetGlass()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Server side glass struct loops through all glass and resets to inital state<BR><B>EXAMPLE:  </B>ResetGlass()<BR></OL><P>
<HR><H1>void &lt;entity&gt; ResetMissileDetonationTime(<I>[time]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [time] Override the reset timer from the weapon and specify the time left.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Resets the timer for a grenade or missile to its max fuse time.<BR><B>EXAMPLE:  </B>grenadeEnt ResetMissileDetonationTime()<BR></OL><P>
<HR><H1>void ResetWeaponCosts(<I>&lt;local client num&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;local client num&gt; The local client num</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Reset the zombie weapon costs<BR><B>EXAMPLE:  </B>ResetWeaponCosts( &lt;local client num&gt;  )<BR></OL><P>
<HR><H1>void ResetZombieBoxWeapons()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Reset the zombie box weapons<BR><B>EXAMPLE:  </B>ResetZombieBoxWeapons()<BR></OL><P>
<HR><H1>void ReviveObituary(<I>&lt;victim&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;victim&gt; The victim entity</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Create an revive obituary for a character<BR><B>EXAMPLE:  </B>Obituary( self )<BR></OL><P>
<HR><H1>void RopeGetPosition(<I>&lt;ropeid&gt;</I>,<I>&lt;frac&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;ropeid&gt; The id of the rope<LI>        <B>[MANDATORY]</B>  &lt;frac&gt; Value between 0 and 1 specifying what position we are querying.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Queries the position of the rope.<BR><B>EXAMPLE:  </B>RopeGetPosition( ropeid, 1 )<BR></OL><P>
<HR><H1>void RopePulse(<I>&lt;origin&gt;</I>,<I>&lt;innerRadius&gt;</I>,<I>&lt;outerRadius&gt;</I>,<I>&lt;innerDamage&gt;</I>,<I>&lt;outerDamage&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; Where the event is.<LI>        <B>[MANDATORY]</B>  &lt;innerRadius&gt; inner radius of event.  At this radius or lower, innerDamage is done.<LI>        <B>[MANDATORY]</B>  &lt;outerRadius&gt; outer radius of event.  Maximum extent at which outerDamage is done.  Damage scales to innerDamage between outerRadius and innerRadius<LI>        <B>[MANDATORY]</B>  &lt;innerDamage&gt; how much damage is applied at innerRadius, or lower.<LI>        <B>[MANDATORY]</B>  &lt;outerDamage&gt; how much damage is applied at outerRadius.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Creates a stimulus that will effect ropes in the area and radius of the event.  Amount of movement is based on damage calculation.  Cheaper than physics events, as it only effects ropes.  Zero network cost, as it's on the client.<BR><B>EXAMPLE:  </B>RopePulse(sRopePulse.origin, 10, 150, 100, 1); // 150 damage applied at 10 units or less, 1 damage applied at 150 units distance.<BR></OL><P>
<HR><H1>void Rotate(<I>&lt;rotation vector&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;rotation vector&gt; The direction of the bobbing</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Causes a script entity to rotate, rotating around its origin<BR><B>EXAMPLE:  </B>self Rotate( rotationVir )<BR></OL><P>
<HR><H1>void &lt;script_model, script_origin or script_brushmodel&gt; RotatePitch(<I>&lt;pitch angle&gt;</I>,<I>&lt;time&gt;</I>,<I>[acceleration time]</I>,<I>[deceleration time]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;pitch angle&gt; The new pitch angle in degrees<LI>        <B>[MANDATORY]</B>  &lt;time&gt; The time to rotate in seconds<LI>        <B>[OPTIONAL]</B>  [acceleration time] The time spent accelerating in seconds<LI>        <B>[OPTIONAL]</B>  [deceleration time] The time spent decelerating in seconds</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Rotate this entity to the given pitch<BR><B>EXAMPLE:  </B>treeorg RotatePitch( -5, 0.26, 0.15, 0.1 )<BR></OL><P>
<HR><H1>void &lt;model_origin_brushmodel&gt; RotateRoll(<I>&lt;roll angle&gt;</I>,<I>&lt;time&gt;</I>,<I>[acceleration time]</I>,<I>[deceleration time]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;roll angle&gt; The new roll angle in degrees<LI>        <B>[MANDATORY]</B>  &lt;time&gt; The time to rotate in seconds<LI>        <B>[OPTIONAL]</B>  [acceleration time] The time spent accelerating in seconds<LI>        <B>[OPTIONAL]</B>  [deceleration time] The time spent decelerating in seconds</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Rotate this entity to the given roll angle<BR><B>EXAMPLE:  </B>self RotateRoll( (2 * 1500 + 3 * Randomfloat( 2500 )) * -1, 5, 0, 0 )<BR></OL><P>
<HR><H1>void &lt;script_model, script_origin or script_brushmodel&gt; RotateTo(<I>&lt;angles&gt;</I>,<I>&lt;time&gt;</I>,<I>[acceleration time]</I>,<I>[deceleration time]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;angles&gt; The new world angle to rotate to<LI>        <B>[MANDATORY]</B>  &lt;time&gt; The time to rotate in seconds<LI>        <B>[OPTIONAL]</B>  [acceleration time] The time spent accelerating in seconds<LI>        <B>[OPTIONAL]</B>  [deceleration time] The time spent decelerating in seconds</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Rotate this entity to the given world rotation value<BR><B>EXAMPLE:  </B>shutter RotateTo( (shutter.angles[0], newYaw, shutter.angles[2]), newTime )<BR></OL><P>
<HR><H1>void &lt;script_model, script_origin or script_brushmodel&gt; RotateVelocity(<I>&lt;rotate velocity&gt;</I>,<I>&lt;time&gt;</I>,<I>[acceleration time]</I>,<I>[deceleration time]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;rotate velocity&gt; The rotational velocity to rotate<LI>        <B>[MANDATORY]</B>  &lt;time&gt; The time to rotate in seconds<LI>        <B>[OPTIONAL]</B>  [acceleration time] The time spent accelerating in seconds<LI>        <B>[OPTIONAL]</B>  [deceleration time] The time spent decelerating in seconds</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Rotate this entity at a particular velocity for a given time<BR><B>EXAMPLE:  </B>self RotateVelocity( (x,y,z), 12 )<BR></OL><P>
<HR><H1>void &lt;script_model, script_origin or script_brushmodel&gt; RotateYaw(<I>&lt;yaw angle&gt;</I>,<I>&lt;time&gt;</I>,<I>[acceleration time]</I>,<I>[deceleration time]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;yaw angle&gt; The new yaw angle in degrees<LI>        <B>[MANDATORY]</B>  &lt;time&gt; The time to rotate in seconds<LI>        <B>[OPTIONAL]</B>  [acceleration time] The time spent accelerating in seconds<LI>        <B>[OPTIONAL]</B>  [deceleration time] The time spent decelerating in seconds</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Rotate this entity to the given yaw<BR></OL><P>
<HR><H1>void ScreenShake(<I>&lt;sourcePoint&gt;</I>,<I>&lt;scalepitch&gt;</I>,<I>&lt;scaleyaw&gt;</I>,<I>&lt;scaleroll&gt;</I>,<I>&lt;duration&gt;</I>,<I>&lt;durationfadeup&gt;</I>,<I>&lt;durationfadedown&gt;</I>,<I>&lt;radius&gt;</I>,<I>&lt;frequencypitch&gt;</I>,<I>&lt;frequencyyaw&gt;</I>,<I>&lt;frequencyroll&gt;</I>,<I>&lt;exponent&gt;</I>,<I>[target]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;sourcePoint&gt; The position of the earthquake.<LI>        <B>[MANDATORY]</B>  &lt;scalepitch&gt; The scale of the shake in player's pitch. Max is 100; Accurate to 2 decimal places.<LI>        <B>[MANDATORY]</B>  &lt;scaleyaw&gt; The scale of the shake in player's yaw. Max is 100; Accurate to 2 decimal places.<LI>        <B>[MANDATORY]</B>  &lt;scaleroll&gt; The scale of the shake in player's roll. Max is 100; Accurate to 2 decimal places.<LI>        <B>[MANDATORY]</B>  &lt;duration&gt; Duration in seconds.<LI>        <B>[OPTIONAL]</B>  &lt;durationfadeup&gt; Duration in seconds, included in base duration. Default is 0. Value of -1 means duration - durationfadeup.<LI>        <B>[OPTIONAL]</B>  &lt;durationfadedown&gt; Duration in seconds, included in base duration. Default is -1. Value of -1 means duration - durationfadedown.<LI>        <B>[OPTIONAL]</B>  &lt;radius&gt; The radius of shake, dampens as you move away from entity. Default is 0 = shake is global<LI>        <B>[OPTIONAL]</B>  &lt;frequencypitch&gt; The scaled speed of the shake's pitch. Default is 1. Max is 100; Accurate to 2 decimal places.<LI>        <B>[OPTIONAL]</B>  &lt;frequencyyaw&gt; The scaled speed of the shake's yaw. Default is 1. Max is 100; Accurate to 2 decimal places.<LI>        <B>[OPTIONAL]</B>  &lt;frequencyroll&gt; The scaled speed of the shake's roll. Default is 1. Max is 100; Accurate to 2 decimal places.<LI>        <B>[OPTIONAL]</B>  &lt;exponent&gt; The scale is multiplied by itself 'exponent' times to determine how the shake falls off. Default is 1 which is a linear falloff. Max is 100; Accurate to 2 decimal places<LI>        <B>[OPTIONAL]</B>  [target] Target is given if screen shake is to be shown to particular client only</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Create a screen shake event on the given point.<BR><B>EXAMPLE:  </B>ScreenShake( jolt.origin, 0.3, 0.3, 0.3, 3, 0.2, 3, 850, 0.5, 0.25, 0.25 ); // locationalScreenShake( (0,0,0), 0.3, 0.3, 0.3, 3, 0.2, 3, 0, 0.5, 0.25, 0.25, player ); // non locational for one player only<BR></OL><P>
<HR><H1>void &lt;entity&gt; SendFaceEvent(<I>&lt;index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;index&gt; Face event index (string)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Broadcast to the client a face event<BR><B>EXAMPLE:  </B>self SendFaceEvent( &lt;index&gt; )<BR></OL><P>
<HR><H1>void SendKillstreakDamageEvent(<I>[damage]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [damage] How much damage was done</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Send a killstreak damage event to the client<BR><B>EXAMPLE:  </B>killstreakOwner SendKillstreakDamageEvent( 25 )<BR></OL><P>
<HR><H1>void ServerFieldGetValue(<I>&lt;player&gt;</I>,<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; player to get value from<LI>        <B>[MANDATORY]</B>  &lt;name&gt; name of field to retrieve</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the value of a serverfield from a given player<BR><B>EXAMPLE:  </B>ServerFieldGetValue(self, "my_field"); <BR></OL><P>
<HR><H1>void ServerFieldIncrement(<I>&lt;player&gt;</I>,<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; the player to operate on<LI>        <B>[MANDATORY]</B>  &lt;name&gt; Unique name to identify the field.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>increment the value in a server field.  wrap on overflow.  <BR><B>EXAMPLE:  </B>ServerFieldIncrement(player, "my_field")<BR></OL><P>
<HR><H1>void serverfieldregister(<I>&lt;name&gt;</I>,<I>&lt;num bits&gt;</I>,<I>&lt;type&gt;</I>,<I>&lt;callback&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; Unique name to identify the field.<LI>        <B>[MANDATORY]</B>  &lt;num bits&gt; How many bits to use for the field. Valid values are in the range of 1-32. Only ask for as many as you need.<LI>        <B>[MANDATORY]</B>  &lt;type&gt; Type of the field. Currently supported types "int" or "float"<LI>        <B>[MANDATORY]</B>  &lt;callback&gt; Function that gets called when the value changes (each client can toggle this bit independently of the others)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Register a server field. Server fields are variable bit length fields communicated from client to server<BR><B>EXAMPLE:  </B>RegisterServerField("my_field", 2, "int"); // registers an int field with 2 bits of resolution, that can hold the values 0,1,2,3.<BR></OL><P>
<HR><H1>void serverfieldsetval(<I>&lt;player&gt;</I>,<I>&lt;name&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; the player to operate on<LI>        <B>[MANDATORY]</B>  &lt;name&gt; Unique name to identify the field.<LI>        <B>[MANDATORY]</B>  &lt;value&gt; the value of the field </UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Register a server field.  server fields are variable bit length fields communicated from client to server<BR><B>EXAMPLE:  </B>RegisterServerField("my_field", VERSION_SHIP, 2, "int", ::my_cb_func); // registers a world int field with 2 bits of resolution, that can hold the values 0,1,2,3.<BR></OL><P>
<HR><H1>void ServerObjective_GetObjective(<I>&lt;localClientNum&gt;</I>,<I>&lt;objectiveName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number<LI>        <B>[MANDATORY]</B>  &lt;objectiveName&gt; The name of the objective</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the index of the objective or undefined if it does not exist<BR><B>EXAMPLE:  </B>objective_num = ServerObjective_GetObjective( localClientNum, "dom_a" )<BR></OL><P>
<HR><H1>entity ServerObjective_GetObjectiveEntity(<I>&lt;localClientNum&gt;</I>,<I>&lt;objectiveID&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number<LI>        <B>[MANDATORY]</B>  &lt;objectiveID&gt; The index of objective</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the entity of the objective<BR><B>EXAMPLE:  </B>origin = ServerObjective_GetObjectiveEntity( localClientNum, objective_num )<BR></OL><P>
<HR><H1>void ServerObjective_GetObjectiveGameModeFlags(<I>&lt;localClientNum&gt;</I>,<I>&lt;objectiveID&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number<LI>        <B>[MANDATORY]</B>  &lt;objectiveID&gt; The index of objective</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the origin of the objective<BR><B>EXAMPLE:  </B>origin = ServerObjective_GetObjectiveGameModeFlags( localClientNum, objective_num )<BR></OL><P>
<HR><H1>void ServerObjective_GetObjectiveOrigin(<I>&lt;localClientNum&gt;</I>,<I>&lt;objectiveID&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number<LI>        <B>[MANDATORY]</B>  &lt;objectiveID&gt; The index of objective</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the index of the objective or undefined if it does not exist<BR><B>EXAMPLE:  </B>origin = ServerObjective_GetObjectiveOrigin( localClientNum, objective_num )<BR></OL><P>
<HR><H1>void ServerObjective_GetObjectiveProgress(<I>&lt;localClientNum&gt;</I>,<I>&lt;objectiveID&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number<LI>        <B>[MANDATORY]</B>  &lt;objectiveID&gt; The index of objective</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the origin of the objective<BR><B>EXAMPLE:  </B>origin = ServerObjective_GetObjectiveProgress( localClientNum, objective_num )<BR></OL><P>
<HR><H1>void ServerObjective_GetObjectiveTeam(<I>&lt;localClientNum&gt;</I>,<I>&lt;objectiveID&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number<LI>        <B>[MANDATORY]</B>  &lt;objectiveID&gt; The index of objective</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the origin of the objective<BR><B>EXAMPLE:  </B>origin = ServerObjective_GetObjectiveTeam( localClientNum, objective_num )<BR></OL><P>
<HR><H1>void &lt;ai&gt; ServiceEvent(<I>&lt;eventId&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;eventId&gt; The identifier of the event (integer)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the specified event to serviced.<BR><B>EXAMPLE:  </B>point = self ServiceEvent( 100 )<BR></OL><P>
<HR><H1>void &lt;ai&gt; ServiceEventsInRadius(<I>&lt;origin&gt;</I>,<I>&lt;radius&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; Source position<LI>        <B>[MANDATORY]</B>  &lt;radius&gt; Radius of events to service (-1 for all)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the events within a radius to serviced.<BR><B>EXAMPLE:  </B>self ServiceEventsInRadius( self.origin, 500 )<BR></OL><P>
<HR><H1>void SessionModeAbbreviation()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns abbreviation of the current session mode, or "default" if none<BR><B>EXAMPLE:  </B>spawnpointname = SessionModeAbbreviation() + "_frontend_camera<BR></OL><P>
<HR><H1>void SessionModeIsCampaignDeadOpsGame()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true/false if the current session mode is DeadOps game<BR><B>EXAMPLE:  </B>if ( SessionModeIsCampaignDeadOpsGame() )<BR></OL><P>
<HR><H1>void SessionModeIsCampaignGame()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true/false if the current session mode is a campaign game<BR><B>EXAMPLE:  </B>if ( SessionModeIsCampaignGame() )<BR></OL><P>
<HR><H1>void SessionModeIsCampaignZombiesGame()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns true/false if the current session mode is a campaign game and the campaign mode is set to zombies.<BR><B>EXAMPLE:  </B>if ( SessionModeIsCampaignZombiesGame() )<BR></OL><P>
<HR><H1>void SessionModeIsMultiplayerGame()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true/false if the current session mode is a multiplayer game<BR><B>EXAMPLE:  </B>if ( SessionModeIsMultiplayerGame() )<BR></OL><P>
<HR><H1>void SessionModeIsOnlineGame()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true/false if the current session mode is onlinegame<BR><B>EXAMPLE:  </B>if ( SessionModeIsOnlineGame() )<BR></OL><P>
<HR><H1>void SessionModeIsPrivate()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true/false if the current session mode is a private game<BR><B>EXAMPLE:  </B>if ( SessionModeIsPrivate() )<BR></OL><P>
<HR><H1>void SessionModeIsPrivateOnlineGame()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true/false if the current session mode is a private onlinegame<BR><B>EXAMPLE:  </B>if ( SessionModeIsPrivateOnlineGame() )<BR></OL><P>
<HR><H1>void SessionModeIsSystemlink()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true/false if the current session mode is a systemlink game<BR><B>EXAMPLE:  </B>if ( SessionModeIsSystemlink() )<BR></OL><P>
<HR><H1>void SessionModeIsZombiesGame()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true/false if the current session mode is a zombies game<BR><B>EXAMPLE:  </B>if ( SessionModeIsZombiesGame() )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetActorWeapon(<I>&lt;weaponname&gt;</I>,<I>[weapon options]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weaponname&gt; The weapon name. (string)<LI>        <B>[OPTIONAL]</B>  [weapon options] options value computed using calcweaponoptions</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the actor weapon.<BR><B>EXAMPLE:  </B>self SetActorWeapon( "weapon_name" )<BR></OL><P>
<HR><H1>void SetAILimit()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Allows you to specify a max number of active AI - which over-rides the MAX_AI functionality in the engine, when it comes time to spawn in new AI.  Setting the value higher will not give you more AI than the system supports.<BR><B>EXAMPLE:  </B>SetAILimit( 10 )<BR></OL><P>
<HR><H1>void &lt;turret&gt; SetAISpread(<I>&lt;spread&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;spread&gt; The spread of the turret in degrees</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the spread of this turret when used by an AI<BR><B>EXAMPLE:  </B>roof_turret SetAISpread( 0.2 )<BR></OL><P>
<HR><H1>void SetAmbientSnapshot(<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; Name of the snapshot</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the ambient snapshot<BR><B>EXAMPLE:  </B>SetAmbientSnapshot( level._sndActiveSnapshot )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetAnim(<I>&lt;animation&gt;</I>,<I>[weight]</I>,<I>[time]</I>,<I>[rate]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; The animation or animtree node to change.<LI>        <B>[OPTIONAL]</B>  [weight] Goal weight of this animation. Defaults to 1.0.<LI>        <B>[OPTIONAL]</B>  [time] Time to transition to this weight in seconds. Defaults to 0.2.<LI>        <B>[OPTIONAL]</B>  [rate] Playback rate of the animation. Defaults to 1.0.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Restart": These functions cause the animation to restart. If they had been previously playing, without this they would continue from their current time.<BR><B>EXAMPLE:  </B>self SetAnim( %precombatrun1, 1, 0.1, 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetAnimForceNew(<I>&lt;animation&gt;</I>,<I>[weight]</I>,<I>[time]</I>,<I>[goalTime]</I>,<I>[rate]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; The animation or animtree node to change.<LI>        <B>[OPTIONAL]</B>  [weight] Goal weight of this animation. Defaults to 1.0.<LI>        <B>[OPTIONAL]</B>  [time] Time to set this animation to after adding it. Defaults to 0.<LI>        <B>[OPTIONAL]</B>  [goalTime] Time to transition to this weight in seconds. Defaults to 0.2.<LI>        <B>[OPTIONAL]</B>  [rate] Playback rate of the animation. Defaults to 1.0.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Debug only functionality that adds a new instance of an animation to an animtree setting its time to a specific point.<BR><B>EXAMPLE:  </B>self SetAnimForceNew( %precombatrun1, 1, 0.1, 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetAnimKnob(<I>&lt;animation&gt;</I>,<I>[weight]</I>,<I>[time]</I>,<I>[rate]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; The animation or animtree node to change.<LI>        <B>[OPTIONAL]</B>  [weight] Goal weight of this animation. Defaults to 1.0.<LI>        <B>[OPTIONAL]</B>  [time] Time to transition to this weight in seconds. Defaults to 0.2.<LI>        <B>[OPTIONAL]</B>  [rate] Playback rate of the animation. Defaults to 1.0.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>See "SetAnim.<BR><B>EXAMPLE:  </B>self SetAnimKnob( %precombatrun1, 1, 0.1, 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetAnimKnobAll(<I>&lt;animation&gt;</I>,<I>&lt;root&gt;</I>,<I>[weight]</I>,<I>[time]</I>,<I>[rate]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; The animation or animtree node to change.<LI>        <B>[MANDATORY]</B>  &lt;root&gt; An ancestor of the animation.<LI>        <B>[OPTIONAL]</B>  [weight] Goal weight of this animation. Defaults to 1.0.<LI>        <B>[OPTIONAL]</B>  [time] Time to transition to this weight in seconds. Defaults to 0.2.<LI>        <B>[OPTIONAL]</B>  [rate] Playback rate of the animation. Defaults to 1.0.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>See "SetAnim.<BR><B>EXAMPLE:  </B>self SetAnimKnobAll( %precombatrun1, %body, 1, 0.1, 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetAnimKnobAllLimited(<I>&lt;animation&gt;</I>,<I>&lt;root&gt;</I>,<I>[weight]</I>,<I>[time]</I>,<I>[rate]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; The animation or animtree node to change.<LI>        <B>[MANDATORY]</B>  &lt;root&gt; An ancestor of the animation.<LI>        <B>[OPTIONAL]</B>  [weight] Goal weight of this animation. Defaults to 1.0.<LI>        <B>[OPTIONAL]</B>  [time] Time to transition to this weight in seconds. Defaults to 0.2.<LI>        <B>[OPTIONAL]</B>  [rate] Playback rate of the animation. Defaults to 1.0.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>See "SetAnim.<BR><B>EXAMPLE:  </B>self SetAnimKnobAllLimited( %precombatrun1, %body, 1, 0.1, 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetAnimKnobAllLimitedRestart(<I>&lt;animation&gt;</I>,<I>&lt;root&gt;</I>,<I>[weight]</I>,<I>[time]</I>,<I>[rate]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; The animation or animtree node to change.<LI>        <B>[MANDATORY]</B>  &lt;root&gt; An ancestor of the animation.<LI>        <B>[OPTIONAL]</B>  [weight] Goal weight of this animation. Defaults to 1.0.<LI>        <B>[OPTIONAL]</B>  [time] Time to transition to this weight in seconds. Defaults to 0.2.<LI>        <B>[OPTIONAL]</B>  [rate] Playback rate of the animation. Defaults to 1.0.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>See "SetAnim.<BR><B>EXAMPLE:  </B>self SetAnimKnobAllLimitedRestart( %precombatrun1, %body, 1, 0.1, 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetAnimKnobAllRestart(<I>&lt;animation&gt;</I>,<I>&lt;root&gt;</I>,<I>[weight]</I>,<I>[time]</I>,<I>[rate]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; The animation or animtree node to change.<LI>        <B>[MANDATORY]</B>  &lt;root&gt; An ancestor of the animation.<LI>        <B>[OPTIONAL]</B>  [weight] Goal weight of this animation. Defaults to 1.0.<LI>        <B>[OPTIONAL]</B>  [time] Time to transition to this weight in seconds. Defaults to 0.2.<LI>        <B>[OPTIONAL]</B>  [rate] Playback rate of the animation. Defaults to 1.0.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>See "SetAnim.<BR><B>EXAMPLE:  </B>self SetAnimKnobAllRestart( %precombatrun1, %body, 1, 0.1, 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetAnimKnobLimited(<I>&lt;animation&gt;</I>,<I>[weight]</I>,<I>[time]</I>,<I>[rate]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; The animation or animtree node to change.<LI>        <B>[OPTIONAL]</B>  [weight] Goal weight of this animation. Defaults to 1.0.<LI>        <B>[OPTIONAL]</B>  [time] Time to transition to this weight in seconds. Defaults to 0.2.<LI>        <B>[OPTIONAL]</B>  [rate] Playback rate of the animation. Defaults to 1.0.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>See "SetAnim.<BR><B>EXAMPLE:  </B>self SetAnimKnobLimited( %precombatrun1, 1, 0.1, 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetAnimKnobLimitedRestart(<I>&lt;animation&gt;</I>,<I>[weight]</I>,<I>[time]</I>,<I>[rate]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; The animation or animtree node to change.<LI>        <B>[OPTIONAL]</B>  [weight] Goal weight of this animation. Defaults to 1.0.<LI>        <B>[OPTIONAL]</B>  [time] Time to transition to this weight in seconds. Defaults to 0.2.<LI>        <B>[OPTIONAL]</B>  [rate] Playback rate of the animation. Defaults to 1.0.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>See "SetAnim.<BR><B>EXAMPLE:  </B>self SetAnimKnobLimitedRestart( %precombatrun1, 1, 0.1, 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetAnimKnobRestart(<I>&lt;animation&gt;</I>,<I>[weight]</I>,<I>[time]</I>,<I>[rate]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; The animation or animtree node to change.<LI>        <B>[OPTIONAL]</B>  [weight] Goal weight of this animation. Defaults to 1.0.<LI>        <B>[OPTIONAL]</B>  [time] Time to transition to this weight in seconds. Defaults to 0.2.<LI>        <B>[OPTIONAL]</B>  [rate] Playback rate of the animation. Defaults to 1.0.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>See "SetAnim.<BR><B>EXAMPLE:  </B>self SetAnimKnobRestart( %precombatrun1, 1, 0.1, 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetAnimLimited(<I>&lt;animation&gt;</I>,<I>[weight]</I>,<I>[time]</I>,<I>[rate]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; The animation or animtree node to change.<LI>        <B>[OPTIONAL]</B>  [weight] Goal weight of this animation. Defaults to 1.0.<LI>        <B>[OPTIONAL]</B>  [time] Time to transition to this weight in seconds. Defaults to 0.2.<LI>        <B>[OPTIONAL]</B>  [rate] Playback rate of the animation. Defaults to 1.0.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>See "SetAnim.<BR><B>EXAMPLE:  </B>self SetAnimLimited( %precombatrun1, 1, 0.1, 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetAnimLimitedRestart(<I>&lt;animation&gt;</I>,<I>[weight]</I>,<I>[time]</I>,<I>[rate]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; The animation or animtree node to change.<LI>        <B>[OPTIONAL]</B>  [weight] Goal weight of this animation. Defaults to 1.0.<LI>        <B>[OPTIONAL]</B>  [time] Time to transition to this weight in seconds. Defaults to 0.2.<LI>        <B>[OPTIONAL]</B>  [rate] Playback rate of the animation. Defaults to 1.0.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>See "SetAnim.<BR><B>EXAMPLE:  </B>self SetAnimLimitedRestart( %precombatrun1, 1, 0.1, 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetAnimRestart(<I>&lt;animation&gt;</I>,<I>[weight]</I>,<I>[time]</I>,<I>[rate]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; The animation or animtree node to change.<LI>        <B>[OPTIONAL]</B>  [weight] Goal weight of this animation. Defaults to 1.0.<LI>        <B>[OPTIONAL]</B>  [time] Time to transition to this weight in seconds. Defaults to 0.2.<LI>        <B>[OPTIONAL]</B>  [rate] Playback rate of the animation. Defaults to 1.0.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>See "SetAnim.<BR><B>EXAMPLE:  </B>self SetAnimRestart( %precombatrun1, 1, 0.1, 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetAnimTime(<I>&lt;animation&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; animation to manipulate</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the animation time for the given animation.<BR><B>EXAMPLE:  </B>if ( (self GetAnimTime( %walk_and_run_loops ) ) &lt; 0.5 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetAnimTimeByName(<I>&lt;animation&gt;</I>,<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;animation&gt; animation to manipulate<LI>        <B>[MANDATORY]</B>  &lt;time&gt; 0-&gt;1</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the animation normalized time for the given animation.<BR><B>EXAMPLE:  </B>self SetAnimTimeByName( "ai_anim_walk",  0.5)<BR></OL><P>
<HR><H1>void SetArchive()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>deprecated function, does nothing<BR></OL><P>
<HR><H1>void SetAssassinationEnabled(<I>&lt;flag&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flag&gt; Whether to use infrared material or not (boolean)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enable or disable assassinations on the AI.  Also turns on/off the can assassinate indicator.<BR><B>EXAMPLE:  </B>quadtank SetAssassinationEnabled( true )<BR></OL><P>
<HR><H1>void &lt;weapon&gt; SetAttachmentCosmeticVariantIndex(<I>&lt;weapon&gt;</I>,<I>&lt;attachment name&gt;</I>,<I>&lt;acvi&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon full name<LI>        <B>[MANDATORY]</B>  &lt;attachment name&gt; The attachment name of the weapon<LI>        <B>[MANDATORY]</B>  &lt;acvi&gt; The attachment cosmetic variant index</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the attachment cosmetic variant index for the weapon<BR><B>EXAMPLE:  </B>level.weapon_clientscript_cac_model[type] SetAttachmentCosmeticVariantIndex( weaponFullName, level.attachment_names[i], 0 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetAttachmentCosmeticVariantIndexes(<I>&lt;acvi&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;acvi&gt; The AttachmentCosmeticVariantIndexes to set</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the previously calculated SetAttachmentCosmeticVariantIndexes of the entity. The entity should not be a player<BR><B>EXAMPLE:  </B>killcamEnt SetAttachmentCosmeticVariantIndexes( acvi )<BR></OL><P>
<HR><H1>void SetAttachmentCosmeticVariants(<I>&lt;weaponname&gt;</I>,<I>[attachmentname_1]</I>,<I>[variantindex_1]</I>,<I>[attachmentname_2]</I>,<I>[variantindex_2]</I>,<I>[attachmentname_3]</I>,<I>[variantindex_3]</I>,<I>[attachmentname_4]</I>,<I>[variantindex_4]</I>,<I>[attachmentname_5]</I>,<I>[variantindex_5]</I>,<I>[attachmentname_6]</I>,<I>[variantindex_6]</I>,<I>[attachmentname_7]</I>,<I>[variantindex_7]</I>,<I>[attachmentname_8]</I>,<I>[variantindex_8]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weaponname&gt; the name of the base weapon to return<LI>        <B>[OPTIONAL]</B>  [attachmentname_1] the name of the first attachment<LI>        <B>[OPTIONAL]</B>  [variantindex_1] the index of the cosmetic variant to use for the first attachment<LI>        <B>[OPTIONAL]</B>  [attachmentname_2] the name of the second attachment<LI>        <B>[OPTIONAL]</B>  [variantindex_2] the index of the cosmetic variant to use for the second attachment<LI>        <B>[OPTIONAL]</B>  [attachmentname_3] the name of the third attachment<LI>        <B>[OPTIONAL]</B>  [variantindex_3] the index of the cosmetic variant to use for the third attachment<LI>        <B>[OPTIONAL]</B>  [attachmentname_4] the name of the fourth attachment<LI>        <B>[OPTIONAL]</B>  [variantindex_4] the index of the cosmetic variant to use for the fourth attachment<LI>        <B>[OPTIONAL]</B>  [attachmentname_5] the name of the fifth attachment<LI>        <B>[OPTIONAL]</B>  [variantindex_5] the index of the cosmetic variant to use for the fifth attachment<LI>        <B>[OPTIONAL]</B>  [attachmentname_6] the name of the sixth attachment<LI>        <B>[OPTIONAL]</B>  [variantindex_6] the index of the cosmetic variant to use for the sixth attachment<LI>        <B>[OPTIONAL]</B>  [attachmentname_7] the name of the seventh attachment<LI>        <B>[OPTIONAL]</B>  [variantindex_7] the index of the cosmetic variant to use for the seventh attachment<LI>        <B>[OPTIONAL]</B>  [attachmentname_8] the name of the eighth attachment<LI>        <B>[OPTIONAL]</B>  [variantindex_8] the index of the cosmetic variant to use for the eighth attachment</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the AttachmentCosmeticVariantIndexes data to be passed in to the weapon<BR><B>EXAMPLE:  </B>SetAttachmentCosmeticVariants( "mp7_mp", "acog", 2, "grip", 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetAvoidanceMask(<I>&lt;Mask&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;Mask&gt; (const string) Mask must be 'avoid all', 'avoid none', 'avoid actor', 'avoid ai'(actors+vehicles), 'avoid player', or 'avoid vehicle'</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the avoidance mask of this Havok character.<BR><B>EXAMPLE:  </B>randEnemy SetAvoidanceMask("avoid none")<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetAvoidanceProperty(<I>&lt;Property&gt;</I>,<I>&lt;Value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;Property&gt; (const string) Property must be 'collision penalty' or 'dodge penalty'<LI>        <B>[MANDATORY]</B>  &lt;Value&gt; (float) The value to set the property to</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the avoidance properties of this Havok character.<BR><B>EXAMPLE:  </B>randAlly SetAvoidanceProperty("collision penalty", 0.1)<BR></OL><P>
<HR><H1>void SetBallPassAllowed()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enables or disables ball passing for the given player.<BR><B>EXAMPLE:  </B>player SetBallPassAllowed( true )<BR></OL><P>
<HR><H1>void SetBeastModeIconMaterial(<I>&lt;iconid&gt;</I>,<I>&lt;materialname&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;iconid&gt; 1 melee 2 electricity 3 grapple<LI>        <B>[MANDATORY]</B>  &lt;materialname&gt; material name</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>sets the material used by beast mode icons<BR><B>EXAMPLE:  </B>SetBeastModeIconMaterial( 1, "cool_icon_1" )<BR></OL><P>
<HR><H1>void SetBGBCost(<I>&lt;local client num&gt;</I>,<I>&lt;cost&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;local client num&gt; The local client num<LI>        <B>[MANDATORY]</B>  &lt;cost&gt; The cost of a BGB</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the current BGB cost<BR><B>EXAMPLE:  </B>SetBGBCost( 115935 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetBlur(<I>&lt;target_blur&gt;</I>,<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target_blur&gt; The final blur. The value is pixels for Gaussian blur at 640x480. Must be a floating point value greater than 0.<LI>        <B>[MANDATORY]</B>  &lt;time&gt; Time in seconds</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Blur the screen over a period of time.<BR><B>EXAMPLE:  </B>setblur( 10.3, 3.0 )<BR></OL><P>
<HR><H1>void SetBlurByLocalClientNum(<I>&lt;localClientNum&gt;</I>,<I>&lt;blurFinalValue&gt;</I>,<I>&lt;blurTime&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number<LI>        <B>[MANDATORY]</B>  &lt;blurFinalValue&gt; The blur value (must be positive)<LI>        <B>[MANDATORY]</B>  &lt;blurTime&gt; The time to blur (must be positive)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the blur for the local client given<BR><B>EXAMPLE:  </B>SetBlurByLocalClientNum( localClientNum, curr_info.magnitude, curr_info.transition_in )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetBodyRenderOptions(<I>&lt;bodyRenderOptions&gt;</I>,<I>&lt;helmetRenderOptions&gt;</I>,<I>&lt;headRenderOptions&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;bodyRenderOptions&gt; The packed body render options - calculated with GetHeroBodyRenderOptions<LI>        <B>[MANDATORY]</B>  &lt;helmetRenderOptions&gt; The packed helmet render options - calculated with GetHeroHelmetRenderOptions<LI>        <B>[MANDATORY]</B>  &lt;headRenderOptions&gt; The packed head render options - calculated with GetHeroHeadRenderOptions</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the entity body, helmet and head render options.<BR><B>EXAMPLE:  </B>heroModel SetBodyRenderOptions( bodyRenderOptions, helmetRenderOptions, headRenderOptions )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetBodyRenderOptionsPacked(<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;value&gt; Usually returned value from GetBodyRenderOptionsPacked()</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the packed value of body render options (body type, style, colors)<BR><B>EXAMPLE:  </B>gibEntity SetBodyRenderOptionsPacked( 0 )<BR></OL><P>
<HR><H1>void SetBombTimer(<I>&lt;flag bit&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flag bit&gt; The flag bit to change<LI>        <B>[MANDATORY]</B>  &lt;value&gt; The new value of the bit</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Bomb timer set in the match state<BR><B>EXAMPLE:  </B>SetBombTimer( "A", 50000 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetBurn(<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; Time to burn for ( greater than 0 )</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the entity burning for the given time<BR><B>EXAMPLE:  </B>self SetBurn( 3.0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetCameraSpikeActive(<I>&lt;toggle&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;toggle&gt; 0 for off, 1 for on</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the state of a player's camera spike.<BR><B>EXAMPLE:  </B>player SetCameraSpikeActive( 1 )<BR></OL><P>
<HR><H1>void &lt;script_model, script_origin or script_brushmodel&gt; SetCanDamage(<I>&lt;can damage&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;can damage&gt; The can damage flag</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the candamage flag for this entity - this means that it can respond to notifies from bullets and grenade hits<BR><B>EXAMPLE:  </B>self SetCanDamage( true )<BR></OL><P>
<HR><H1>void SetClearanceCeiling()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets a new clearance ceiling. If the value is larger than the current ceiling, cut faces will be invalidated.<BR><B>EXAMPLE:  </B>SetClearanceCeiling( 15.0 )<BR></OL><P>
<HR><H1>void SetClientNameMode(<I>&lt;name mode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name mode&gt; either 'auto_change' or 'manual_change'</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>alters the way that the player name is updated, to prevent cheating by spectators altering their name to communicate with active players.<BR><B>EXAMPLE:  </B>SetClientNameMode( "auto_change" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetClone()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the contents for the clone.<BR><B>EXAMPLE:  </B>clone SetClone()<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetCompassIcon(<I>&lt;iconName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;iconName&gt; Name of compass material</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the icon to be shown on the minimap<BR><B>EXAMPLE:  </B>plane setCompassIcon(iconName)<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetContents(<I>&lt;content&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;content&gt; The content to set for the entity</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets contents of the entity to the given content<BR><B>EXAMPLE:  </B>reconModel SetContents( 0 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetCorpseGibState(<I>&lt;leg state&gt;</I>,<I>&lt;arm state&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;leg state&gt; 0 - 3 state: 0 is no gib, 1 right, 2 left, 3 both<LI>        <B>[MANDATORY]</B>  &lt;arm state&gt; 0 - 3 state: 0 is no gib, 1 right, 2 left, 3 both</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the gib state for the body rendering.<BR><B>EXAMPLE:  </B>corpse SetCorpseGibState( leg_state, arm_state )<BR></OL><P>
<HR><H1>void SetCullDist(<I>&lt;cull distance&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;cull distance&gt; The cull distance</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the cull distance for a level<BR><B>EXAMPLE:  </B>SetCullDist( 7200 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetCursorHint()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Attach a cursor hint to the entity.<BR><B>EXAMPLE:  </B>self setCursorHint( cursor_hint, cursor_hint_weapon )<BR></OL><P>
<HR><H1>void SetDamageDirectionIndicator(<I>&lt;indicator&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;indicator&gt; 0 = regular, 1 = armor</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Use the armor version of the hit indicator<BR></OL><P>
<HR><H1>void &lt;pathnode&gt; SetDangerous(<I>&lt;team&gt;</I>,<I>&lt;flag&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; Name of the team.<LI>        <B>[MANDATORY]</B>  &lt;flag&gt; True if dangerous. False otherwise</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set this node to be a dangerous node for a particular team. works only on pathnodes. <BR><B>EXAMPLE:  </B>self SetDangerous( self.team, true )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetDedicatedShadow(<I>&lt;flag&gt;</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  &lt;flag&gt; True or False, enabled or disabled</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enabled or Disables dedicated shadow for a model<BR><B>EXAMPLE:  </B>thing SetDedicatedShadow( true )<BR></OL><P>
<HR><H1>void &lt;turret&gt; SetDefaultDropPitch(<I>&lt;pitch&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;pitch&gt; yaw of the turret (side to side) in degrees.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the default drop pitch that the turret attempts to return to when it is not in use.<BR><B>EXAMPLE:  </B>turret SetDefaultDropPitch( -90 )<BR></OL><P>
<HR><H1>void SetDemoIntermissionPoint(<I>&lt;origin&gt;</I>,<I>&lt;angles&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt;<LI>        <B>[MANDATORY]</B>  &lt;angles&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the intermission point for the demos.<BR><B>EXAMPLE:  </B>setDemoIntermissionPoint( spawnpoint.origin, spawnpoint.angles )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetDepthOfField(<I>&lt;nearStart&gt;</I>,<I>&lt;nearEnd&gt;</I>,<I>&lt;farStart&gt;</I>,<I>&lt;farEnd&gt;</I>,<I>&lt;nearBlur&gt;</I>,<I>&lt;farBlur&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;nearStart&gt; Near start (should be greater than 0)<LI>        <B>[MANDATORY]</B>  &lt;nearEnd&gt; Near end (should be greater than 0)<LI>        <B>[MANDATORY]</B>  &lt;farStart&gt; Far start (should be greater than 0)<LI>        <B>[MANDATORY]</B>  &lt;farEnd&gt; Far end (should be greater than 0)<LI>        <B>[MANDATORY]</B>  &lt;nearBlur&gt; Near blur<LI>        <B>[MANDATORY]</B>  &lt;farBlur&gt; Far blur</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the Depth of Field.<BR><B>EXAMPLE:  </B>self SetDepthOfField( 0, 0, 512, 4000, 4, 0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetDoubleJumpEnergy(<I>&lt;energy&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;energy&gt; % energy to set on the player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets a double jump energy amount on the player<BR><B>EXAMPLE:  </B>player SetDoubleJumpEnergy( &lt;energy&gt; )<BR></OL><P>
<HR><H1>void SetDrawInfrared(<I>&lt;flag&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flag&gt; Whether to use infrared material or not (boolean)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Draw this entity using infrared material when using infrared scope.<BR><B>EXAMPLE:  </B>helicopter SetDrawInfrared( true )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetDrawName(<I>&lt;text&gt;</I>,<I>force vis Bool, alpha = full</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;text&gt; The name.<LI>        <B>[OPTIONAL]</B>  force vis Bool, alpha = full</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the drawnname of client ent<BR><B>EXAMPLE:  </B>dude SetDrawName( "dJVahn" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetDrawOwnerName(<I>&lt;bool&gt;</I>,<I>&lt;bool&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;bool&gt; Enable/Disable using the owners name.<LI>        <B>[OPTIONAL]</B>  &lt;bool&gt; Whether to always draw the name rega</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Draws the entity's owners name above the entity.<BR><B>EXAMPLE:  </B>entity SetDrawOwnerName( true, true )<BR></OL><P>
<HR><H1>void SetDvar(<I>&lt;dvar&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;dvar&gt; The dvar name as a string.<LI>        <B>[MANDATORY]</B>  &lt;value&gt; The dvar value.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the value of a dvar.<BR><B>EXAMPLE:  </B>SetDvar( "r_eyesAdjust", "1" )<BR></OL><P>
<HR><H1>void SetDynEntBodyRenderOptionsPacked(<I>dynent</I>,<I>&lt;packed render options&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  dynent<LI>        <B>[MANDATORY]</B>  &lt;packed render options&gt; Usually returned value from GetBodyRenderOptionsPacked()</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the packed value of body render options (body type, style, colors)<BR><B>EXAMPLE:  </B>SetDynEntBodyRenderOptionsPacked( gibEntity, 0 )<BR></OL><P>
<HR><H1>void SetDynEntEnabled(<I>dynent</I>,<I>[enabled]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  dynent<LI>        <B>[OPTIONAL]</B>  [enabled] 1 if dynent is enabled, 0 otherwise</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set this dyn ent to enabled or disabled.  Disabled stops the physics and hides the dyn ent.<BR><B>EXAMPLE:  </B>SetDynEntEnabled( brick, 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetElectrified(<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; Time to get electrified for ( greater than 0 )</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Electrify the entity for the given time<BR><B>EXAMPLE:  </B>self SetElectrified( 3.0 )<BR></OL><P>
<HR><H1>void SetEMPJammed(<I>&lt;isJammed&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;isJammed&gt; Whether the player should be jammed or not. ( boolean )</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether a player/client is affected by EMP<BR><B>EXAMPLE:  </B>player SetEMPJammed( true )<BR></OL><P>
<HR><H1>void SetEnableNode(<I>&lt;node&gt;</I>,<I>[truefalse]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; the node to enable/disable<LI>        <B>[OPTIONAL]</B>  [truefalse] whether it should be enabled</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Disables or enabled this node.<BR><B>EXAMPLE:  </B>SetEnableNode( node, false )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetEnemyGlobalScrambler(<I>&lt;bool&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;bool&gt; true if there is a scrabler active, false otherwise</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set to true if there is a global enemy scrambler active<BR><B>EXAMPLE:  </B>player SetEnemyGlobalScrambler( 1 )<BR></OL><P>
<HR><H1>void &lt;actor&gt; SetEnemyModel(<I>&lt;model name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;model name&gt; The name of the model to set this actor to</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the model of the actor that actors enemies will see to the given model name<BR><B>EXAMPLE:  </B>dog SetEnemyModel( "german_shepard_black" )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetEnemyScramblerAmount(<I>&lt;float&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;float&gt; Between 0.0 and 1.0</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the amount alpha of the scrambler applied to the compass<BR><B>EXAMPLE:  </B>player SetEnemyScramblerAmount( 1.0 )<BR></OL><P>
<HR><H1>void SetEntBeastModeIconType(<I>&lt;iconid&gt;</I>,<I>&lt;location&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;iconid&gt; 1 melee 2 electricity 3 grapple<LI>        <B>[OPTIONAL]</B>  &lt;location&gt; icon location</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>sets the beast mode icon shown for a particular entity<BR><B>EXAMPLE:  </B>object SetBeastModeIconMaterial( 2, object.origin )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetEntGravityTrajectory(<I>&lt;trajectory&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;trajectory&gt;  0 = TR_GRAVITY, 1 = TR_MOON_GRAVITY</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the gravity trajectory type for the entity.<BR><B>EXAMPLE:  </B>player SetEntGravityTrajectory( 0 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetEntityAnimRate(<I>&lt;rate&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;rate&gt; animation rate</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>set the entity animation rate - ZOMBIES ONLY<BR><B>EXAMPLE:  </B>self SetEntityAnimRate( 1.0 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetEntityPaused(<I>&lt;ignore&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;ignore&gt; Whether or not to advance normally.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether a given entity will advance normally.<BR><B>EXAMPLE:  </B>ent SetEntityPaused( true )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetEntityWeapon(<I>weapon name</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  weapon name</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set weapon ent field from script.<BR><B>EXAMPLE:  </B>ent SetEntityWeapon( "kniferang_mp" )<BR></OL><P>
<HR><H1>void &lt;trigger&gt; SetExcludeTeamForTrigger(<I>&lt;team name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team name&gt; The name of the team that the trigger will not respond to. Must be either 'axis', 'allies', 'team3', 'team4', 'team5', 'team6' or 'none'</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the team that this trigger will not react to. Reacts to all other teams.<BR><B>EXAMPLE:  </B>self SetExcludeTeamForTrigger( game["attackers"] )<BR></OL><P>
<HR><H1>void SetExpFog(<I>&lt;startDist&gt;</I>,<I>&lt;halfwayDist&gt;</I>,<I>&lt;red&gt;</I>,<I>&lt;green&gt;</I>,<I>&lt;blue&gt;</I>,<I>&lt;transition time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;startDist&gt; The distance, in world units, at which the fog begins.<LI>        <B>[MANDATORY]</B>  &lt;halfwayDist&gt; The distance, beyond the startDist, at which the scene will be 50% fogged.<LI>        <B>[MANDATORY]</B>  &lt;red&gt; The red component of the fog as a value between 0.0 and 1.0<LI>        <B>[MANDATORY]</B>  &lt;green&gt; The red component of the fog as a value between 0.0 and 1.0<LI>        <B>[MANDATORY]</B>  &lt;blue&gt; The red component of the fog as a value between 0.0 and 1.0<LI>        <B>[MANDATORY]</B>  &lt;transition time&gt; transition time in seconds</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Creates an exponential fog.<BR><B>EXAMPLE:  </B>SetExpFog(.0001144, 131/255, 116/255, 71/255, 0)<BR></OL><P>
<HR><H1>void SetFakeFire()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Simulates gun fire.  Sound and radar blip.<BR><B>EXAMPLE:  </B>entity SetFakeFire( &lt;enabled&gt; )<BR></OL><P>
<HR><H1>void &lt;flag&gt; SetFlagAsAway(<I>&lt;localClientNum&gt;</I>,<I>&lt;away&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client number<LI>        <B>[MANDATORY]</B>  &lt;away&gt; A value of 1 sets the flag as away, 0 sets the flag as home</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets a flag as away/home.<BR><B>EXAMPLE:  </B>flag SetFlagAsAway( localClientNum, 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetForceNoCull()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the force-no-cull flag. Entity will not be culled by portals<BR><B>EXAMPLE:  </B>helicopter SetForceNoCull()<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetForceNotSimple()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the forceNotSimple flag on the entity<BR><B>EXAMPLE:  </B>self SetForceNotSimple()<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetFOVForKillcam(<I>&lt;fov&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;fov&gt; The fov you want to use for the killcam</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the fov for use with this killcam entity.  Setting it to zero makes it use the default fov.<BR><B>EXAMPLE:  </B>killCamEnt SetFOVForKillcam( 25 )<BR></OL><P>
<HR><H1>void SetFriendlyNameDraw(<I>&lt;onOff&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;onOff&gt; True if friendly name drawing is turned on</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>turns on or off local client friendly name drawing<BR><B>EXAMPLE:  </B>SetFriendlyNameDraw( true )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetFriendlyScramblerAmount(<I>&lt;float&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;float&gt; Between 0.0 and 1.0</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the amount alpha of the friendly scrambler applied<BR><B>EXAMPLE:  </B>player SetFriendlyScramblerAmount( 1.0 )<BR></OL><P>
<HR><H1>void SetGameEndTime(<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; The time to set</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the time the current match will end<BR><B>EXAMPLE:  </B>setGameEndTime( getTime() + int(timeLeft) )<BR></OL><P>
<HR><H1>void SetGametypeSetting(<I>&lt;setting&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;setting&gt; The setting name as a string.<LI>        <B>[MANDATORY]</B>  &lt;value&gt; The new value for the setting.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the value of a gametype setting.<BR><B>EXAMPLE:  </B>SetGametypeSetting( "timeLimit", 0 )<BR></OL><P>
<HR><H1>void SetGlobalFutz(<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; The Futz name</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the global futz<BR><B>EXAMPLE:  </B>SetGlobalFutz( futz_name )<BR></OL><P>
<HR><H1>void SetGrapplableType()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set how an entity is grappled.<BR><B>EXAMPLE:  </B>platform SetGrapplableType( 1 )<BR></OL><P>
<HR><H1>void SetGravity(<I>&lt;gravity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;gravity&gt; The gravity to set</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>sets the gravity in inches per second per second.<BR><B>EXAMPLE:  </B>SetGravity( 800 )<BR></OL><P>
<HR><H1>void SetGroupSnapshot(<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; Name of the snapshot</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the group snapshot<BR><B>EXAMPLE:  </B>SetGroupSnapshot( level._sndActiveSnapshot )<BR></OL><P>
<HR><H1>void SetHealthSnapshot(<I>&lt;name&gt;</I>,<I>&lt;amount&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; The snapshot name<LI>        <B>[MANDATORY]</B>  &lt;amount&gt; The amount</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the health snapshot<BR><B>EXAMPLE:  </B>SetHealthSnapshot( sn_name, sn_amount )<BR></OL><P>
<HR><H1>void SetHideonClientWhenScriptedAnimCompleted(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>hides the entity on the client side onces its scripted animation ends<BR><B>EXAMPLE:  </B>SetHideonClientWhenScriptedAnimCompleted( ent )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetHideWhenScriptedAnimationCompleted()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>When playing a scene this will hide the entity when the scripted animation ends on it.<BR><B>EXAMPLE:  </B>entity SetHideWhenScriptedAnimationCompleted()<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetHighDetail(<I>[flag]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [flag] True or False, enabled or disabled</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enabled or Disables High Detail rendering for a model<BR><B>EXAMPLE:  </B>thing SetHighDetail( true )<BR></OL><P>
<HR><H1>void SetHintLowPriority(<I>&lt;bool&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;bool&gt; True\False if its on or off</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets this as a low priority hint which is lower priority then everything other then turrets and dropped weapons<BR><B>EXAMPLE:  </B>m_e_hack_trigger SetHintLowPriority( true )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetHintString(<I>&lt;hint string&gt;</I>,<I>[...]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;hint string&gt; The hint string that will be displayed to the player<LI>        <B>[OPTIONAL]</B>  [...] Additional arguments may be appended to the hint string</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the hint string for the entity<BR><B>EXAMPLE:  </B>t_door SetHintString( "Press and Hold ^3[{+activate}]^7 to transmit unlock code" )<BR></OL><P>
<HR><H1>void SetHintStringForPerk(<I>&lt;perk&gt;</I>,<I>&lt;hint string&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;perk&gt; The perk that the player needs to have to see this hint string<LI>        <B>[MANDATORY]</B>  &lt;hint string&gt; The hint string that will be displayed to the player that has the perk</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Shows this hint string to the player if the player has the specified perk<BR></OL><P>
<HR><H1>void SetHintStringForPlayer(<I>&lt;player&gt;</I>,<I>&lt;hint string&gt;</I>,<I>[...]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player that will see the hint string<LI>        <B>[MANDATORY]</B>  &lt;hint string&gt; The hint string that will be displayed to the player<LI>        <B>[OPTIONAL]</B>  [...] Additional arguments may be appended to the hint string in the same way as SetHintString.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the trigger hint string for one specific player<BR></OL><P>
<HR><H1>void &lt;trigger&gt; SetIgnoreEntForTrigger(<I>&lt;entity to ignore&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity to ignore&gt; The entity that will be ignored during sight trace checks</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Ignores this entity when doing trigger sight traces. Currently only works for trigger_radius_use<BR><B>EXAMPLE:  </B>self SetIgnoreEntForTrigger( camera_spike_ent )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetIgnorePauseWorld(<I>&lt;ignore&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;ignore&gt; Whether or not to advance normally when the world is paused.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether a given entity will advance normally when the world is paused.<BR><B>EXAMPLE:  </B>ent SetIgnorePauseWorld( true )<BR></OL><P>
<HR><H1>void SetIncludeMeshes(<I>&lt;enabled&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;enabled&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets a streamer hint entity to include mesh data<BR><B>EXAMPLE:  </B>self setIncludeMeshes( true )<BR></OL><P>
<HR><H1>void SetInfluenceAt(<I>&lt;influenceMapIndex&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;influence&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;influenceMapIndex&gt; Index of the influence map<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The location to set the influence value<LI>        <B>[MANDATORY]</B>  &lt;influence&gt; The influence value to set</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the influence value on the influence map, returns true/false if the value was set.<BR><B>EXAMPLE:  </B>SetInfluenceAt(influenceMapIndex, origin, influence)<BR></OL><P>
<HR><H1>void SetInfluencerTeamMask(<I>&lt;influencer id&gt;</I>,<I>&lt;team mask&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;influencer id&gt; The influencer id<LI>        <B>[MANDATORY]</B>  &lt;team mask&gt; The team mask to apply</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the team mask for the given influencer<BR><B>EXAMPLE:  </B>SetInfluencerTeamMask( influencer_id, team_mask )<BR></OL><P>
<HR><H1>void SetInfluencerTimeout(<I>&lt;influencer id&gt;</I>,<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;influencer id&gt; The influencer id<LI>        <B>[MANDATORY]</B>  &lt;time&gt; The timeout for the influencer</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the timeout for the influencer in seconds from current time<BR><B>EXAMPLE:  </B>SetInfluencerTimeout( influencer_id, 2.5 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetInfraredVision(<I>&lt;is infrared vision&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;is infrared vision&gt; Whether using infrared vision</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Switches using the infrared vision (infrared visionset and thermal characters)<BR><B>EXAMPLE:  </B>player SetInfraredVision( true )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetInfraredVisionSet(<I>&lt;visionNameInfrared&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;visionNameInfrared&gt; name of the vision set</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the vision when using infrared<BR><B>EXAMPLE:  </B>entity SetInfraredVisionSet("visionName")<BR></OL><P>
<HR><H1>void SetInitialPlayersConnected()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set initialPlayersConnected bool in match state to true<BR><B>EXAMPLE:  </B>SetInitialPlayersConnected()<BR></OL><P>
<HR><H1>void setInTacticalHud(<I>&lt;onOff&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;onOff&gt; false = off, true = on</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets if the player has the tactical hud open<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetInvisibleToAll()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set entity invisible to all players<BR><B>EXAMPLE:  </B>use_trigger SetInvisibleToAll()<BR></OL><P>
<HR><H1>void SetInvisibleToPlayer(<I>&lt;player&gt;</I>,<I>[setInvisible]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player to set the entity invisible to.<LI>        <B>[OPTIONAL]</B>  [setInvisible] True if entity has to be invisible to player. False otherwise</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Make the entity invisible to the player<BR><B>EXAMPLE:  </B>hackable._trigger SetInvisibleToPlayer( player, false )<BR></OL><P>
<HR><H1>void SetJumpHeight(<I>&lt;height_in_inches&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;height_in_inches&gt; The height to jump in inches</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the global jump height of all players.  Minimum value of 0, maximum value of 1023.<BR><B>EXAMPLE:  </B>SetJumpHeight( 100 )<BR></OL><P>
<HR><H1>void SetLevelFadeSnapshot(<I>&lt;name&gt;</I>,<I>&lt;amount&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; The snapshot name<LI>        <B>[MANDATORY]</B>  &lt;amount&gt; The level fade amount</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the level fade snapshot<BR><B>EXAMPLE:  </B>SetLevelFadeSnapshot( sn_name, sn_amount )<BR></OL><P>
<HR><H1>void &lt;light&gt; SetLightColor(<I>&lt;color&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;color&gt; An RGB vector with components in the range 0 to 1. The given values get rounded before they are stored. (vector3)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the current color of the light, as an RGB vector.<BR><B>EXAMPLE:  </B>self SetLightColor( (0.5, 0.75, 1.0) )<BR></OL><P>
<HR><H1>void &lt;light&gt; SetLightExponent(<I>&lt;exponent&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;exponent&gt; A new value for the exponent of the light. This should be an integer in the range of 0 to 100. (integer)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the current exponent of the light.<BR><B>EXAMPLE:  </B>self SetLightExponent( 1 )<BR></OL><P>
<HR><H1>void &lt;light&gt; SetLightFovRange(<I>&lt;fov_outer&gt;</I>,<I>[fov_inner]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;fov_outer&gt; A new value for the outer FOV of the light, in degrees. This cannot be larger than the fov when the map was compiled, or less than 1. (float)<LI>        <B>[OPTIONAL]</B>  [fov_inner] A new value for the inner FOV of the light, in degrees. This cannot be larger than fov_outer, or less than 0. If not specified, the map value is used. (float)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the current fov range of the light.<BR><B>EXAMPLE:  </B>self SetLightFovRange( 200, 50 )<BR></OL><P>
<HR><H1>void SetLightingOnly(<I>&lt;enabled&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;enabled&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets a streamer hint entity to only hint lighting data<BR><B>EXAMPLE:  </B>self SetLightingOnly( true )<BR></OL><P>
<HR><H1>void SetLightingState(<I>&lt;new light state&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;new light state&gt; new state to change to. Lighting state defaults to 1 at start of game</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Changes lighting state for the map<BR><B>EXAMPLE:  </B>SetLightingState( 2 )<BR></OL><P>
<HR><H1>void &lt;light&gt; SetLightIntensity(<I>&lt;intensity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;intensity&gt; A new value for the intensity of the light. 1 is fullbright, but values can be larger than 1. (float)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the current intensity of the light.<BR><B>EXAMPLE:  </B>self SetLightIntensity( 1.5 )<BR></OL><P>
<HR><H1>void &lt;light&gt; SetLightRadius(<I>&lt;radius&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;radius&gt; A new value for the radius of the light. This cannot be larger than the radius when the map was compiled. (float)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the current radius of the light.<BR><B>EXAMPLE:  </B>self SetLightRadius( 200 )<BR></OL><P>
<HR><H1>void SetLocalRadarEnabled(<I>&lt;localClientNum&gt;</I>,<I>&lt;enabled&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number to set local radar on<LI>        <B>[MANDATORY]</B>  &lt;enabled&gt; 0 if disabled, 1 if enabled</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets whether a client's local radar is enabled.<BR><B>EXAMPLE:  </B>SetLocalRadarEnabled( localClientNum, 1 )<BR></OL><P>
<HR><H1>void SetLocalRadarPosition(<I>&lt;localClientNum&gt;</I>,<I>&lt;position&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number to set local radar position on<LI>        <B>[MANDATORY]</B>  &lt;position&gt; New position of the local radar</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the position of a client's local radar.<BR><B>EXAMPLE:  </B>SetLocalRadarPosition( localClientNum, self.origin )<BR></OL><P>
<HR><H1>void SetLoopState(<I>&lt;aliasname&gt;</I>,<I>&lt;attenuation&gt;</I>,<I>&lt;pitch&gt;</I>,<I>[attenuation_rate]</I>,<I>[pitch_rate]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;aliasname&gt; The sound alias to play<LI>        <B>[MANDATORY]</B>  &lt;attenuation&gt; The desired volume attenuation<LI>        <B>[MANDATORY]</B>  &lt;pitch&gt; The desired pitch<LI>        <B>[OPTIONAL]</B>  [attenuation_rate] The desired attenuation rate<LI>        <B>[OPTIONAL]</B>  [pitch_rate] The desired pitch rate</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>set pitch and volume per entity/alias<BR><B>EXAMPLE:  </B>car SetLoopState( "peugeot_idle_low", 0.5, 1.0, 0.5, 0.2 )<BR></OL><P>
<HR><H1>void SetMapCenter(<I>&lt;mapCenter&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;mapCenter&gt; The map center</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the center of the map (used by the network code to optimize position data)<BR><B>EXAMPLE:  </B>SetMapCenter( level.mapCenter )<BR></OL><P>
<HR><H1>void SetMapLatLong(<I>&lt;mapX&gt;</I>,<I>&lt;mapY&gt;</I>,<I>&lt;longitude&gt;</I>,<I>&lt;latitude&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;mapX&gt; map X coordinate for which the longitude is given<LI>        <B>[MANDATORY]</B>  &lt;mapY&gt; map Y coordinate for which the longitude is given<LI>        <B>[MANDATORY]</B>  &lt;longitude&gt; world longitude of the given map position<LI>        <B>[MANDATORY]</B>  &lt;latitude&gt; world latitude of the given map position</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the map's real world latitude & longitude and their corresponding map coordinates.<BR><B>EXAMPLE:  </B>SetMapLatLong( 1000, 500, -118.448689, 34.021566 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetMatchFlag(<I>&lt;flag bit&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flag bit&gt; The flag bit to change<LI>        <B>[MANDATORY]</B>  &lt;value&gt; The new value of the bit</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Flags a bit in the match state<BR><B>EXAMPLE:  </B>SetMatchFlag( "bomb_timer", "1" )<BR></OL><P>
<HR><H1>void SetMatchTalkFlag(<I>&lt;flag bit&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flag bit&gt; The flag bit to change<LI>        <B>[MANDATORY]</B>  &lt;value&gt; The new value of the bit</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Flags a bit in the match talk state<BR><B>EXAMPLE:  </B>SetMatchTalkFlag( "DeadChatWithDead", "1" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetMaterialOverride(<I>&lt;surfaceName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;surfaceName&gt; The new material</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the material override<BR><B>EXAMPLE:  </B>self SetMaterialOverride("water")<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetmaxHealth(<I>&lt;health&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;health&gt; The new max health</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the max health of this entity<BR><B>EXAMPLE:  </B>self SetMaxHealth( required_amount )<BR></OL><P>
<HR><H1>void SetMiniMap(<I>&lt;material&gt;</I>,<I>&lt;upperLeftX&gt;</I>,<I>&lt;upperLeftY&gt;</I>,<I>&lt;lowerRightX&gt;</I>,<I>&lt;lowerRightY&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;material&gt; Sets the material<LI>        <B>[MANDATORY]</B>  &lt;upperLeftX&gt; Upper left X value<LI>        <B>[MANDATORY]</B>  &lt;upperLeftY&gt; Upper left Y value<LI>        <B>[MANDATORY]</B>  &lt;lowerRightX&gt; Lower right X value<LI>        <B>[MANDATORY]</B>  &lt;lowerRightY&gt; Lower right Y value</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the minimap bounds and material<BR><B>EXAMPLE:  </B>setMiniMap(material, northwest[0], northwest[1], southeast[0], southeast[1])<BR></OL><P>
<HR><H1>void &lt;missile&gt; SetMissileBrake(<I>&lt;flag&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flag&gt; True to enable or disable missile brake.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Tells a remote missile to disable brake<BR><B>EXAMPLE:  </B>missile DisableMissileBrake( true )<BR></OL><P>
<HR><H1>void &lt;missile&gt; SetMissileCoasting(<I>&lt;flag&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flag&gt; True to start coasting at reduced speed.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Tells a remote missile to start coasting at a reduced speed.<BR><B>EXAMPLE:  </B>missile SetMissileCoasting( true )<BR></OL><P>
<HR><H1>void &lt;missile&gt; SetMissileOwner(<I>player</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the missile entity owner.<BR><B>EXAMPLE:  </B>grenade SetMissileOwner( player )<BR></OL><P>
<HR><H1>void &lt;turret&gt; SetMode(<I>&lt;mode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;mode&gt; The turret mode. Possible modes are "auto_ai", "manual", "manual_ai" and "auto_nonai</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the mode of a turret.<BR><B>EXAMPLE:  </B>turret SetMode( "auto_ai" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetModel(<I>&lt;model alias&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;model alias&gt; Name of the model</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the model for the entity<BR><B>EXAMPLE:  </B>raps_meteor SetModel( "veh_t7_drone_raps" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetMoveSpeedScale(<I>&lt;speed scale multiplier&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;speed scale multiplier&gt; The speed scale multiplier (float)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the speed scale multiplier for the entity<BR><B>EXAMPLE:  </B>self SetMoveSpeedScale( HOLDING_CRATE_MOVEMENT_SPEED )<BR></OL><P>
<HR><H1>void SetMovingPlatformEnabled()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enbles the moving platfrom.<BR><B>EXAMPLE:  </B>platform SetMovingPlatformEnabled( true )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetNearestEnemyScrambler(<I>&lt;cent&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;cent&gt; scrambler centity</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the nearest enemy scrambler<BR><B>EXAMPLE:  </B>player AddEnemyScrambler( scrambler )<BR></OL><P>
<HR><H1>void SetNemesisXUID(<I>&lt;nemesisXuidString&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;nemesisXuidString&gt; The Nemesis XUID string</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the Nemesis XUID<BR><B>EXAMPLE:  </B>player setNemesisXuid( player.pers["nemesis_xuid"] )<BR></OL><P>
<HR><H1>void SetNodePriority(<I>&lt;node&gt;</I>,<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; (node) A priority allowed node.<LI>        <B>[MANDATORY]</B>  &lt;enable&gt; (boolean) True if this node is enabled.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enable or disable the priority for this node.<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetNormalHealth(<I>&lt;normal health&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;normal health&gt; Health in normalized form. Range 0 - 1</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set health of entity. Input health is normalized.<BR><B>EXAMPLE:  </B>self SetNormalHealth( 0.8 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetNoSunShadow()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the no-sunshadow flag.<BR><B>EXAMPLE:  </B>helicopter SetNoSunShadow()<BR></OL><P>
<HR><H1>void SetObjectivePointStatus(<I>&lt;objective_index&gt;</I>,<I>&lt;team&gt;</I>,<I>&lt;percent&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_index&gt; The objective index in the matchstate<LI>        <B>[MANDATORY]</B>  &lt;team&gt; The team of the objective<LI>        <B>[MANDATORY]</B>  &lt;percent&gt; Percentage completed</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Objective status set in the match state<BR><B>EXAMPLE:  </B>SetObjectivePointStatus( 1, "allies", 80 )<BR></OL><P>
<HR><H1>void &lt;turret_or_vehicle&gt; SetOnTargetAngle(<I>&lt;angle&gt;</I>,<I>[gunnerIndex]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;angle&gt; In degrees (float)<LI>        <B>[OPTIONAL]</B>  [gunnerIndex] Which gun, 0-3.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the angle range at which the turret_on_target notify will occur.<BR><B>EXAMPLE:  </B>boat SetOnTargetAngle( 0, 15 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetOwner(<I>player</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the entity owner.<BR><B>EXAMPLE:  </B>grenade SetOwner( player )<BR></OL><P>
<HR><H1>void SetPauseWorld(<I>&lt;pause&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;pause&gt; Whether or not to pause the world</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>pauses playback of animations and effects, but doesn't affect the server tick the way slomo does<BR><B>EXAMPLE:  </B>SetPauseWorld( 1 )<BR></OL><P>
<HR><H1>void &lt;trigger&gt; SetPerkForTrigger(<I>&lt;perk name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;perk name&gt; The name of the perk that the trigger will respond to.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the perk that the player must have for this trigger will react to<BR><B>EXAMPLE:  </B>self SetPerkForTrigger( "specialty_fastinteract" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetPlayerCollision(<I>&lt;on_off&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;on_off&gt; True for on and false for off</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Use to turn on off the collision with the player.<BR><B>EXAMPLE:  </B>self SetPlayerCollision( true )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetPlayerCurrentObjective(<I>&lt;objective_index&gt;</I>,<I>&lt;objective_type&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;objective_index&gt; The objective index in the matchstate<LI>        <B>[MANDATORY]</B>  &lt;objective_type&gt; Type of the objective</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the current objective information on the player<BR><B>EXAMPLE:  </B>SetPlayerCurrentObjective( "flag_a", 1 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetPlayerCurrentStreak(<I>&lt;current streak&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;current streak&gt; The current kill streak count</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the current kill streak count on the player<BR><B>EXAMPLE:  </B>SetPlayerCurrentStreak( 3 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetPlayerGravity(<I>&lt;gravity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;gravity&gt; The gravity to set</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the gravity override value for the player.<BR><B>EXAMPLE:  </B>player SetPlayerGravity( 600 )<BR></OL><P>
<HR><H1>void SetPlayerIgnoreRadiusDamage(<I>&lt;flag&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flag&gt; true to ignore radius damage, false otherwise</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the player to take or ignore radius damage<BR><B>EXAMPLE:  </B>SetPlayerIgnoreRadiusDamage( true )<BR></OL><P>
<HR><H1>void &lt;turret&gt; SetPlayerSpread(<I>&lt;spread&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;spread&gt; The spread of the turret in degrees</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the spread of this turret when used by the player<BR><B>EXAMPLE:  </B>roof_turret SetPlayerSpread( 0.2 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetPlayerStateLoadoutBonusCards(<I>&lt;custom Class&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;custom Class&gt; Class Num</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the player state to have bonus card info, for codcaster to view it<BR><B>EXAMPLE:  </B>self SetPlayerStateLoadoutBonusCards( class_num )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetPlayerStateLoadoutWeapons(<I>&lt;custom Class&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;custom Class&gt; Class Num</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the player state to have primary and secondary weapon info, for codcaster to view it<BR><B>EXAMPLE:  </B>self SetPlayerStateLoadoutWeapons( class_num )<BR></OL><P>
<HR><H1>void SetRenderInThirdPersonSpectate(<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;enable&gt; Enable or disable redering the entity in 3rd person</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>render the entity when spectated in 3rd person.<BR><B>EXAMPLE:  </B>SetRenderInThirdPersonSpectate( true )<BR></OL><P>
<HR><H1>void SetReviveHintString(<I>&lt;hint string&gt;</I>,<I>[team]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;hint string&gt; The hint string that will be displayed to the player that has the perk<LI>        <B>[OPTIONAL]</B>  [team] The team to show the hint to</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the revive hint string to show to all or to a team.<BR><B>EXAMPLE:  </B>self.revivetrigger setReviveHintString( &"GAME_BUTTON_TO_REVIVE_PLAYER", self.team )<BR></OL><P>
<HR><H1>void SetRoundsPlayed(<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;value&gt; The number of rounds played</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set rounds played in match state<BR><B>EXAMPLE:  </B>SetRoundsPlayed( game["roundsplayed"] )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetSAnim(<I>&lt;string anim name&gt;</I>,<I>&lt;int&gt;</I>,<I>[float time]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string anim name&gt; name of a SANIM asset<LI>        <B>[OPTIONAL]</B>  [string shot name] shot name of the sub animation to play, pass in &lt;int&gt; 0 to play the first one.<LI>        <B>[OPTIONAL]</B>  [float time] frame to start playing on, default is 0.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the anim shot to play on a static model<BR><B>EXAMPLE:  </B>thing SetSAnim( anim, shot, 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetScale(<I>&lt;scale&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;scale&gt; The scale factor. (float)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the model scale on a script mover.<BR><B>EXAMPLE:  </B>entity SetScale(2.0)<BR></OL><P>
<HR><H1>void &lt;turret&gt; SetScanningPitch(<I>&lt;pitch&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;pitch&gt; of the turret (up and down) in degrees.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the pitch that the turret attempts to use while scanning for enemies.<BR><B>EXAMPLE:  </B>turret SetScanningPitch( -45 )<BR></OL><P>
<HR><H1>void SetScoreboardColumns(<I>&lt;column1&gt;</I>,<I>[...]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;column1&gt; to &lt;column5&gt;<LI>        <B>[OPTIONAL]</B>  [...] More columns if needed.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the scoreboard columns.<BR><B>EXAMPLE:  </B>SetScoreboardColumns( "score", "kills", "deaths", "kdratio", "assists" )<BR></OL><P>
<HR><H1>void &lt;non_player_entity&gt; SetScriptMoverFlag(<I>&lt;flag_number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flag_number&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets flag 0-7 on the script mover ent.<BR><B>EXAMPLE:  </B>some_script_model SetScriptMoverFlag( 1 )<BR></OL><P>
<HR><H1>void SetScriptStreamBias(<I>&lt;bias&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;bias&gt; Streaming bias (0 is the highest importance)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the base importance of materials being forced from script<BR><B>EXAMPLE:  </B>setScriptStreamBias( 1.0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetSessStat(<I>&lt;stat path&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;stat path&gt; The path to the stat to set the value for.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the indicated stat<BR><B>EXAMPLE:  </B>self SetSessStat( "byteStat", 0, 12 )<BR></OL><P>
<HR><H1>void setshaderconstant(<I>&lt;localClientNum&gt;</I>,<I>&lt;index&gt;</I>,<I>&lt;x&gt;</I>,<I>&lt;y&gt;</I>,<I>&lt;z&gt;</I>,<I>&lt;w&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client for which to set the shader constant<LI>        <B>[MANDATORY]</B>  &lt;index&gt; An 0-based index that refers to a previously-mapped shader constant(see MapShaderConstant)<LI>        <B>[MANDATORY]</B>  &lt;x&gt; A float value, x component of the shader constant<LI>        <B>[MANDATORY]</B>  &lt;y&gt; A float value, y component of the shader constant<LI>        <B>[MANDATORY]</B>  &lt;z&gt; A float value, z component of the shader constant<LI>        <B>[MANDATORY]</B>  &lt;w&gt; A float value, w component of the shader constant</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the value of a previously-mapped shader constant<BR><B>EXAMPLE:  </B>ent setshaderconstant( 0, "shaderColor" , 0, 0, 0, 0)<BR></OL><P>
<HR><H1>void SetSharedViewPort(<I>&lt;mode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;mode&gt; true if shared viewport, false for independent (default splitscreen behavior)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the view mode to either shared or independent, shared combines all views into a single shared viewport, modifies the way input is handled, and places the camera into scripted camera mode (i.e. control it with script).<BR><B>EXAMPLE:  </B>SetSharedViewPort(true)<BR></OL><P>
<HR><H1>void SetShowcaseWeaponPaintshopXUID()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the showcase weapon paintshop XUID for the given local client num<BR><B>EXAMPLE:  </B>SetShowcaseWeaponPaintshopXUID( localClientNum, xuid )<BR></OL><P>
<HR><H1>void SetSkipTos(<I>&lt;skipto&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;skipto&gt; The skipto name</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set skip tos<BR><B>EXAMPLE:  </B>SetSkiptos( ToLower( skipto ) )<BR></OL><P>
<HR><H1>void SetSlowMotion(<I>&lt;startTimescale&gt;</I>,<I>[endTimescale]</I>,<I>[deltaTime]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;startTimescale&gt; The initial timescale.<LI>        <B>[OPTIONAL]</B>  [endTimescale] The final timescale. Default to 1.<LI>        <B>[OPTIONAL]</B>  [deltaTime] The time to go from start to end timescale. Default to 1. (in seconds)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>sets the current slow motion timescale interpolation.<BR><B>EXAMPLE:  </B>SetSlowMotion( 1.0, 0.25, 0.5 )<BR></OL><P>
<HR><H1>void SetSModelSAnimShot(<I>&lt;target name&gt;</I>,<I>&lt;int&gt;</I>,<I>[time]</I>,<I>[loop]</I>,<I>[append]</I>,<I>[blend]</I>,<I>[frames to blend]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target name&gt; target name of the static model or &lt;int index&gt; The index of the static model or &lt;array int indices&gt; The indices of the static models (string)<LI>        <B>[OPTIONAL]</B>  [shot name] shot name of the sub animation to play, pass in &lt;int&gt; 0 to play the first one. (string)<LI>        <B>[OPTIONAL]</B>  [time] frame to start playing on, pass in -1 to use the static model random frame, this is the default. (float)<LI>        <B>[OPTIONAL]</B>  [loop] this is unused, looping is set in the asset editor. (integer)<LI>        <B>[OPTIONAL]</B>  [append] If !0 the animation will be played after the current animation(s), any loop flags in current animations are ignored. If 0, it will replace the current and any appended animation with the current one.(integer)<LI>        <B>[OPTIONAL]</B>  [blend] If !0 new animation will blend into the new one. default is 0 (integer)<LI>        <B>[OPTIONAL]</B>  [frames to blend] If number of frames to blend over (float)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the anim shot to play on a static model<BR><B>EXAMPLE:  </B>SetSModelSAnimShot("tiny_bot_blend", "", -1, true, false, true, 5*30)<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetSonarAttachmentEnabled(<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;enable&gt; true/false</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the sonar attachment to be enabled or disabled<BR><B>EXAMPLE:  </B>entity SetSonarAttachmentEnabled(false)<BR></OL><P>
<HR><H1>void SetSoundContext(<I>&lt;type&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;type&gt; The type of context<LI>        <B>[MANDATORY]</B>  &lt;value&gt; The value for that type</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the sound context<BR><B>EXAMPLE:  </B>SetSoundContext ("ringoff_plr", "outdoor"); //for weapon decay's<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetSoundEntContext(<I>&lt;type&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;type&gt; Sound Context type<LI>        <B>[MANDATORY]</B>  &lt;value&gt; Sound Context value</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the entity sound context<BR><B>EXAMPLE:  </B>car SetSoundEntContext("type", "value")<BR></OL><P>
<HR><H1>void SetSoundPitch(<I>&lt;playbackId&gt;</I>,<I>&lt;pitch&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;playbackId&gt; The sound id<LI>        <B>[MANDATORY]</B>  &lt;pitch&gt; The new pitch</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the sound pitch<BR></OL><P>
<HR><H1>void SetSoundPitchRate(<I>&lt;playbackId&gt;</I>,<I>&lt;pitchRate&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;playbackId&gt; The sound id<LI>        <B>[MANDATORY]</B>  &lt;pitchRate&gt; The new pitch rate</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the sound pitch rate<BR></OL><P>
<HR><H1>void SetSoundVolume(<I>&lt;playbackId&gt;</I>,<I>&lt;attenuation&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;playbackId&gt; The sound id<LI>        <B>[MANDATORY]</B>  &lt;attenuation&gt; The attenuation of the sound</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the sound volume<BR></OL><P>
<HR><H1>void SetSoundVolumeRate(<I>&lt;playbackId&gt;</I>,<I>&lt;attenuationRate&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;playbackId&gt; The sound id<LI>        <B>[MANDATORY]</B>  &lt;attenuationRate&gt; The new volume rate</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the sound volume rate<BR></OL><P>
<HR><H1>void &lt;player&gt; SetSpawnClientFlag(<I>&lt;flag&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flag&gt; Flag to set</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set a flag on a client's spawn client data in the spawning system.<BR><B>EXAMPLE:  </B>player SetSpawnClientFlag( "SCDFL_DISABLE_LOGGING" )<BR></OL><P>
<HR><H1>void SetSpawnPointRandomVariation(<I>&lt;variation&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;variation&gt; random range will be [0, variation]</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Random value will be added into the spawn point weighting calculation.<BR><B>EXAMPLE:  </B>SetSpawnPointRandomVariation( 10 )<BR></OL><P>
<HR><H1>void SetSpawnPointsBaseWeight(<I>&lt;team mask&gt;</I>,<I>&lt;objective position&gt;</I>,<I>&lt;angle&gt;</I>,<I>&lt;score&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team mask&gt; teams that this command will affect<LI>        <B>[MANDATORY]</B>  &lt;objective position&gt; Position of the objective that will be used in the facing calculations<LI>        <B>[MANDATORY]</B>  &lt;angle&gt; max angle that will be accepted<LI>        <B>[MANDATORY]</B>  &lt;score&gt; additional score that will be applied</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>If the spawn point is facing the objective position then it will have an additional score applied<BR><B>EXAMPLE:  </B>SetSpawnPointsBaseWeight( team_mask, point, 30, 100 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetStableMissile(<I>&lt;flag&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flag&gt; Set to true if the stable flag should be set. False otherwise</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the stable missile flag of the entity<BR><B>EXAMPLE:  </B>self SetStableMissile( true )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetStance(<I>&lt;stance&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;stance&gt; The stance.  Possible values are 'crouch', 'prone' and 'stand'</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the stance of the player. It only works for the player.<BR><B>EXAMPLE:  </B>player SetStance( "stand" );\<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetStepTriggerSound(<I>&lt;sound alias&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;sound alias&gt; The sound name</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the sound that is triggered by steps<BR><B>EXAMPLE:  </B>trigPlayer SetStepTriggerSound(self.script_label + suffix)<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetStowedWeapon(<I>&lt;weaponName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weaponName&gt; The weapon name to attach (string).</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the stowed weapon for the player<BR><B>EXAMPLE:  </B>self SetStowedWeapon( "mp40_mp" )<BR></OL><P>
<HR><H1>void SetStreamerRequest(<I>&lt;slot&gt;</I>,<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slot&gt; Request slot<LI>        <B>[MANDATORY]</B>  &lt;name&gt; Name of the streamer hint asset</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Put a streamer hint asset into a request slot (0-7)<BR><B>EXAMPLE:  </B>setStreamerRequest(0, "apple_pie")<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetStunned(<I>&lt;stunned&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;stunned&gt; True/false stun state</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Puts the vehicle or takes the vehicle out of stun mode.  Only works for nitrous vehicles.<BR><B>EXAMPLE:  </B>vehicle SetStunned( 0, true )<BR></OL><P>
<HR><H1>void &lt;turret&gt; SetTargetEntity(<I>&lt;target&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target&gt; the turret target</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the target of this turret<BR><B>EXAMPLE:  </B>roof_turret SetTargetEntity( target )<BR></OL><P>
<HR><H1>void &lt;turret_or_vehicle&gt; SetTargetOrigin(<I>&lt;origin&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; the turret target origin</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the target origin of this turret or vehicle weapon<BR><B>EXAMPLE:  </B>roof_turret SetTargetOrigin( origin )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetTeam(<I>team</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  team</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the entity team.<BR><B>EXAMPLE:  </B>panzer SetTeam( team )<BR></OL><P>
<HR><H1>void &lt;trigger&gt; SetTeamForTrigger(<I>&lt;team name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team name&gt; The name of the team that the trigger will respond to. Must be either 'axis', 'allies', 'team3' or 'none'</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the team that this trigger will react to<BR><B>EXAMPLE:  </B>self SetTeamForTrigger( game["attackers"] )<BR></OL><P>
<HR><H1>void SetTeamReviveIcon(<I>&lt;team&gt;</I>,<I>&lt;material&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt;<LI>        <B>[MANDATORY]</B>  &lt;material&gt; The icon to use</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the revive icon used by particular teams<BR><B>EXAMPLE:  </B>SetTeamReviveIcon( "allies", "waypoint_revive_cdc_zm" )<BR></OL><P>
<HR><H1>void SetTeamSatellite(<I>&lt;team&gt;</I>,<I>&lt;availability&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; The name of a team. Must be either Must be 'axis', 'allies', 'team3' or 'none'.<LI>        <B>[MANDATORY]</B>  &lt;availability&gt; Whether the team has Satellite; defaults to false</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether a team has Spyplane or not<BR><B>EXAMPLE:  </B>SetTeamSatellite( "allies", true )<BR></OL><P>
<HR><H1>void SetTeamScore(<I>&lt;team&gt;</I>,<I>&lt;score&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; The name of a team. Must be either 'axis' or 'allies' or 'team3'.<LI>        <B>[MANDATORY]</B>  &lt;score&gt; The new team score</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set a team's score<BR><B>EXAMPLE:  </B>SetTeamScore( "allies", 100 )<BR></OL><P>
<HR><H1>void SetTeamSpyplane(<I>&lt;team&gt;</I>,<I>&lt;availability&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; The name of a team. Must be either Must be 'axis', 'allies', 'team3' or 'none'.<LI>        <B>[MANDATORY]</B>  &lt;availability&gt; Whether the team has Spyplane; defaults to false</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether a team has Spyplane or not<BR><B>EXAMPLE:  </B>SetTeamSpyplane( "allies", true )<BR></OL><P>
<HR><H1>void SetThirdPerson(<I>&lt;onOff&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;onOff&gt; set third person mode to this value</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the camera mode to third person if true<BR><B>EXAMPLE:  </B>SetThirdPerson( true )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetTmodeProvider(<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;value&gt; (int) 1-enable 0-disable</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enables (or disables) the actor to provide tmode traces to the player.<BR><B>EXAMPLE:  </B>entity SetTmodeProvider( 1 )<BR></OL><P>
<HR><H1>void SetTopDownCameraYaw(<I>&lt;yaw_angle&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;yaw_angle&gt; The yaw angle to set</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the top down camera yaw that is used in DOA to get the player controls to work correctly in bgpmove.<BR><B>EXAMPLE:  </B>SetTopDownCameraYaw( 180 )<BR></OL><P>
<HR><H1>void SetTopScorer(<I>&lt;index&gt;</I>,<I>&lt;player&gt;</I>,<I>&lt;taunt&gt;</I>,<I>&lt;gesture0&gt;</I>,<I>&lt;gesture1&gt;</I>,<I>&lt;gesture2&gt;</I>,<I>&lt;weapon&gt;</I>,<I>&lt;weapon render options&gt;</I>,<I>&lt;acvi&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;index&gt; position [0..2] of the player<LI>        <B>[MANDATORY]</B>  &lt;player&gt; player who is the top scorer<LI>        <B>[MANDATORY]</B>  &lt;taunt&gt; players selected taunt index<LI>        <B>[MANDATORY]</B>  &lt;gesture0&gt; players selected gesture type 0 index<LI>        <B>[MANDATORY]</B>  &lt;gesture1&gt; players selected gesture type 1 index<LI>        <B>[MANDATORY]</B>  &lt;gesture2&gt; players selected gesture type 2 index<LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; players weapon<LI>        <B>[OPTIONAL]</B>  &lt;weapon render options&gt; players weapon renderoptions<LI>        <B>[OPTIONAL]</B>  &lt;acvi&gt; players attachment cosmetic variant indexes</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the top scorer for the end game screen.<BR><B>EXAMPLE:  </B>SetTopScorer( 0, player, weapon, renderoptions, acvi)<BR></OL><P>
<HR><H1>void &lt;turret&gt; SetTurretAccuracy()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Currently does nothing.<BR><B>EXAMPLE:  </B>roof_turret SetTargetAccuracy()<BR></OL><P>
<HR><H1>void &lt;turret&gt; SetTurretCarried(<I>&lt;flag&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flag&gt; True if the turret is being carried</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether a turret is being carried.<BR><B>EXAMPLE:  </B>turret SetTurretCarried( true )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetTurretMinimapVisible(<I>&lt;flag&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flag&gt; True if the turret is visible on the minimap</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether a turret is visible on the minimap.<BR><B>EXAMPLE:  </B>sentry SetTurretMinimapVisible( true )<BR></OL><P>
<HR><H1>void SetTurretNode(<I>&lt;node&gt;</I>,<I>&lt;turret&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; The turret node to connect to the turret<LI>        <B>[MANDATORY]</B>  &lt;turret&gt; The turret to connect to the node</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set this turretnode to use this turret.<BR><B>EXAMPLE:  </B>SetTurretNode( node, turret )<BR></OL><P>
<HR><H1>void &lt;turret&gt; SetTurretOwner(<I>player</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the turret entity owner.<BR><B>EXAMPLE:  </B>turret SetTurretOwner( player )<BR></OL><P>
<HR><H1>void &lt;turret&gt; SetTurretSpinning(<I>&lt;onoff&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;onoff&gt; Turn it on or off (boolean)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the minigun spin for the turret on this entity. Works for vehicles also.<BR><B>EXAMPLE:  </B>roof_turret SetTurretSpinning( true )<BR></OL><P>
<HR><H1>void &lt;turret&gt; SetTurretType(<I>string, "sentry" or "tow"</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  string, "sentry" or "tow"</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the turret Type, Sentry or TOW.<BR><B>EXAMPLE:  </B>turret SetTurretType( "sentry" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetUnderwaterVisionSet(<I>&lt;visionNameUnderwater&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;visionNameUnderwater&gt; name of the vision set</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the vision when underwater<BR><B>EXAMPLE:  </B>entity SetUnderwaterVisionSet("visionName")<BR></OL><P>
<HR><H1>void SetupClientFieldAnimSpeedCallbacks()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Registers a code callback for each of the given clientfield names in a field pool.<BR><B>EXAMPLE:  </B>SetupClientFieldAnimSpeedCallbacks( "world", 1, "flag_a_owner" )<BR></OL><P>
<HR><H1>void setupclientfieldcodecallbacks()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Registers a LUI code callback for each of the given clientfield names in a field pool.<BR><B>EXAMPLE:  </B>SetupClientFieldLuiCodeCallbacks( "world", 1, "flag_a_owner" )<BR></OL><P>
<HR><H1>void SetupClientFieldLuiCodeCallbacks()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Registers a LUI code callback for each of the given clientfield names in a field pool.<BR><B>EXAMPLE:  </B>SetupClientFieldLuiCodeCallbacks( "world", 1, "flag_a_owner" )<BR></OL><P>
<HR><H1>void SetupFieldOpsKitLoadouts(<I>&lt;mapname&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;mapname&gt;  The map to load the field ops kits for</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Sets up all the field ops custom classes (using slots 6 through 9)<BR><B>EXAMPLE:  </B>SetupFieldOpsKitLoadouts( mapname )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetViewAngleResistance(<I>&lt;right arc&gt;</I>,<I>&lt;left arc&gt;</I>,<I>&lt;top arc&gt;</I>,<I>&lt;bottom arc&gt;</I>,<I>[snap to]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;right arc&gt; Angle to resist against the right plane of the view cone.<LI>        <B>[MANDATORY]</B>  &lt;left arc&gt; Angle to resist against the left plane of the view cone.<LI>        <B>[MANDATORY]</B>  &lt;top arc&gt; Angle to resist against the top plane of the view cone.<LI>        <B>[MANDATORY]</B>  &lt;bottom arc&gt; Angle to resist against the bottom plane of the view cone.<LI>        <B>[OPTIONAL]</B>  [snap to] false when the resistance will be blended to over time. True by default.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the zones in the player's view cone in which resistance will be applied in the direction of the view limit<BR><B>EXAMPLE:  </B>level.player SetViewAngleResistance( 40, 40, 20, 0, 0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetViewModelDepthOfField(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt; Start DOF ( &gt;= 0 )<LI>        <B>[MANDATORY]</B>  &lt;end&gt; End DOF ( &gt;= 0 )</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the view model depth of field of the player<BR><B>EXAMPLE:  </B>self SetViewModelDepthOfField(0,1000)<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetVisibleToAll()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Make the entity visible to all players<BR><B>EXAMPLE:  </B>trigger SetVisibleToAll()<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetVisibleToAllExceptTeam(<I>&lt;team&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; Which to teams not to show this entity too</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set self visible to all teams except the selected teams<BR><B>EXAMPLE:  </B>plane SetVisibleToAllExceptTeam( self.team )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetVisibleToPlayer(<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player to set the entity visible to.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Make the entity visible to the player<BR><B>EXAMPLE:  </B>trigger SetVisibleToPlayer( self )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetVisibleToTeam(<I>&lt;team&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; Which to show this entity to</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set self visible only to selected team<BR><B>EXAMPLE:  </B>plane SetVisibleToSquad( self.team )<BR></OL><P>
<HR><H1>void SetVisionSetForPlayer(<I>&lt;visionset name&gt;</I>,<I>[transition time]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;visionset name&gt; Vision set to transition into (string)<LI>        <B>[OPTIONAL]</B>  [transition time] How long, in seconds, to take transitioning to the new vision set if a transition is possible. Default is one second. (float)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Specify the server override visionset and the transition time into it.<BR><B>EXAMPLE:  </B>player SetVisionSetForPlayer( "mortar_thermal", 1.5 )<BR></OL><P>
<HR><H1>void SetVolFog(<I>&lt;startDist&gt;</I>,<I>&lt;halfwayDist&gt;</I>,<I>&lt;halfwayHeight&gt;</I>,<I>&lt;baseHeight&gt;</I>,<I>&lt;red&gt;</I>,<I>&lt;green&gt;</I>,<I>&lt;blue&gt;</I>,<I>&lt;transition time&gt;</I>,<I>&lt;startDist&gt;</I>,<I>&lt;halfwayDist&gt;</I>,<I>&lt;halfwayHeight&gt;</I>,<I>&lt;baseHeight&gt;</I>,<I>&lt;red&gt;</I>,<I>&lt;green&gt;</I>,<I>&lt;blue&gt;</I>,<I>&lt;fogColorScale&gt;</I>,<I>&lt;sunFogRed&gt;</I>,<I>&lt;sunFogGreen&gt;</I>,<I>&lt;sunFogBlue&gt;</I>,<I>&lt;sunFogDirX&gt;</I>,<I>&lt;sunFogDirY&gt;</I>,<I>&lt;sunFogDirZ&gt;</I>,<I>&lt;sunFogStartAng&gt;</I>,<I>&lt;sunFogEndAng&gt;</I>,<I>&lt;fog max opacity&gt;</I>,<I>&lt;transition time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;startDist&gt; The distance, in world units, at which the fog begins.<LI>        <B>[MANDATORY]</B>  &lt;halfwayDist&gt; The distance at which the scene will be 50% fogged.<LI>        <B>[MANDATORY]</B>  &lt;halfwayHeight&gt; The height at which the scene will be 50% fogged.<LI>        <B>[MANDATORY]</B>  &lt;baseHeight&gt; The ground-level Z position at which the fog will start from.<LI>        <B>[MANDATORY]</B>  &lt;red&gt; The red component of the fog as a value between 0.0 and 1.0<LI>        <B>[MANDATORY]</B>  &lt;green&gt; The green component of the fog as a value between 0.0 and 1.0<LI>        <B>[MANDATORY]</B>  &lt;blue&gt; The blue component of the fog as a value between 0.0 and 1.0<LI>        <B>[MANDATORY]</B>  &lt;transition time&gt; transition time in seconds<LI>        <B>[MANDATORY]</B>  &lt;startDist&gt; The distance, in world units, at which the fog begins.<LI>        <B>[MANDATORY]</B>  &lt;halfwayDist&gt; The distance at which the scene will be 50% fogged.<LI>        <B>[MANDATORY]</B>  &lt;halfwayHeight&gt; The height at which the scene will be 50% fogged.<LI>        <B>[MANDATORY]</B>  &lt;baseHeight&gt; The ground-level Z position at which the fog will start from.<LI>        <B>[MANDATORY]</B>  &lt;red&gt; The red component of the fog as a value between 0.0 and 1.0<LI>        <B>[MANDATORY]</B>  &lt;green&gt; The green component of the fog as a value between 0.0 and 1.0<LI>        <B>[MANDATORY]</B>  &lt;blue&gt; The blue component of the fog as a value between 0.0 and 1.0<LI>        <B>[MANDATORY]</B>  &lt;fogColorScale&gt; The scaler for the colors as a value between 1 and 10000.0<LI>        <B>[MANDATORY]</B>  &lt;sunFogRed&gt; The red component of the fog as a value between 0.0 and 1.0<LI>        <B>[MANDATORY]</B>  &lt;sunFogGreen&gt; The green component of the fog as a value between 0.0 and 1.0<LI>        <B>[MANDATORY]</B>  &lt;sunFogBlue&gt; The blue component of the fog as a value between 0.0 and 1.0<LI>        <B>[MANDATORY]</B>  &lt;sunFogDirX&gt; The X component of the fog direction as a value between -1.0 and 1.0<LI>        <B>[MANDATORY]</B>  &lt;sunFogDirY&gt; The Y component of the fog direction as a value between -1.0 and 1.0<LI>        <B>[MANDATORY]</B>  &lt;sunFogDirZ&gt; The Z component of the fog direction as a value between -1.0 and 1.0<LI>        <B>[MANDATORY]</B>  &lt;sunFogStartAng&gt; The starting angle of the sun fog as a value between 0 and 180<LI>        <B>[MANDATORY]</B>  &lt;sunFogEndAng&gt; The ending angle of the sun fog as a value between 0 and 180<LI>        <B>[MANDATORY]</B>  &lt;fog max opacity&gt; The maximum opacity of the fog as a value between 0 and 1<LI>        <B>[MANDATORY]</B>  &lt;transition time&gt; transition time in seconds</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Creates an exponential fog.<BR><B>EXAMPLE:  </B>SetVolFog(0.0001144, 0.01, 131/255, 116/255, 71/255, 0)<BR></OL><P>
<HR><H1>void SetVoteNoCount(<I>&lt;no count&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;no count&gt; Number of 'no' votes</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the number of No votes<BR></OL><P>
<HR><H1>void SetVoteString(<I>&lt;string&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string&gt; The vote string</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the string for a vote<BR></OL><P>
<HR><H1>void SetVoteTime(<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; The vote time in ms</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the start time for a vote<BR></OL><P>
<HR><H1>void SetVoteYesCount(<I>&lt;no count&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;no count&gt; Number of 'yes' votes</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the number of Yes votes<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetWaterDisturbanceParams(<I>&lt;force&gt;</I>,<I>&lt;length&gt;</I>,<I>&lt;width&gt;</I>,<I>&lt;damping&gt;</I>,<I>&lt;angle&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;force&gt; The force of the disturbance influences the height and size of the wave<LI>        <B>[MANDATORY]</B>  &lt;length&gt; How long the wave is in the direction of travel<LI>        <B>[MANDATORY]</B>  &lt;width&gt; How wide the wave is (across direction of travel)<LI>        <B>[MANDATORY]</B>  &lt;damping&gt; How much the wave damps the water after it travels; larger values (&gt;1) will cause the wave to leave very little wake, smaller values will leave lots of disturbance behind the wave.  Keep &gt; 0.<LI>        <B>[MANDATORY]</B>  &lt;angle&gt; The angle of the surge line in degrees; 0 -&gt; +X</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets parameters describing the water disturbance created by the (script mover) entity<BR><B>EXAMPLE:  </B>self SetWaterDisturbanceParams( 0.5, 500, 1500, 0.2, 70 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetWaterDrops(<I>&lt;count&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;count&gt; Number of water drops (should be &gt;= 0)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets water drops equal to the count<BR><B>EXAMPLE:  </B>self SetWaterDrops( 3 )<BR></OL><P>
<HR><H1>void SetWaveWaterEnabled(<I>&lt;water name&gt;</I>,<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;water name&gt; The name of the water affected, or empty string for all<LI>        <B>[MANDATORY]</B>  &lt;enable&gt; whether water should be visible</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Makes a water completely appear or disappear<BR><B>EXAMPLE:  </B>SetWaveWaterEnabled( "huge_lake", true )<BR></OL><P>
<HR><H1>void SetWaveWaterGeneratorAmplitude(<I>&lt;generator name&gt;</I>,<I>&lt;amplitude&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;generator name&gt; The generator name<LI>        <B>[MANDATORY]</B>  &lt;amplitude&gt; The amplitude for the generator</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the wave water amplitude of the generator.<BR><B>EXAMPLE:  </B>SetWaveWaterGeneratorAmplitude( "exampleGenerator", 1.1 )<BR></OL><P>
<HR><H1>void SetWaveWaterHeight(<I>&lt;water name&gt;</I>,<I>&lt;height&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;water name&gt; The name of the water affected, or empty string for all<LI>        <B>[MANDATORY]</B>  &lt;height&gt; The new height value in world coordinates</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the height of one or all waters in a level<BR><B>EXAMPLE:  </B>SetWaveWaterHeight( "huge_lake", 15.0 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetWeapon(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to set</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the weapon of the entity. The entity should not be a player<BR><B>EXAMPLE:  </B>killcamEnt SetWeapon( self.weapon )<BR></OL><P>
<HR><H1>void SetWeaponCosts(<I>&lt;local client num&gt;</I>,<I>&lt;weapon&gt;</I>,<I>&lt;weaponCost&gt;</I>,<I>&lt;ammoCost&gt;</I>,<I>&lt;playerAmmoCost&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;local client num&gt; The local client num<LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to add<LI>        <B>[MANDATORY]</B>  &lt;weaponCost&gt; Cost to buy the weapon<LI>        <B>[MANDATORY]</B>  &lt;ammoCost&gt; Cost to buy ammo<LI>        <B>[MANDATORY]</B>  &lt;playerAmmoCost&gt; Cost to buy ammo through secret shopper</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the cost of a weapon for use by prompts<BR><B>EXAMPLE:  </B>SetWeaponCosts( weapon, weapon.cost, weapon.ammoCost, weapon.secretshopperCost )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetWeaponOptions(<I>&lt;weaponOptions&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weaponOptions&gt; The weapon options to set</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the previously calculated weapon options of the entity. The entity should not be a player<BR><B>EXAMPLE:  </B>killcamEnt SetWeaponOptions( weapon_options )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetWeaponRenderOptions(<I>&lt;camo index&gt;</I>,<I>&lt;reticle index&gt;</I>,<I>&lt;show player tag&gt;</I>,<I>&lt;show emblem&gt;</I>,<I>&lt;show paintshop&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;camo index&gt;<LI>        <B>[MANDATORY]</B>  &lt;reticle index&gt;<LI>        <B>[MANDATORY]</B>  &lt;show player tag&gt;<LI>        <B>[MANDATORY]</B>  &lt;show emblem&gt;<LI>        <B>[MANDATORY]</B>  &lt;show paintshop&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the weapon render options in the entity.<BR><B>EXAMPLE:  </B>level.weapon_clientscript_model SetWeaponRenderOptions( level.camo_index, level.reticle_index, level.show_player_tag, level.show_emblem, level.show_paintshop )<BR></OL><P>
<HR><H1>void SetWinningPlayer(<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player to set as the winning player</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets a player to be the winner<BR></OL><P>
<HR><H1>void SetWinningTeam(<I>&lt;team&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; The team name of the winning team. Must be 'axis', 'allies' or 'none'</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets a team to be the winner<BR></OL><P>
<HR><H1>void &lt;client&gt; SetWorldFogActiveBank(<I>&lt;bankMask&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;bankMask&gt; Active bank</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets world fog volumes active bank mask.<BR><B>EXAMPLE:  </B>self setworldfogactivebank(1)<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetZBarrierColModel(<I>&lt;model&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;model&gt; The model.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the collision model for a zbarrier.<BR><B>EXAMPLE:  </B>ent SetZBarrierColModel("p6_anim_zm_barricade_board_collision")<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetZBarrierPieceState(<I>&lt;piece number&gt;</I>,<I>&lt;state&gt;</I>,<I>[animation scalar]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;piece number&gt; The piece index.<LI>        <B>[MANDATORY]</B>  &lt;state&gt; State to set - valid states are open, opening, closed and closing.<LI>        <B>[OPTIONAL]</B>  [animation scalar] Valid range 0.1 - 2.0, changes the playback speed of the animation in the set state - numbers less than 1.0 are faster.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set's the state of the piece indexed in the zbarrier ent. States are open, opening, closed and closing.<BR><B>EXAMPLE:  </B>ent SetZBarrierPieceState(1, "open", 0.8)<BR></OL><P>
<HR><H1>void &lt;actor&gt; SetZombieName()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set this actors name<BR><B>EXAMPLE:  </B>guy SetZombieName( "zombie11" )<BR></OL><P>
<HR><H1>void ShellShock(<I>&lt;shellshockname&gt;</I>,<I>&lt;duration&gt;</I>,<I>[allowReduceShellShockPerk]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;shellshockname&gt;<LI>        <B>[MANDATORY]</B>  &lt;duration&gt; duration in seconds. The duration must be between 0 and 60 seconds.<LI>        <B>[OPTIONAL]</B>  [allowReduceShellShockPerk] true if shell shock perk should be reduced</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Start a shell shock sequence for the entity for given duration.<BR><B>EXAMPLE:  </B>self shellShock( "frag_grenade_mp", 0.2 )<BR></OL><P>
<HR><H1>void &lt;turret&gt; ShootTurret()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Shoots a turret<BR><B>EXAMPLE:  </B>roof_turret ShootTurret()<BR></OL><P>
<HR><H1>void ShootUp(<I>&lt;float&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;float&gt; upwards velocity</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gives an entity vertical movement<BR><B>EXAMPLE:  </B>betty ShootUp( 350 )<BR></OL><P>
<HR><H1>void &lt;player&gt; ShouldDoInitialWeaponRaise(<I>&lt;weapon&gt;</I>,<I>&lt;bool shouldDoRaise&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to set the first raise anim state for<LI>        <B>[MANDATORY]</B>  &lt;bool shouldDoRaise&gt; Whether the weapon should do the initial raise</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set weaponstate to force or prevent first raise animation the next time the player switches to it. Only works if the player currently has it<BR><B>EXAMPLE:  </B>old_state = self ShouldDoInitialWeaponRaise( "ak47", false )<BR></OL><P>
<HR><H1>void &lt;entity&gt; Show()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Show the entity<BR><B>EXAMPLE:  </B>self Show()<BR></OL><P>
<HR><H1>void &lt;entity&gt; ShowAllParts()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Show all parts of an entity.<BR><B>EXAMPLE:  </B>self ShowAllParts()<BR></OL><P>
<HR><H1>void ShowInfoVolume(<I>&lt;entnum&gt;</I>,<I>[rgb color]</I>,<I>[alpha]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entnum&gt; The entity number of the info volume<LI>        <B>[OPTIONAL]</B>  [rgb color] The rgb color that the info volume will be drawn with<LI>        <B>[OPTIONAL]</B>  [alpha] The alpha that the info volume will be drawn with</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enables an info volume to be drawn with the specified color<BR><B>EXAMPLE:  </B>InfoVolumeDebug_ShowVolume( info_volume GetEntityNumber(), ( 0.2, 0.2, 0.5 ), 0.5 )<BR></OL><P>
<HR><H1>void ShowMiscModels(<I>&lt;targetname&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;targetname&gt; targetname of misc model(s).</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Show all misc models with this targetname<BR><B>EXAMPLE:  </B>ShowMiscModels( "crash_destruct" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; ShowPart(<I>&lt;tagname&gt;</I>,<I>[modelname]</I>,<I>[bApplyToChildren]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;tagname&gt; The tag to show. All surfaces with a vertex weighted to the tag will be shown. (string)<LI>        <B>[OPTIONAL]</B>  [modelname] The optional model name to help specify the part location. (string)<LI>        <B>[OPTIONAL]</B>  [bApplyToChildren] Optional flag to specify if we should apply the operation to children bones as well. (boolean)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Show part of an entity.<BR><B>EXAMPLE:  </B>self ShowPart( "tag_weapon", "weapon_saw" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; ShowToPlayer(<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player to show the entity to.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Show the entity to a given client<BR></OL><P>
<HR><H1>void &lt;entity&gt; ShowToTeam(<I>&lt;team&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; The team to show the entity to.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Show the entity to a particular team<BR><B>EXAMPLE:  </B>self ShowToTeam( team )<BR></OL><P>
<HR><H1>void &lt;entity&gt; ShowZBarrierPiece(<I>&lt;piece number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;piece number&gt; The piece index.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Allows the indexed piece to be drawn.<BR><B>EXAMPLE:  </B>ent ShowZBarrierPiece(1)<BR></OL><P>
<HR><H1>void &lt;entity&gt; SiegeCmd(<I>&lt;string cmd&gt;</I>,<I>[string cmd]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string cmd&gt; cmd to execute.<LI>        <B>[OPTIONAL]</B>  [string cmd] more cmd's...</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Apply a number of anim commands on a siege model<BR><B>EXAMPLE:  </B>thing SiegeCmd( "set_shot", "myshot", "unpause<BR></OL><P>
<HR><H1>void &lt;entity&gt; SightConeTrace(<I>&lt;sight position&gt;</I>,<I>[ignore entity]</I>,<I>&lt;sight position&gt;</I>,<I>[cone angle]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;sight position&gt; The point the sight starts at<LI>        <B>[OPTIONAL]</B>  [ignore entity] An entity to ignore when doing the traces<LI>        <B>[OPTIONAL]</B>  [cone forward] The forward direction of the cone, whose base is at the &lt;sight position&gt;.  Must be normalized.<LI>        <B>[OPTIONAL]</B>  [cone angle] Angle in degrees from the line of sight to the edge of the cone.  Defaults to 65.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Determines how much the entity can be seen from the given position, using the same check that is used by grenades. Performs multiple sight traces and returns an approximation to how much of the entity is visible from the given point (between 0 and 1). In SinglePlayer this will always be 1 if the entity is partially visible.<BR><B>EXAMPLE:  </B>tankVisibilityFraction = tank SightConeTrace( player.origin, player, player.angles, 65)<BR></OL><P>
<HR><H1>void SightTracePassed(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>,<I>&lt;hit characters&gt;</I>,<I>&lt;ignore entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt; The bullet start point<LI>        <B>[MANDATORY]</B>  &lt;end&gt; The bullet end point<LI>        <B>[MANDATORY]</B>  &lt;hit characters&gt; An entity to ignore<LI>        <B>[MANDATORY]</B>  &lt;ignore entity&gt; An entity to ignore</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Does a sight trace from start to end. Returns true if doesnt hit anything<BR><B>EXAMPLE:  </B>passed = SightTracePassed( player.origin + ( 0, 0, 64 ), self.origin + ( 0, 0, 64 ), false, undefined )<BR></OL><P>
<HR><H1>void SModelAnimCmd(<I>&lt;target&gt;</I>,<I>&lt;cmd&gt;</I>,<I>[cmd]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target&gt; target name of the static model or &lt;int index&gt; The index of the static model or &lt;array int indices&gt; The indices of the static models (string)<LI>        <B>[MANDATORY]</B>  &lt;cmd&gt; cmd to execute. (string)<LI>        <B>[OPTIONAL]</B>  [cmd] more cmd's... (string)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Apply a number of anim commands on a siege model<BR><B>EXAMPLE:  </B>SModelAnimCmd("targetName","pause")<BR></OL><P>
<HR><H1>void SnapshotAcknowledged(<I>&lt;array&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;array&gt; The array returned by GetSnapshotIndexArray.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns 1 if all clients have acknowledged the snapshot or the timeout has expired. Otherwise returns undefined.<BR><B>EXAMPLE:  </B>acked = SnapshotAcknowledged( snapindices )<BR></OL><P>
<HR><H1>void &lt;ent&gt; Solid()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the solid flag, so that this object is collidable.<BR><B>EXAMPLE:  </B>self Solid()<BR></OL><P>
<HR><H1>void SoundExists(<I>&lt;soundName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;soundName&gt; The sound alias</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the given sound exists<BR><B>EXAMPLE:  </B>if( SoundExists( soundAlias )) { //do something }<BR></OL><P>
<HR><H1>void SoundGetAlias(<I>&lt;soundId&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;soundId&gt; the hashed sound id of the alias</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>The the string alias of a sound from the hashed sound id. Will return undefined if no sound is found<BR><B>EXAMPLE:  </B>soundAlias =  SoundGetAlias( soundId )<BR></OL><P>
<HR><H1>void SoundGetPlaybackTime(<I>&lt;soundName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;soundName&gt; The sound alias</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the playback time for the sound<BR><B>EXAMPLE:  </B>playbackTime = SoundGetPlaybackTime( "evt_infection_record_oneshot" )<BR></OL><P>
<HR><H1>void SoundLineEmitter(<I>&lt;alias&gt;</I>,<I>&lt;origin 1&gt;</I>,<I>&lt;origin 2&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;alias&gt; The sound alias name<LI>        <B>[MANDATORY]</B>  &lt;origin 1&gt; start point<LI>        <B>[MANDATORY]</B>  &lt;origin 2&gt; end point</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Play a sound from start point to end point<BR><B>EXAMPLE:  </B>SoundLineEmitter( "wpn_micro_turret_loop", start, end )<BR></OL><P>
<HR><H1>void SoundLoopEmitter(<I>&lt;alias&gt;</I>,<I>&lt;position&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;alias&gt; The sound alias name<LI>        <B>[MANDATORY]</B>  &lt;position&gt; The position to play sound at</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Play a sound loop at the position<BR><B>EXAMPLE:  </B>SoundLoopEmitter("evt_beacon_loop_red", self.origin)<BR></OL><P>
<HR><H1>void SoundPlayAutoFX(<I>&lt;fxid&gt;</I>,<I>&lt;alias&gt;</I>,<I>[offsetx]</I>,<I>[offsety]</I>,<I>[offset]</I>,<I>[onground]</I>,<I>[area]</I>,<I>[threshold]</I>,<I>[alias_override]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;fxid&gt; The ID of the FX you want to play alias off.<LI>        <B>[MANDATORY]</B>  &lt;alias&gt; Audio alias.<LI>        <B>[OPTIONAL]</B>  [offsetx] Offset x from effect origin to play the sound.<LI>        <B>[OPTIONAL]</B>  [offsety] Offset y from effect origin to play the sound.<LI>        <B>[OPTIONAL]</B>  [offset] Offset z from effect origin to play the sound.<LI>        <B>[OPTIONAL]</B>  [onground] Do a trace to ground to ensure audio is played above ground.<LI>        <B>[OPTIONAL]</B>  [area] If #threshold multiple effects of same id in target radius #area, play alias_override at center of fx instead.<LI>        <B>[OPTIONAL]</B>  [threshold] If #threshold multiple effects of same id in target radius #area, play alias_override at center of fx instead.<LI>        <B>[OPTIONAL]</B>  [alias_override] If #threshold multiple effects of same id in target radius #area, play alias_override at center of fx instead.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>This function is used to play audio on createfx ents.<BR><B>EXAMPLE:  </B>SoundPlayAutoFX( "fx_fire_barrel", "amb_fire_small", 5, -10, 5, false, 20, 5, "amb_fire_large" )<BR></OL><P>
<HR><H1>void SoundPlaying(<I>&lt;playbackId&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;playbackId&gt; The sound  id</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if the sound given by sound id is playing<BR><B>EXAMPLE:  </B>while( soundplaying( soundId ) )<BR></OL><P>
<HR><H1>void SoundRattle(<I>&lt;origin&gt;</I>,<I>&lt;minDist&gt;</I>,<I>[maxDist]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The position<LI>        <B>[MANDATORY]</B>  &lt;minDist&gt; The min distance to play sound<LI>        <B>[OPTIONAL]</B>  [maxDist] The max distance to play sound</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the rattle sound's origin, min distance and max distance<BR><B>EXAMPLE:  </B>soundrattle(origin,min,max)<BR></OL><P>
<HR><H1>void SoundRattleSetup(<I>&lt;alias&gt;</I>,<I>&lt;position&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;alias&gt; The sound alias name<LI>        <B>[MANDATORY]</B>  &lt;position&gt; The position to play sound at</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Play a rattle sound at the position<BR><B>EXAMPLE:  </B>SoundRattleSetup(rattles[i].script_sound, rattles[i].origin)<BR></OL><P>
<HR><H1>void SoundSetMusicState(<I>&lt;state id&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;state id&gt; The state identifier</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the music state for the sound<BR><B>EXAMPLE:  </B>SoundSetMusicState( state_id )<BR></OL><P>
<HR><H1>void SoundStopLineEmitter(<I>&lt;alias&gt;</I>,<I>&lt;origin 1&gt;</I>,<I>&lt;origin 2&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;alias&gt; The sound alias name<LI>        <B>[MANDATORY]</B>  &lt;origin 1&gt; start point<LI>        <B>[MANDATORY]</B>  &lt;origin 2&gt; end point</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Stops the sound playing from start point to end point<BR><B>EXAMPLE:  </B>SoundStopLineEmitter( "wpn_micro_turret_loop", start, end )<BR></OL><P>
<HR><H1>void SoundStopLoopEmitter(<I>&lt;alias&gt;</I>,<I>&lt;position&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;alias&gt; The sound alias name<LI>        <B>[MANDATORY]</B>  &lt;position&gt; The position</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Stop the sound loop emitter at the position<BR><B>EXAMPLE:  </B>SoundStopLoopEmitter("evt_beacon_loop_green", self.origin)<BR></OL><P>
<HR><H1>void SoundTimeScale(<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; The new time scale</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the sound time scale<BR><B>EXAMPLE:  </B>SoundTimeScale( 1.1 )<BR></OL><P>
<HR><H1>void SoundUpdateLineEmitter(<I>&lt;alias&gt;</I>,<I>&lt;previous origin 1&gt;</I>,<I>&lt;previous origin 2&gt;</I>,<I>&lt;origin 1&gt;</I>,<I>&lt;origin 2&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;alias&gt; The sound alias name<LI>        <B>[MANDATORY]</B>  &lt;previous origin 1&gt; start point<LI>        <B>[MANDATORY]</B>  &lt;previous origin 2&gt; end point<LI>        <B>[MANDATORY]</B>  &lt;origin 1&gt; start point<LI>        <B>[MANDATORY]</B>  &lt;origin 2&gt; end point</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Updates the sound playing from previous start point to previous end point<BR><B>EXAMPLE:  </B>SoundUpdateLineEmitter( "wpn_micro_turret_loop", previousStart, previousEnd, start, end )<BR></OL><P>
<HR><H1>entity Spawn(<I>&lt;classname&gt;</I>,<I>&lt;origin&gt;</I>,<I>[spawnflags]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;classname&gt; The classname of the entity to spawn<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The position to spawn at<LI>        <B>[OPTIONAL]</B>  [spawnflags] Optional spawn flags (up to 5)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Spawn an entity.<BR><B>EXAMPLE:  </B>Spawn( "trigger_radius", trigger_origin )<BR></OL><P>
<HR><H1>entity SpawnActor(<I>&lt;AIType&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;angles&gt;</I>,<I>[targetname]</I>,<I>[forcespawn]</I>,<I>[fullyaware]</I>,<I>[spawnerEnt]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;AIType&gt; AI type (constant string)<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The position of the vehicle (vector)<LI>        <B>[MANDATORY]</B>  &lt;angles&gt; The angle to spawn the vehicle at (vector)<LI>        <B>[OPTIONAL]</B>  [targetname] sets the targetname of the spawned entity<LI>        <B>[OPTIONAL]</B>  [forcespawn] forces a guy to spawn even if the spawn may be visible to the player<LI>        <B>[OPTIONAL]</B>  [fullyaware] gives the AI full awareness of all enemies<LI>        <B>[OPTIONAL]</B>  [spawnerEnt] if passed in, then the fields of the spawnerEnt will be duplicated to the newly spawned actor</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Spawns an actor from an actor spawner, if possible (the spawner won't spawn if the player is looking at the spawn point, or if spawning would cause a telefrag)<BR><B>EXAMPLE:  </B>spawned = SpawnActor( "spawner_bo3_soldier_ally_sniper_tool", origin, angles, "george", false )<BR></OL><P>
<HR><H1>entity SpawnCollision(<I>&lt;modelname&gt;</I>,<I>&lt;targetname&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;angles&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;modelname&gt; The name of the model to spawn (constant string)<LI>        <B>[MANDATORY]</B>  &lt;targetname&gt; target name (constant string)<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The position of the collision (vector)<LI>        <B>[MANDATORY]</B>  &lt;angles&gt; The angle to spawn the collision at (vector)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Spawns a script mover thats used only for collision<BR></OL><P>
<HR><H1>void spawndynent(<I>&lt;model&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;angles&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;model&gt; The model of the dynent<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The position<LI>        <B>[MANDATORY]</B>  &lt;angles&gt; The angles</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Spawn a dynent<BR><B>EXAMPLE:  </B>twig = spawndynent( "trashcan", origin, angles )<BR></OL><P>
<HR><H1>entity &lt;actor_or_vehicle_spawner&gt; SpawnFromSpawner(<I>[targetname]</I>,<I>[forcespawn]</I>,<I>[makeroom]</I>,<I>[infinitespawn]</I>,<I>[classnameOverride]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [targetname] sets the targetname of the spawned entity<LI>        <B>[OPTIONAL]</B>  [forcespawn] forces a guy to spawn even if the spawn may be visible to the player<LI>        <B>[OPTIONAL]</B>  [makeroom] will remove an undeletable entity if necessary to spawn a new one<LI>        <B>[OPTIONAL]</B>  [infinitespawn] don't increment the spawn count<LI>        <B>[OPTIONAL]</B>  [classnameOverride] override the spawner's classname</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Spawns an actor or vehicle from a spawner, if possible (the spawner won't spawn if the player is looking at the spawn point, or if spawning would cause a telefrag) Unsupplied optional fields will use flag values from the entity<BR><B>EXAMPLE:  </B>spawned = spawnerent SpawnFromSpawner( "george", false )<BR></OL><P>
<HR><H1>entity SpawnFX(<I>&lt;fx name&gt;</I>,<I>&lt;position&gt;</I>,<I>[forward]</I>,<I>[up]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;fx name&gt; Name of the fx. Fx has to be cached<LI>        <B>[MANDATORY]</B>  &lt;position&gt; Position to play the fx at<LI>        <B>[OPTIONAL]</B>  [forward] The forward vector of the fx<LI>        <B>[OPTIONAL]</B>  [up] The up vector of the fx</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Spawn an FX<BR><B>EXAMPLE:  </B>fx = SpawnFx( level._effect[player.light_playFX], monkey.origin + (0,0,-12),(1,0,0),(0,0,1) )<BR></OL><P>
<HR><H1>entity SpawnHelicopter(<I>&lt;owner&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;angles&gt;</I>,<I>&lt;vehicle name&gt;</I>,<I>&lt;model name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;owner&gt; the owner entity<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; the location<LI>        <B>[MANDATORY]</B>  &lt;angles&gt; the angles<LI>        <B>[MANDATORY]</B>  &lt;vehicle name&gt; the vehicle name<LI>        <B>[MANDATORY]</B>  &lt;model name&gt; the model name</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Spawns a helicopter<BR><B>EXAMPLE:  </B>heliGuard = spawnHelicopter( self, startPos, startAng, "heli_guard_mp" , "veh_t6_drone_overwatch_light" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SpawnNapalmGroundFlame(<I>&lt;origin&gt;</I>,<I>&lt;weapon&gt;</I>,<I>&lt;direction&gt;</I>,<I>[time]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The origin of the flame<LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon<LI>        <B>[MANDATORY]</B>  &lt;direction&gt; The direction of the flame<LI>        <B>[OPTIONAL]</B>  [time] The time to live</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Spawn a napalm ground flame at the origin with the direction.<BR><B>EXAMPLE:  </B>self SpawnNapalmGroundFlame( bot_pos , weapon, forward)<BR></OL><P>
<HR><H1>pathnode SpawnPathNode(<I>&lt;classname&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;angles&gt;</I>,<I>[key1]</I>,<I>[value1]</I>,<I>[key2]</I>,<I>[value2]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;classname&gt; The class name<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The origin<LI>        <B>[MANDATORY]</B>  &lt;angles&gt; The view angles<LI>        <B>[OPTIONAL]</B>  [key1] Key 1<LI>        <B>[OPTIONAL]</B>  [value1] Value for key 1<LI>        <B>[OPTIONAL]</B>  [key2] Key 2<LI>        <B>[OPTIONAL]</B>  [value2] Value for key 2</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Spawn a dynamically created path node or cover node<BR><B>EXAMPLE:  </B>node = SpawnPathNode( cover_left, origin, angles )<BR></OL><P>
<HR><H1>entity SpawnPlane(<I>&lt;player&gt;</I>,<I>&lt;classname&gt;</I>,<I>&lt;origin&gt;</I>,<I>[spawnflags]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; the owner<LI>        <B>[MANDATORY]</B>  &lt;classname&gt; class of entity<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; location to spawn at<LI>        <B>[OPTIONAL]</B>  [spawnflags] optional spawn flags</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Spawns a plane at the origin<BR><B>EXAMPLE:  </B>plane = spawnplane( owner, "script_model", origin )<BR></OL><P>
<HR><H1>void SpawnStruct()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR></OL><P>
<HR><H1>entity SpawnTimedFX(<I>&lt;weapon&gt;</I>,<I>&lt;origin&gt;</I>,<I>[direction&gt; default (0,0,1)</I>,<I>[time]</I>,<I>[team]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; weapon to spawn fx on<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; the position to spawn fx at<LI>        <B>[OPTIONAL]</B>  [direction&gt; default (0,0,1)<LI>        <B>[OPTIONAL]</B>  [time] default 10 seconds<LI>        <B>[OPTIONAL]</B>  [team] defaults to TEAM_FREE</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Spawns a broadcast entity that plays an oriented timed FX using the weapon's property projExplosionEffect<BR><B>EXAMPLE:  </B>ent = SpawnTimedFX( smokeGrenade, position, directionUp, duration )<BR></OL><P>
<HR><H1>void SpawnTurret()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Unsupported function. Do not use.<BR></OL><P>
<HR><H1>entity SpawnVehicle(<I>&lt;vehicletype&gt;</I>,<I>&lt;origin&gt;</I>,<I>&lt;angles&gt;</I>,<I>[targetname]</I>,<I>[destructibledef]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;vehicletype&gt; vehicle type (constant string)<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The position of the vehicle (vector)<LI>        <B>[MANDATORY]</B>  &lt;angles&gt; The angle to spawn the vehicle at (vector)<LI>        <B>[OPTIONAL]</B>  [targetname] vehicle target name (constant string)<LI>        <B>[OPTIONAL]</B>  [destructibledef] The destructibledef to use to make this vehicle a destructible</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Spawns a new vehicle and returns a reference to it<BR></OL><P>
<HR><H1>void StartBinocs(<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Start Binoculars on player<BR><B>EXAMPLE:  </B>player StartBinocs()<BR></OL><P>
<HR><H1>void &lt;entity&gt; StartFadingBlur(<I>&lt;blur_amount&gt;</I>,<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;blur_amount&gt; The initial blur amount. The value is pixels for Gaussian blur at 640x480. Must be a floating point value greater than 0.<LI>        <B>[MANDATORY]</B>  &lt;time&gt; Time in seconds, how long the fade out will take</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Blurs the screen, then fades out the blur to 0, over a period of time.<BR><B>EXAMPLE:  </B>player StartFadingBlur( 3, 2 )<BR></OL><P>
<HR><H1>void &lt;turret&gt; StartFiring()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Starts a turret firing<BR><B>EXAMPLE:  </B>turret StartFiring()<BR></OL><P>
<HR><H1>void StartMission(<I>&lt;mission_index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;mission_index&gt; index of the mission name to start - mission names can be retrieved by calling GetMissions to return the available mission array</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Start the (server side) mission script for the specified mission - all loading (on all clients) should be completed before calling - use client side LoadMission to load missions<BR><B>EXAMPLE:  </B>StartMission()<BR></OL><P>
<HR><H1>void StartPoisoning(<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Start poisoning player<BR><B>EXAMPLE:  </B>player StartPoisoning()<BR></OL><P>
<HR><H1>void &lt;player_or_playercorpse&gt; StartRagdoll(<I>[immediate]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [immediate] Start the ragdoll immediately and don't do the velocity capture on the client.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Begin ragdoll physics for this entity.  Does nothing if the entity is already a ragdoll.<BR><B>EXAMPLE:  </B>self StartRagdoll()<BR></OL><P>
<HR><H1>void StartResurrectViewAngleTransition()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Finishes the flashback<BR><B>EXAMPLE:  </B>self StartResurrectViewAngleTransition()<BR></OL><P>
<HR><H1>void StopAllLoopSounds(<I>[fade]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [fade] The fade out time</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Stops a loop sound<BR><B>EXAMPLE:  </B>car StopAllLoopSounds( 0.5 )<BR></OL><P>
<HR><H1>void StopAllRumbles()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stop all the rumbles playing right now<BR><B>EXAMPLE:  </B>StopAllRumbles()<BR></OL><P>
<HR><H1>void &lt;entity&gt; StopAnimScripted(<I>[blend]</I>,<I>[ImmediateStop]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [blend] The blend out time for the animation<LI>        <B>[OPTIONAL]</B>  [ImmediateStop] Stop the animation immediatly on the client side (no client/server time sync)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Halts animscript on this entity.<BR><B>EXAMPLE:  </B>self StopAnimScripted()<BR></OL><P>
<HR><H1>void StopBinocs(<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stop Binoculars on player<BR><B>EXAMPLE:  </B>player StopBinocs()<BR></OL><P>
<HR><H1>void StopDemoRecording()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stops demo recording<BR><B>EXAMPLE:  </B>Demo_End()<BR></OL><P>
<HR><H1>void &lt;turret&gt; StopFiring()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stops a turret firing<BR><B>EXAMPLE:  </B>turret StopFiring()<BR></OL><P>
<HR><H1>void StopForceStreamingMaterial(<I>&lt;material&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;material&gt; Material to stop force streaming</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Forces the streamer to load the texture LODs for a material even if it isn't yet visible.  Returns true when all levels are loaded.  Call StopForceStreamingMaterial when you no longer need it, or Steve will be upset that you're wasting Streamer memory.<BR><B>EXAMPLE:  </B>StopForceStreamingMaterial( material )<BR></OL><P>
<HR><H1>void StopForceStreamingXModel(<I>&lt;model&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;model&gt; The model to stop force streaming</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Forces the streamer to load model and texture LODs for a model even if it isn't yet visible.  Returns true when all levels are loaded.  Call StopForceStreamingXModel when you no longer need it, or Steve will be upset that you're wasting Streamer memory.<BR><B>EXAMPLE:  </B>areAllForcedLodsLoaded = CScr_StopForceStreamingXModel( model )<BR></OL><P>
<HR><H1>void StopForcingStreamer()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Remove all streamer forcing<BR><B>EXAMPLE:  </B>StopForcingStreamer()<BR></OL><P>
<HR><H1>void &lt;player&gt; StopJukeMove()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stops the player juke movement in progress<BR><B>EXAMPLE:  </B>player StopJukeMove()<BR></OL><P>
<HR><H1>void &lt;entity&gt; StopLoopSound(<I>[fadetime]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [fadetime] Time to fade the sound in. Range is between 1 and 31 inclusive.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stops the looping sound with an optional fadetime.<BR><B>EXAMPLE:  </B>m_chasm stoploopsound( 5 )<BR></OL><P>
<HR><H1>void StopMission()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>fire Mission_Stop event to terminate the current mission<BR><B>EXAMPLE:  </B>StopMission()<BR></OL><P>
<HR><H1>void &lt;model_origin_brushmodel&gt; StopMoveSlide()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stops the movement caused by MoveSlide().<BR><B>EXAMPLE:  </B>self StopMoveSlide()<BR></OL><P>
<HR><H1>void StopPoisoning(<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stop poisoning player<BR><B>EXAMPLE:  </B>player StopPoisoning()<BR></OL><P>
<HR><H1>void &lt;entity&gt; StopRumble(<I>&lt;rumble name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;rumble name&gt; The name of the rumble to play</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Plays a looping rumble on the given entity.<BR><B>EXAMPLE:  </B>self StopRumble( "damage_heavy" )<BR></OL><P>
<HR><H1>void &lt;player&gt; StopShellShock()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stops the shell shock sequence for the player<BR><B>EXAMPLE:  </B>player StopShellShock()<BR></OL><P>
<HR><H1>void &lt;turret&gt; StopShootTurret()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stops a turrent from firing.<BR><B>EXAMPLE:  </B>roof_turret StopShootTurret()<BR></OL><P>
<HR><H1>void StopSound()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stop a particular sound on an entity *WARNING*, You must have a wait between StopSounds() and delete() or the sound will not stop.<BR><B>EXAMPLE:  </B>beatBox StopSound("alias");<BR></OL><P>
<HR><H1>void &lt;entity&gt; StopSounds()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stop all sounds on an entity.  *WARNING*, You must have a wait between StopSounds() and delete() or the sound will not stop.<BR><B>EXAMPLE:  </B>beatBox StopSounds()<BR></OL><P>
<HR><H1>void StreamerModelHint(<I>&lt;modelname&gt;</I>,<I>&lt;duration&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;modelname&gt; The name of the model.<LI>        <B>[MANDATORY]</B>  &lt;duration&gt; Length of time (in seconds) to keep it loaded.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Force a model to be loaded for a set period of time.<BR><B>EXAMPLE:  </B>streamerModelHint( "c_hro_hendricks_base_fb", 10 )<BR></OL><P>
<HR><H1>void StreamerNotify(<I>&lt;id&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;id&gt; integer value indicating the current streamer notify</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Send a streamer notify to the server indicating that the streamer is ready<BR><B>EXAMPLE:  </B>StreamerNotify(1)<BR></OL><P>
<HR><H1>void StreamerRequest(<I>&lt;command&gt;</I>,<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;command&gt; "set", "clear" or "play"<LI>        <B>[MANDATORY]</B>  &lt;name&gt; Name of the streamer hint asset</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Streamer request<BR><B>EXAMPLE:  </B>streamerRequest( "set", "ramses_igc1" )<BR></OL><P>
<HR><H1>void StreamerSkiptoDebug()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR></OL><P>
<HR><H1>void StreamTextureList(<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; Texturelist to stream</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Specify a texture list file for the streamer to load<BR><B>EXAMPLE:  </B>StreamTextureList( "igc1" )<BR></OL><P>
<HR><H1>void SubtitlePrint(<I>&lt;localClientNum&gt;</I>,<I>&lt;msec&gt;</I>,<I>&lt;subtitle&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The localClientNum to flush the subtitles for<LI>        <B>[MANDATORY]</B>  &lt;msec&gt; The time to display the subtitle for<LI>        <B>[MANDATORY]</B>  &lt;subtitle&gt; The message to display</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>print to the subtitle channel<BR><B>EXAMPLE:  </B>SubtitlePrint( 0, 100, "zombies everywhere") <BR></OL><P>
<HR><H1>void SwitchMap_Load(<I>&lt;map name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;map name&gt; the name of the map to preload</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Start loading a map/level.<BR><B>EXAMPLE:  </B>SwitchMap_Load( "cp_sh_cairo", "coop", 0 )<BR></OL><P>
<HR><H1>void SwitchMap_Preload(<I>&lt;map name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;map name&gt; the name of the map to preload</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Start preloading a map/level.  A 'switchmap_preload_finished' notify is sent to the level when its finished.<BR><B>EXAMPLE:  </B>SwitchMap_Preload( "cp_sh_cairo" )<BR></OL><P>
<HR><H1>void SwitchMap_SetLoadingMovie(<I>&lt;movie_name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;movie_name&gt; The name of the movie</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the loading movie to play<BR><B>EXAMPLE:  </B>SwitchMap_SetLoadingMovie( str_intro_movie )<BR></OL><P>
<HR><H1>void SwitchMap_Switch()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Switch to the loaded map/level<BR><B>EXAMPLE:  </B>SwitchMap_Switch()<BR></OL><P>
<HR><H1>void Target_BoundingIsUnderReticle(<I>&lt;player&gt;</I>,<I>&lt;target entity&gt;</I>,<I>&lt;maxDistance&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player entity<LI>        <B>[MANDATORY]</B>  &lt;target entity&gt; The entity that is the target<LI>        <B>[MANDATORY]</B>  &lt;maxDistance&gt; The maximum distance to check for target intersection</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player's cursor is roughly inside of the target's bounding box.<BR><B>EXAMPLE:  </B>player Target_BoundingIsUnderReticle( player, enemy_chopper, 1000 )<BR></OL><P>
<HR><H1>void Target_ClearReticleLockOn()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Cancels any lock-on sequence on the hud.<BR><B>EXAMPLE:  </B>Target_ClearReticleLockOn()<BR></OL><P>
<HR><H1>entity Target_GetArray()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets an array of entities that are set as targets<BR><B>EXAMPLE:  </B>mytargets = Target_GetArray()<BR></OL><P>
<HR><H1>void Target_GetOffset(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The entity that is the target</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the target offset<BR><B>EXAMPLE:  </B>offset = Target_GetOffset( entity )<BR></OL><P>
<HR><H1>void Target_IsInCircle(<I>&lt;target entity&gt;</I>,<I>&lt;player&gt;</I>,<I>&lt;fov&gt;</I>,<I>&lt;radius&gt;</I>,<I>[zoffset]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target entity&gt; The entity that is the target<LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player entity<LI>        <B>[MANDATORY]</B>  &lt;fov&gt; The player's field of view<LI>        <B>[MANDATORY]</B>  &lt;radius&gt; radius of the circle, centered at the center of the screen<LI>        <B>[OPTIONAL]</B>  [zoffset] if entity is not in target array, use optional zoffset for target pos</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns whether a target is within a given radius from the center of the player's screen<BR><B>EXAMPLE:  </B>player Target_IsInCircle( enemy_chopper, player, 65, 100 )<BR></OL><P>
<HR><H1>void Target_IsInRect(<I>&lt;target entity&gt;</I>,<I>&lt;player&gt;</I>,<I>&lt;fov&gt;</I>,<I>&lt;halfwidth&gt;</I>,<I>&lt;halfheight&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target entity&gt; The entity that is the target<LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player entity<LI>        <B>[MANDATORY]</B>  &lt;fov&gt; The player's field of view<LI>        <B>[MANDATORY]</B>  &lt;halfwidth&gt; half the width of the rectangle<LI>        <B>[MANDATORY]</B>  &lt;halfheight&gt; half the height of the rectangle</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns whether a target is within a given rectangle, centered in the center of the player's screen<BR><B>EXAMPLE:  </B>player Target_IsInRect( enemy_chopper, player, 65, 100, 100 )<BR></OL><P>
<HR><H1>void Target_IsTarget(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The entity to check</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns whether an entity has been marked as a target<BR><B>EXAMPLE:  </B>if ( Target_IsTarget( foundEnt ) ) ...<BR></OL><P>
<HR><H1>void Target_OriginIsInCircle(<I>&lt;origin&gt;</I>,<I>&lt;player&gt;</I>,<I>&lt;fov&gt;</I>,<I>&lt;radius&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The origin to test<LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player entity<LI>        <B>[MANDATORY]</B>  &lt;fov&gt; The player's field of view<LI>        <B>[MANDATORY]</B>  &lt;radius&gt; radius of the circle, centered at the center of the screen</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns whether a target is within a given radius from the center of the player's screen<BR><B>EXAMPLE:  </B>player Target_IsInCircle( enemy_chopper, player, 65, 100 )<BR></OL><P>
<HR><H1>void Target_Remove(<I>&lt;target entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target entity&gt; The entity that is the target</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Removes a target<BR><B>EXAMPLE:  </B>Target_Remove( enemy_chopper )<BR></OL><P>
<HR><H1>void Target_ScaleMinMaxRadius(<I>&lt;target entity&gt;</I>,<I>&lt;player&gt;</I>,<I>&lt;fov&gt;</I>,<I>&lt;radius_min&gt;</I>,<I>&lt;radius_max&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target entity&gt; The entity that is the target<LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player entity<LI>        <B>[MANDATORY]</B>  &lt;fov&gt; The player's field of view<LI>        <B>[MANDATORY]</B>  &lt;radius_min&gt; radius of the circle, centered at the center of the screen<LI>        <B>[MANDATORY]</B>  &lt;radius_max&gt; radius of the circle, centered at the center of the screen</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the ratio from 0-1 of where the target is in relation to the radius min and radius max<BR><B>EXAMPLE:  </B>scale = Target_ScaleMinMaxRadius( target, self, level.hackerToolLockOnFOV, radiusInner, radiusOuter )<BR></OL><P>
<HR><H1>void Target_Set(<I>&lt;target entity&gt;</I>,<I>[target offset]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target entity&gt; The entity that is the target<LI>        <B>[OPTIONAL]</B>  [target offset] The offset of the target position from the entity's origin</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Adds a new target to draw on the hud<BR><B>EXAMPLE:  </B>Target_Set( enemy_chopper )<BR></OL><P>
<HR><H1>void Target_SetAllowHighSteering(<I>&lt;target entity&gt;</I>,<I>[bool]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target entity&gt; The entity that is the target<LI>        <B>[MANDATORY]</B>  [bool] true/false"</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Target will allow incoming missiles to steer more making the target easier to hit<BR><B>EXAMPLE:  </B>Target_SetAllowHighSteering( enemy_tank, true )<BR></OL><P>
<HR><H1>void Target_SetAttackMode(<I>&lt;target entity&gt;</I>,<I>&lt;mode name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target entity&gt; The entity that is the target<LI>        <B>[MANDATORY]</B>  &lt;mode name&gt; "top" or "direct"</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets how missiles and rockets should approach the target.<BR><B>EXAMPLE:  </B>Target_SetAttackMode( enemy_tank, "top" )<BR></OL><P>
<HR><H1>void Target_SetJavelinOnly(<I>&lt;target entity&gt;</I>,<I>&lt;mode name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target entity&gt; The entity that is the target<LI>        <B>[MANDATORY]</B>  &lt;mode name&gt; "top" or "direct"</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Target will only draw on player's hud when they are looking through the Javelin-weapon's site.<BR><B>EXAMPLE:  </B>Target_SetJavelinOnly( enemy_tank, true )<BR></OL><P>
<HR><H1>void Target_SetOffscreenShader(<I>&lt;target entity&gt;</I>,<I>&lt;materialname&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target entity&gt; The entity that is the target<LI>        <B>[MANDATORY]</B>  &lt;materialname&gt; The shader for the quad drawn over the target</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the material that is used when a target clamps to the edge of the screen.  The target must have already been created with target_set()<BR><B>EXAMPLE:  </B>Target_SetOffscreenShader( enemy_chopper, "arrow" )<BR></OL><P>
<HR><H1>void Target_SetOffset(<I>&lt;target entity&gt;</I>,<I>[target offset]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target entity&gt; The entity that is the target<LI>        <B>[OPTIONAL]</B>  [target offset] The offset of the target position from the entity's origin</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the offset for a particular target<BR><B>EXAMPLE:  </B>Target_SetOffset( enemy_chopper, ( 0, 0, -100 ) )<BR></OL><P>
<HR><H1>void Target_SetShader(<I>&lt;target entity&gt;</I>,<I>&lt;materialname&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target entity&gt; The entity that is the target<LI>        <B>[MANDATORY]</B>  &lt;materialname&gt; The shader for the quad drawn over the target</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Changes the material of a target.  The target must have already been created with target_set()<BR><B>EXAMPLE:  </B>Target_SetShader( enemy_chopper, "locked_on_shader" )<BR></OL><P>
<HR><H1>void Target_SetTurretAquire(<I>&lt;entity&gt;</I>,<I>[bool]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The entity to set the flag<LI>        <B>[OPTIONAL]</B>  [bool] false if you want the SAM turret to ignore the targe. default is true.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets if the target can be attacked by SAM turrets<BR><B>EXAMPLE:  </B>Target_SetTurretAquire( chopper, false )<BR></OL><P>
<HR><H1>void Target_StartReticleLockOn(<I>&lt;target entity&gt;</I>,<I>&lt;duration&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target entity&gt; The entity that is the target<LI>        <B>[MANDATORY]</B>  &lt;duration&gt; The amount of time between now and fully locked-on, in seconds.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Begins the lock-on sequence for the target on the hud.  This affects the animation of the vehicle reticle.<BR><B>EXAMPLE:  </B>Target_StartReticleLockOn( enemy_chopper, 4 )<BR></OL><P>
<HR><H1>void TestSpawnPoint(<I>&lt;point&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;point&gt; the point to test</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player would not be in a solid when spawned at the given point.<BR><B>EXAMPLE:  </B>TestSpawnPoint( self.origin )<BR></OL><P>
<HR><H1>void &lt;entity&gt; TmodeSetServerUser(<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;value&gt; (int) 1-using 0-not usuing</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>informs the server if the entity is using tmode<BR><B>EXAMPLE:  </B>entity TmodeSetServerUser( 1 )<BR></OL><P>
<HR><H1>void ToggleNoVehicleFaceTraversability()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set whether the entity can use NoVehicleFaces. This should only be used in MP map for now.<BR></OL><P>
<HR><H1>void TracePassedOnNavMesh(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>,<I>[characterRadius]</I>,<I>[materialFlags]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt; start of the trace<LI>        <B>[MANDATORY]</B>  &lt;end&gt; end of the trace<LI>        <B>[OPTIONAL]</B>  [characterRadius] the radius of the capsule used in trace. default to 0.<LI>        <B>[OPTIONAL]</B>  [materialFlags] the flags marking whether a face type can be used</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Run a trace on NavMesh to see if a character can go straight from start to end.<BR><B>EXAMPLE:  </B>posOnNavMesh = TracePassedOnNavMesh( (10,20,30), 25, 15 )<BR></OL><P>
<HR><H1>void TracePoint(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt; Start point<LI>        <B>[MANDATORY]</B>  &lt;end&gt; End point</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Traces a poitn throught the world with MASK_SHOT. Returns hit position, hit surface normal.<BR><B>EXAMPLE:  </B>trace = TracePoint( p0, p1 )<BR></OL><P>
<HR><H1>void &lt;trigger&gt; TriggerEnable(<I>&lt;flag&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flag&gt; True if trigger should be enabled, false otherwise</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enables or disables the trigger<BR><B>EXAMPLE:  </B>trig TriggerEnable( true )<BR></OL><P>
<HR><H1>void TriggerFX(<I>&lt;entity&gt;</I>,<I>[time delay]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The fx entity<LI>        <B>[OPTIONAL]</B>  [time delay] The time delay for the fx to play</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Trigger the fx after some time delay<BR><B>EXAMPLE:  </B>triggerFx( domFlag.enemyBaseEffect, 0.001 )<BR></OL><P>
<HR><H1>void &lt;trigger&gt; TriggerIgnoreTeam()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Trigger ignores team<BR><B>EXAMPLE:  </B>trig TriggerIgnoreTeam()<BR></OL><P>
<HR><H1>void &lt;player_actor&gt; Underwater()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>checks if the player or actor is underwater<BR><B>EXAMPLE:  </B>if( player Underwater() ) ...<BR></OL><P>
<HR><H1>void &lt;entity&gt; Unlink()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Unlinks a linked entity from another entity<BR><B>EXAMPLE:  </B>guy Unlink()<BR></OL><P>
<HR><H1>void UnlinkNodes(<I>&lt;node1&gt;</I>,<I>&lt;node2&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node1&gt; first node to unlink<LI>        <B>[MANDATORY]</B>  &lt;node2&gt; second node to unlink</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Disconnects node1 from node2. Call it again with arguments flipped if you want to completely disconnect the two nodes.<BR><B>EXAMPLE:  </B>UnlinkNodes( node_moving_elev_left, node_moving_elev_right )<BR></OL><P>
<HR><H1>void UnlinkTraversal(<I>&lt;node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; Negotiation begin node</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Destroys a user edge connecting two path nodes<BR><B>EXAMPLE:  </B>UnlinkTraversal( beginNode )<BR></OL><P>
<HR><H1>void UnloadSiegeAnim(<I>&lt;anim_name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;anim_name&gt; Name of the siege anim to unload</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Unload a siege anim from memory<BR><B>EXAMPLE:  </B>UnloadSiegeAnim( "flappy_bird" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; UnlockSongByAlias(<I>&lt;aliasname&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;aliasname&gt; The sound alias to play (string)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Unlock the the sound alias<BR><B>EXAMPLE:  </B>self UnlockSongByAlias( "frag_out" )<BR></OL><P>
<HR><H1>void UnSetTurretNode(<I>&lt;node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; The turret node to disconnect</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Unset the turret from this node.<BR><B>EXAMPLE:  </B>UnSetTurretNode( node )<BR></OL><P>
<HR><H1>void UpdateClientNames()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Update all of the client names: only works in 'manual_change' mode<BR></OL><P>
<HR><H1>void UpdateNavTriggers()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Optimized code that performs the update_nav_triggers() script functionality<BR><B>EXAMPLE:  </B>UpateNavTriggers()<BR></OL><P>
<HR><H1>void &lt;entity&gt; UpdateUnlockedAttachmentBits()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Updates client-&gt;unlockedAttachments<BR><B>EXAMPLE:  </B>self UpdateUnlockedAttachmentBits()<BR></OL><P>
<HR><H1>void &lt;player&gt; UseAlternateAimParams()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Forces the local player to use alternate values for aim assist. Only works in zombie/campaign mode. Can only be called on players<BR><B>EXAMPLE:  </B>self UseAlternateAimParams( )<BR></OL><P>
<HR><H1>void UseAlternateHud(<I>&lt;onOff&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;onOff&gt; 0 = regular, 1 = alternate</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Use the alternate HUD in lui. Zombies only<BR></OL><P>
<HR><H1>void &lt;entity&gt; UseAnimTree(<I>&lt;anim tree&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;anim tree&gt; The anim tree to set</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the anim tree for the entity<BR><B>EXAMPLE:  </B>self UseAnimTree( #animtree )<BR></OL><P>
<HR><H1>void UseBuildKitWeaponModel(<I>&lt;player&gt;</I>,<I>&lt;weapon&gt;</I>,<I>[camoIndex]</I>,<I>&lt;upgraded&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player whose build kit data will be used<LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to base the build kit on<LI>        <B>[OPTIONAL]</B>  [camoIndex] The index of the camo to override the build kit's camo with<LI>        <B>[OPTIONAL]</B>  &lt;upgraded&gt; bool whether this should be the upgraded version. If so extclip and fmj will be added</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Use a build kit weapon model<BR><B>EXAMPLE:  </B>wall_weapon_model UseBuildKitWeaponModel( player, magicbox.weapon )<BR></OL><P>
<HR><H1>entity &lt;entity&gt; UseBy(<I>&lt;activator entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;activator entity&gt;</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Uses the entity with the passed in entity as the activator<BR><B>EXAMPLE:  </B>self UseBy( player )<BR></OL><P>
<HR><H1>void &lt;player&gt; UseServerVisionset(<I>&lt;use it&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;use it&gt; Whether using the server override visionset</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Switches using the server supplied (via SetVisionSetForPlayer()) visionset.<BR><B>EXAMPLE:  </B>player UseServerVisionset( true )<BR></OL><P>
<HR><H1>void &lt;trigger&gt; UseTriggerIgnoreUseHoldTime()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the require look at flag for the trigger<BR><B>EXAMPLE:  </B>e_trig_mobile_armory UseTriggerIgnoreUseHoldTime()<BR></OL><P>
<HR><H1>void &lt;trigger&gt; UseTriggerRequireLookAt()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the require look at flag for the trigger<BR><B>EXAMPLE:  </B>e_trig_plaza_igc UseTriggerRequireLookAt()<BR></OL><P>
<HR><H1>void &lt;trigger&gt; UseTriggerRequireLookToward()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the require look along flag for the trigger<BR><B>EXAMPLE:  </B>e_trig_plaza_igc UseTriggerRequireLookToward()<BR></OL><P>
<HR><H1>void UseWeaponHideTags(<I>&lt;weaponName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weaponName&gt; The name of the weapon to base the tags to hide on</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Hides tags on this entity based on the hidetags value of the provided weaponname<BR><B>EXAMPLE:  </B>wall_weapon_model UseWeaponHideTags()<BR></OL><P>
<HR><H1>void UseWeaponModel(<I>&lt;weaponName&gt;</I>,<I>[model]</I>,<I>[weapon options]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weaponName&gt; The name of the weapon to base the tags to hide on<LI>        <B>[OPTIONAL]</B>  [model] The name of a model to use. If none is specified the world model for the weapon will be used<LI>        <B>[OPTIONAL]</B>  [weapon options] The weapon options</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Use a weapon model<BR><B>EXAMPLE:  </B>wall_weapon_model UseWeaponModel("m16_zm")<BR></OL><P>
<HR><H1>void Vibrate(<I>&lt;direction vector&gt;</I>,<I>&lt;amplitude&gt;</I>,<I>&lt;period&gt;</I>,<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;direction vector&gt; The direction of the vibration<LI>        <B>[MANDATORY]</B>  &lt;amplitude&gt; The amount of the vibration in degrees<LI>        <B>[MANDATORY]</B>  &lt;period&gt; The period of the vibration in seconds<LI>        <B>[MANDATORY]</B>  &lt;time&gt; The length of time of the vibration in seconds</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Causes a script entity to vibrate, rotating around its origin, along a given vector dir<BR><B>EXAMPLE:  </B>self Vibrate( directionVir, 0.3, 0.4, 1.0 )<BR></OL><P>
<HR><H1>void VideoPause(<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; name of movie to pause.  do not add a file suffix (like .mp4)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Pause video playback<BR><B>EXAMPLE:  </B>VideoPause( "MyAwesomeMovie" )<BR></OL><P>
<HR><H1>void VideoPrime(<I>&lt;name&gt;</I>,<I>&lt;loop&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; name of movie to play.  do not add a file suffix (like .mp4)<LI>        <B>[OPTIONAL]</B>  &lt;loop&gt; Set this to true if the movie should automatically restart when it reaches the end.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Preload the first second of a movie.  Call this several seconds before the movie needs to play to prevent any delay<BR><B>EXAMPLE:  </B>VideoPrime( "MyAwesomeMovie" )<BR></OL><P>
<HR><H1>void VideoStart(<I>&lt;name&gt;</I>,<I>&lt;loop&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; name of movie to play.  do not add a file suffix (like .mp4)<LI>        <B>[OPTIONAL]</B>  &lt;loop&gt; Set this to true if the movie should automatically restart when it reaches the end.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Start a video for playback on an in-game surface<BR><B>EXAMPLE:  </B>VideoStart( "MyAwesomeMovie" )<BR></OL><P>
<HR><H1>void VideoStop(<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; name of movie to stop.  do not add a file suffix (like .mp4)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stop a video being played on an in-game surface<BR><B>EXAMPLE:  </B>VideoStop( "MyAwesomeMovie" )<BR></OL><P>
<HR><H1>void VideoUnpause(<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; name of movie to pause.  do not add a file suffix (like .mp4)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Unpause video playback<BR><B>EXAMPLE:  </B>VideoUnpause( "MyAwesomeMovie" )<BR></OL><P>
<HR><H1>void &lt;player&gt; ViewKick(<I>&lt;damage&gt;</I>,<I>&lt;origin&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;damage&gt; The damage to inflict<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The origin of the kick</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Give the player a view kick<BR><B>EXAMPLE:  </B>entity ViewKick( 25, self.origin )<BR></OL><P>
<HR><H1>void ViewmodelHasTag(<I>&lt;local_client_num&gt;</I>,<I>&lt;tag&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;local_client_num&gt; The client number<LI>        <B>[MANDATORY]</B>  &lt;tag&gt; The tag to see if it exists on the current weapon</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR></OL><P>
<HR><H1>void VisionSetLastStand(<I>&lt;vision name&gt;</I>,<I>[transition time]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;vision name&gt; Vision to transition to.<LI>        <B>[OPTIONAL]</B>  [transition time] How long, in seconds, to take transitioning to the new vision set if a transition is possible.  Default is one second.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets players' laststand vision.  Optionally give a transition time from the current vision.<BR><B>EXAMPLE:  </B>VisionSetLastStand( "armada", 1.5 )<BR></OL><P>
<HR><H1>void VisionSetLerpRatio(<I>&lt;float&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;float&gt; ratio between 0 and 1</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Determines if you can see an item.  Checks distance and view cone before the trace to increase efficency.<BR><B>EXAMPLE:  </B>self VisionSetLerpRatio ( currentDistance / maxDistance )<BR></OL><P>
<HR><H1>void VisionSetNaked(<I>&lt;name&gt;</I>,<I>[duration]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; The vision set name<LI>        <B>[OPTIONAL]</B>  [duration] The duration of the vision</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the vision and its duration<BR><B>EXAMPLE:  </B>VisionSetNaked( "cp_igc_chinatown_intro", 0.05 )<BR></OL><P>
<HR><H1>void VrIsActive()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns whether the game is currently in VR mode.<BR><B>EXAMPLE:  </B>do_vr_stuff = VrIsActive() ...<BR></OL><P>
<HR><H1>void &lt;player&gt; WalkUnderwater(<I>&lt;boolean&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;boolean&gt; true if player should walk underwater.  False if player should swim</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets if a player should walk while underwater<BR><B>EXAMPLE:  </B>depth = get_players()[0] WalkUnderwater( true )<BR></OL><P>
<HR><H1>void &lt;player&gt; WeaponCyclingEnabled()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Determine if weapon cycling is enabled for the player<BR><B>EXAMPLE:  </B>enabled = player WeaponCyclingEnabled()<BR></OL><P>
<HR><H1>void WeaponFriendlyHacking(<I>&lt;localClientNum&gt;</I>,<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client number of the player<LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Weapon to check</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the value of the friendlyHacking bit on the specified weapon of the specified player<BR><B>EXAMPLE:  </B>currentWeapon = GetCurrentWeapon( localClientNum )<BR></OL><P>
<HR><H1>void WeaponHasAttachment()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Does the weapon have all the attachments specified?<BR><B>EXAMPLE:  </B>WeaponHasAttachment( weapon, "extbarrel", "damage, "fmj" )<BR></OL><P>
<HR><H1>void WeaponHasAttachmentAndUnlocked(<I>&lt;weapon&gt;</I>,<I>&lt;string&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; weapon<LI>        <B>[MANDATORY]</B>  &lt;string&gt; string id for attachment</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Does the weapon have all the attachments specified? And are they all unlocked for challenge stat purposes?<BR><B>EXAMPLE:  </B>player WeaponHasAttachmentAndUnlocked( weapon, "extbarrel", "damage, "fmj" )<BR></OL><P>
<HR><H1>void WorldEntNumber()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the entity number for the world<BR></OL><P>
<HR><H1>void &lt;entity&gt; WorldToLocalCoords(<I>&lt;world coords&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;world coords&gt; The point in world coordinates (vector3)</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Transform the given world point into the local space of the entity<BR><B>EXAMPLE:  </B>local_point = self WorldToLocalCoords( world_point )<BR></OL><P>
<HR><H1>void WorldTrace(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt; The trace start point<LI>        <B>[MANDATORY]</B>  &lt;end&gt; The trace end point</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Trace from start to end<BR><B>EXAMPLE:  </B>trace = WorldTrace( start_pos, end_pos )<BR></OL><P>
<HR><H1>entity &lt;entity&gt; ZBarrierGetPiece(<I>&lt;piece_index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;piece_index&gt; piece index to get</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Gets the entity for the zbarrier's given piece index<BR><B>EXAMPLE:  </B>zbarrier ZBarrierGetPiece( 3 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; ZBarrierPieceUseAlternateModel(<I>&lt;piece number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;piece number&gt; The piece index.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the indexed piece to use the alternate model.<BR><B>EXAMPLE:  </B>ent ZBarrierPieceUseAlternateModel(1)<BR></OL><P>
<HR><H1>void &lt;entity&gt; ZBarrierPieceUseAttachWeapon(<I>&lt;piece number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;piece number&gt; The piece index.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the indexed piece to attach the zbarrier's weapon to tag_weapon (and tag_weapon_left if it's dual wield).<BR><B>EXAMPLE:  </B>ent ZBarrierPieceUseAttachWeapon( 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; ZBarrierPieceUseBoxRiseLogic(<I>&lt;piece number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;piece number&gt; The piece index.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the indexed piece to use the box rise logic.<BR><B>EXAMPLE:  </B>ent ZBarrierPieceUseBoxRiseLogic(1)<BR></OL><P>
<HR><H1>void &lt;entity&gt; ZBarrierPieceUseDefaultModel(<I>&lt;piece number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;piece number&gt; The piece index.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the indexed piece to use the default model.<BR><B>EXAMPLE:  </B>ent ZBarrierPieceUseDefaultModel(1)<BR></OL><P>
<HR><H1>void &lt;entity&gt; ZBarrierPieceUseUpgradedModel(<I>&lt;piece number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;piece number&gt; The piece index.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the indexed piece to use the upgraded model.<BR><B>EXAMPLE:  </B>ent ZBarrierPieceUseUpgradedModel(1)<BR></OL><P>
<HR><H1>void &lt;entity&gt; ZBarrierSupportsZombieReachThroughAttacks()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if this zbarrier supports zombie reach through attacks.<BR><B>EXAMPLE:  </B>useAttack = ent ZBarrierSupportsZombieReachThroughAttacks()<BR></OL><P>
<HR><H1>void &lt;entity&gt; ZBarrierSupportsZombieTaunts()</H1><OL><UL></UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if this zbarrier supports zombie taunt anims.<BR><B>EXAMPLE:  </B>useTaunt = ent ZBarrierSupportsZombieTaunts()<BR></OL><P>
<HR><H1>void ZeroGravityVolumeOff(<I>&lt;volume name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;volume name&gt; The volume name.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Disables Zero Gravity Volume.<BR><B>EXAMPLE:  </B>ZeroGravityVolumeOff( "area_four" )<BR></OL><P>
<HR><H1>void ZeroGravityVolumeOn(<I>&lt;volume name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;volume name&gt; The volume name.</UL><B>CATEGORY:  </B><BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enables Zero Gravity Volume.<BR><B>EXAMPLE:  </B>ZeroGravityVolumeOn( "area_four" )<BR></OL><P>
<HR><H1>void &lt;sentient&gt; AddSentientEventListener(<I>&lt;event&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;event&gt; The event name</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Registers entity to listen to a specific event. Call waittill(&lt;event&gt;) to get the notification in script.<BR><B>EXAMPLE:  </B>self AddSentientEventListener("bulletwhizby")<BR></OL><P>
<HR><H1>void &lt;actor&gt; aithrowgrenade()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Throw a grenade. CheckGrenadeThrowPos() or CheckGrenadeThrow() must be called first.<BR><B>EXAMPLE:  </B>self GrenadeThrow()<BR></OL><P>
<HR><H1>void &lt;actor&gt; AllowPitchAngle(<I>&lt;on_off&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;on_off&gt; 1 to allow and 0 to disallow</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Allows AI to pitch on stairs<BR><B>EXAMPLE:  </B>guy AllowPitchAngle ( 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; AnimMode(<I>&lt;mode&gt;</I>,<I>[clear path]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;mode&gt; which animmode to use. Must be 'gravity', 'nogravity', 'angle deltas', 'pos deltas', 'normal', 'normal_nogravity', 'zonly_physics', 'nophysics', 'none'<LI>        <B>[OPTIONAL]</B>  [clear path] The clear path flag</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the way that animation deltas are interpreted by the game engine<BR><B>EXAMPLE:  </B>self AnimMode( "gravity" )<BR><B>NOTES:  </B>none:				Use default animmode behavior (i.e., code controls the movement).<BR></OL><P>
<HR><H1>void &lt;actor&gt; AtDangerousNode()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Determine whether this actor is near a dangerous node.<BR><B>EXAMPLE:  </B>if ( ai atDangerousNode() )...<BR></OL><P>
<HR><H1>void &lt;sentient&gt; AttackedRecently(<I>&lt;entity&gt;</I>,<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The enemy entity<LI>        <B>[MANDATORY]</B>  &lt;time&gt; Time interval in seconds.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if given sentient has attacked the entity within last "time" sec.<BR><B>EXAMPLE:  </B>self AttackedRecently(self.enemy)<BR></OL><P>
<HR><H1>void &lt;actor&gt; CalcApproximatePathToPosition(<I>&lt;position&gt;</I>,<I>[clear path]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; The goal position for the path<LI>        <B>[OPTIONAL]</B>  [clear path] True to clear path, false otherwise. Defaults to True</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of world positions representing the approximate path an actor will take.  Calculating an approximate path will cause the AI to clear their current path.<BR><B>EXAMPLE:  </B>self CalcApproximatePathToPosition( position )<BR></OL><P>
<HR><H1>void &lt;actor&gt; CalcLookaheadPos(<I>&lt;startPos&gt;</I>,<I>&lt;numIter&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;startPos&gt; Starting position of the lookahead traces<LI>        <B>[MANDATORY]</B>  &lt;numIter&gt; Number of times to iterate (more gives better results, but is more expensive). Set to 0 to get current lookahead.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Calculate a lookahead point based on a given starting location and number of iterations. Returns an array with these keys: "position", "node" and "next_node", which contain vectors for the actual lookahead position and the next two nodes on the path, respectively.<BR><B>EXAMPLE:  </B>self CalcLookaheadPos( self.origin, 3 )<BR></OL><P>
<HR><H1>void &lt;actor&gt; CanAttackEnemyNode()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks if this actor can attack its enemies node.<BR><B>EXAMPLE:  </B>self CanAttackEnemyNode()<BR></OL><P>
<HR><H1>void &lt;sentient&gt; CanSee(<I>&lt;target&gt;</I>,<I>[cacheLength]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target&gt; (entity) The entity to check.<LI>        <B>[OPTIONAL]</B>  [cacheLength] (integer) The cache length</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check to see if the AI can see the given entity.<BR><B>EXAMPLE:  </B>if( self CanSee( player ) )<BR></OL><P>
<HR><H1>void &lt;actor&gt; CanShoot(<I>&lt;shoot at position&gt;</I>,<I>[offset from gun]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;shoot at position&gt; (vector) The position to shoot at.<LI>        <B>[OPTIONAL]</B>  [offset from gun] (vector) The offset from the gun muzzle from which to calculate collision.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check to see if the actor can shoot the given position.<BR><B>EXAMPLE:  </B>canShoot = self CanShoot( eye, offset )<BR></OL><P>
<HR><H1>void &lt;actor&gt; CanShootEnemy(<I>[cache duration]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [cache duration] (int) When set, uses a custom time value for the cache.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check to see if the actor can shoot his current enemy.<BR><B>EXAMPLE:  </B>canShootEnemy = self CanShootEnemy()<BR></OL><P>
<HR><H1>void &lt;actor&gt; CanThrowGrenade(<I>&lt;hand offset&gt;</I>,<I>&lt;random range&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;hand offset&gt; (vector) the estimated offset of the hand for the throw<LI>        <B>[MANDATORY]</B>  &lt;random range&gt; (float) random range from target position to throw at</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether the actor can throw a grenade at a given position. If he can't then result will be undefined, otherwise the result is the resultant velocity vector<BR><B>EXAMPLE:  </B>throwvel = self CanThrowGrenade( armOffset, 0 )<BR></OL><P>
<HR><H1>void &lt;actor&gt; CanThrowGrenadePos(<I>&lt;hand offset&gt;</I>,<I>&lt;targetpos&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;hand offset&gt; (vector) the estimated offset of the hand for the throw<LI>        <B>[MANDATORY]</B>  &lt;targetpos&gt; (vector) The target position, should be at ground level of potential target</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether the actor can throw a grenade at a given position. If he can't then result will be undefined, otherwise the result is the resultant velocity vector<BR><B>EXAMPLE:  </B>throwvel = self CanThrowGrenadePos( armOffset, targetPos )<BR></OL><P>
<HR><H1>void &lt;actor&gt; CheckGrenadeThrow(<I>&lt;hand offset&gt;</I>,<I>&lt;method&gt;</I>,<I>&lt;random range&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;hand offset&gt; (vector) the estimated offset of the hand for the throw<LI>        <B>[MANDATORY]</B>  &lt;method&gt; (string) The grenade toss method. Can be 'min energy', 'min time', and 'max tune'<LI>        <B>[MANDATORY]</B>  &lt;random range&gt; (float) random range from target position to throw at</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether the actor can throw a grenade at his target. If he can't then result will be undefined, otherwise the result is the resultant velocity vector<BR><B>EXAMPLE:  </B>throwvel = self CheckGrenadeThrow( armOffset, "min energy", 0 )<BR></OL><P>
<HR><H1>void &lt;actor&gt; CheckGrenadeThrowPos(<I>&lt;hand offset&gt;</I>,<I>&lt;method&gt;</I>,<I>&lt;targetpos&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;hand offset&gt; (vector) the estimated offset of the hand for the throw<LI>        <B>[MANDATORY]</B>  &lt;method&gt; (vector) The grenade toss method. Can be 'min energy', 'min time', and 'max tune'<LI>        <B>[MANDATORY]</B>  &lt;targetpos&gt; (vector) The target position, should be at ground level of potential target</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether the actor can throw a grenade at a given position. If he can't then result will be undefined, otherwise the result is the resultant velocity vector<BR><B>EXAMPLE:  </B>throwvel = self CheckGrenadeThrowPos( armOffset, "min energy", targetPos )<BR></OL><P>
<HR><H1>void &lt;actor&gt; CheckProne(<I>&lt;position&gt;</I>,<I>&lt;yaw&gt;</I>,<I>&lt;is prone&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt;(vector) The position of the prone character.<LI>        <B>[MANDATORY]</B>  &lt;yaw&gt;(float) The world yaw in degrees.<LI>        <B>[MANDATORY]</B>  &lt;is prone&gt;(bool) Flag if the character is already prone.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true when a character can go prone at the specified position. Specifically setup for use by AI characters.<BR><B>EXAMPLE:  </B>canFitProne = self CheckProne( origin, yaw, alreadyProne )<BR></OL><P>
<HR><H1>pathnode &lt;actor&gt; ChooseBetterCoverNode()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Chooses a better cover node for an ai<BR><B>EXAMPLE:  </B>newNode = behaviorTreeEntity ChooseBetterCoverNode()<BR></OL><P>
<HR><H1>void &lt;actor&gt; ClearEnemy()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clear the actor's current enemy entity.<BR><B>EXAMPLE:  </B>self ClearEnemy()<BR></OL><P>
<HR><H1>void &lt;actor&gt; ClearEntityOwner()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears an AI's entity owner.<BR><B>EXAMPLE:  </B>self ClearEntityOwner()<BR></OL><P>
<HR><H1>void &lt;actor&gt; ClearEntityTarget()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears an AI's entity target.<BR><B>EXAMPLE:  </B>self ClearEntityTarget( vehicle_entity )<BR></OL><P>
<HR><H1>void &lt;actor&gt; ClearFixedNodeSafeVolume()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears this actor's fixed node safe volume.<BR><B>EXAMPLE:  </B>self ClearFixedNodeSafeVolume()<BR></OL><P>
<HR><H1>void &lt;sentient&gt; ClearForcedGoal()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears the forcedGoal for this AI's goal.<BR><B>EXAMPLE:  </B>self ClearForcedGoal()<BR></OL><P>
<HR><H1>void &lt;sentient&gt; ClearGoalVolume()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears this actor's goal volume.<BR><B>EXAMPLE:  </B>self ClearGoalVolume()<BR></OL><P>
<HR><H1>void &lt;actor&gt; ClearPath()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears the AI's current path.<BR><B>EXAMPLE:  </B>self ClearPath()<BR></OL><P>
<HR><H1>void &lt;actor&gt; ClearPitchOrient()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clear pitch orientation<BR><B>EXAMPLE:  </B>self clearPitchOrient()<BR></OL><P>
<HR><H1>void &lt;entity&gt; ClearPotentialThreat(<I>&lt;dir&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;dir&gt; direction of the threat. This is the angle from which the NPC should expect danger</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clear the potential threat direction. See SetPotentialThreat for more info on potential threats<BR><B>EXAMPLE:  </B>self ClearPotentialThreat( 90 )<BR></OL><P>
<HR><H1>void &lt;actor&gt; ClearUsePosition()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clear the override for the goal pos.<BR><B>EXAMPLE:  </B>self ClearUsePosition()<BR></OL><P>
<HR><H1>void &lt;actor&gt; CollideWithActors(<I>(bool) Turn collision on or off.</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  (bool) Turn collision on or off.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Toggles collision with other actors. Actor will go through each other, when its toggled off.<BR><B>EXAMPLE:  </B>entity CollideWithActors( true )<BR></OL><P>
<HR><H1>void CreateThreatBiasGroup(<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; threat bias group name.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Create a new threat bias group. If it already exists, do nothing<BR><B>EXAMPLE:  </B>CreateThreatBiasGroup( "flanking_team" )<BR></OL><P>
<HR><H1>void &lt;actor&gt; DamageMode(<I>&lt;damage mode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;damage mode&gt; (const string) DamageMode must be 'normal' or 'next_shot_kills'</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the damage mode of this actor.<BR><B>EXAMPLE:  </B>randAlly DamageMode("next_shot_kills")<BR></OL><P>
<HR><H1>entity &lt;actor&gt; DropWeapon(<I>&lt;weapon name&gt;</I>,<I>&lt;hand&gt;</I>,<I>[velocity]</I>,<I>[angular velocity]</I>,<I>[scavenger]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon name&gt; (string) The name of the weapon.<LI>        <B>[MANDATORY]</B>  &lt;hand&gt; (string) The tag to throw the weapon from.<LI>        <B>[OPTIONAL]</B>  [velocity] (vector) The initial velocity of the weapon.<LI>        <B>[OPTIONAL]</B>  [angular velocity] (vector) The initial angular velocity of the weapon.<LI>        <B>[OPTIONAL]</B>  [scavenger] (bool) If the weapon requires the player to have scavenger perk to pick up the weapon.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Drop the actor's weapon<BR><B>EXAMPLE:  </B>self DropWeapon(self.weapon, self.anim_gunHand, throwVel)<BR></OL><P>
<HR><H1>pathnode &lt;actor&gt; FindBestCoverNode()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Find the best cover node for a given NPC given his state.<BR><B>EXAMPLE:  </B>self FindBestCoverNode()<BR></OL><P>
<HR><H1>pathnode &lt;actor&gt; FindBestCoverNodes(<I>&lt;radius&gt;</I>,<I>&lt;origin&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;radius&gt; search radius<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; search origin</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Find the best cover nodes for a given NPC given his state. Sorted by best<BR><B>EXAMPLE:  </B>nodes = self FindBestCoverNodes(radius,origin)<BR></OL><P>
<HR><H1>pathnode &lt;actor&gt; FindCoverNodeAtLocation(<I>&lt;radius&gt;</I>,<I>&lt;origin&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;radius&gt; search radius<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; search origin</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Finds a near by cover node for the character.<BR><B>EXAMPLE:  </B>guy FindCoverNodeAtLocation(512,loc)<BR></OL><P>
<HR><H1>void &lt;actor&gt; FindReacquireDirectPath(<I>[ignore suppression]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [ignore suppression] Whether to ignore suppression when looking for a path. True makes a success more likely but may result in a more dangerous path.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Finds a path directly to the enemy. Call ReacquireMove to use the path.<BR></OL><P>
<HR><H1>void &lt;actor&gt; FindReacquireNode()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Finds a reacquire node when exposed.<BR><B>EXAMPLE:  </B>guy FindReacquireNode()<BR></OL><P>
<HR><H1>void &lt;actor&gt; FindReacquireProximatePath(<I>[ignore suppression]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [ignore suppression] Whether to ignore suppression when looking for a path. True makes a success more likely but may result in a more dangerous path.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Finds a path to a point that can see the enemy without leaving goal. Call ReacquireMove to use the path.<BR></OL><P>
<HR><H1>entity &lt;actor&gt; FinishActorDamage(<I>&lt;Inflictor&gt;</I>,<I>&lt;Attacker&gt;</I>,<I>&lt;Damage&gt;</I>,<I>&lt;Damage Flags&gt;</I>,<I>&lt;Means Of Death&gt;</I>,<I>&lt;Weapon&gt;</I>,<I>&lt;Direction&gt;</I>,<I>&lt;Hit Loc&gt;</I>,<I>&lt;Damage Origin&gt;</I>,<I>&lt;Offset Time&gt;</I>,<I>&lt;Bone Index&gt;</I>,<I>[Surface Type]</I>,<I>[Surface Normal]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;Inflictor&gt; The entity that causes the damage.(e.g. a turret)<LI>        <B>[MANDATORY]</B>  &lt;Attacker&gt; The entity that is attacking.<LI>        <B>[MANDATORY]</B>  &lt;Damage&gt; Integer specifying the amount of damage done<LI>        <B>[MANDATORY]</B>  &lt;Damage Flags&gt; Integer specifying flags that are to be applied to the damage<LI>        <B>[MANDATORY]</B>  &lt;Means Of Death&gt; Integer specifying the method of death<LI>        <B>[MANDATORY]</B>  &lt;Weapon&gt; The weapon number of the weapon used to inflict the damage<LI>        <B>[MANDATORY]</B>  &lt;Direction&gt; (vector) The direction of the damage<LI>        <B>[MANDATORY]</B>  &lt;Hit Loc&gt; The location of the hit<LI>        <B>[MANDATORY]</B>  &lt;Damage Origin&gt; Position of the originator of the damage<LI>        <B>[MANDATORY]</B>  &lt;Offset Time&gt; The time offset for the damage<LI>        <B>[MANDATORY]</B>  &lt;Bone Index&gt; Index of nearest bone<LI>        <B>[OPTIONAL]</B>  [Surface Type] The surface type of the hit location<LI>        <B>[OPTIONAL]</B>  [Surface Normal] The surface normal at hit location</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Does damage to an actor - usually as part of the damage callback<BR><B>EXAMPLE:  </B>self FinishActorDamage( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, sWeapon, vPoint, vDir, sHitLoc, vDamageOrigin, psOffsetTime, iBoneIndex, iSurfaceType, vSurfaceNormal )<BR></OL><P>
<HR><H1>void &lt;actor&gt; ForceTeleport(<I>&lt;position&gt;</I>,<I>[angles]</I>,<I>[updategoalpos]</I>,<I>[resetEntity]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; (point) The actor's new position.<LI>        <B>[OPTIONAL]</B>  [angles] (vector) The actor's new angles.<LI>        <B>[OPTIONAL]</B>  [updategoalpos] (bool) Update the script goal position to the teleport location. True by default.<LI>        <B>[OPTIONAL]</B>  [resetEntity] (bool) Reset the entity behaviors.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Force Teleport the actor to a new position with the given origin and angles, regardless of wether it will be visible to the player or not.<BR><B>EXAMPLE:  </B>self ForceTeleport( org, angles )<BR></OL><P>
<HR><H1>void &lt;actor&gt; GenerateRadioEvent(<I>&lt;type of event&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;type of event&gt; The type of radio event</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Searches animation selector table and returns an animation alias based on current state of the blackboard.<BR><B>EXAMPLE:  </B>self GenerateRadioEvent("radio_event_low")<BR></OL><P>
<HR><H1>void &lt;actor&gt; GetAimLimitsFromEntry()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Searches animation selector table and returns an animation alias based on current state of the blackboard.<BR></OL><P>
<HR><H1>void &lt;actor&gt; GetBehaviorTreeStatus()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns current status/BHTN_STATUS of the behavior tree for an actor.<BR><B>EXAMPLE:  </B>isBehaviorTreeInRunningState = behaviorTreeEntity GetBehaviortreeStatus() == BHTN_RUNNING<BR></OL><P>
<HR><H1>void &lt;sentient&gt; GetClosestEnemySqDist()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the distance to the nearest enemy<BR><B>EXAMPLE:  </B>dist = self GetClosestEnemySqDist()<BR><B>NOTES:  </B>either AI or player<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetDropToFloorPosition(<I>[position]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [position] test position. Defaults to entity's current origin</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the floor position for dropping an AI or player to the ground. Returns undefined if the AI is in solid.<BR><B>EXAMPLE:  </B>position = ai GetDropToFloorPosition( ai.origin )<BR></OL><P>
<HR><H1>void GetFinalPathPos()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the last position in the path<BR></OL><P>
<HR><H1>void &lt;actor&gt; GetFireMode()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns the firemode<BR><B>EXAMPLE:  </B>soldier GetFireMode()<BR></OL><P>
<HR><H1>entity &lt;actor&gt; GetFixedNodeSafeVolume()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get this actor's fixed node safe volume.<BR><B>EXAMPLE:  </B>volume = self GetFixedNodeSafeVolume()<BR></OL><P>
<HR><H1>void &lt;actor&gt; GetFlashBangedStrength()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Retrieves how strongly the actor was initially hit by a flashbang. 1.0 is full strength, 0.0 is none at all.<BR><B>EXAMPLE:  </B>flashedPercent = self GetFlashBangedStrength()<BR></OL><P>
<HR><H1>entity &lt;sentient&gt; GetGoalVolume()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get this actor's goal volume.<BR><B>EXAMPLE:  </B>goalVolume = self GetGoalVolume()<BR></OL><P>
<HR><H1>void &lt;actor&gt; GetGroundEntType()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the entity type of the 'ground' that the actor is on.<BR><B>EXAMPLE:  </B>self GetGroundEntType()<BR></OL><P>
<HR><H1>void &lt;actor&gt; GetHitEntType()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the type of entity that the actor has hit. Can be 'hit', 'obstacle' or 'world'.<BR><B>EXAMPLE:  </B>self GetHitEntType()<BR></OL><P>
<HR><H1>void &lt;actor&gt; GetHitYaw()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the direction in degrees that the player has hit an obstacle at. Returns an error if nothing was hit.<BR><B>EXAMPLE:  </B>self GetHitYaw()<BR></OL><P>
<HR><H1>void &lt;sentient&gt; GetIgnoreEnt(<I>&lt;sentient&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;sentient&gt; Another sentient entity</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns if a specific sentient entity is ignored by this sentient entity or not<BR><B>EXAMPLE:  </B>if ( aiGuy GetIgnoreEnt( player ) )<BR></OL><P>
<HR><H1>void GetNextFindBestCoverTime(<I>&lt;minEngageDist&gt;</I>,<I>&lt;maxEngageDist&gt;</I>,<I>&lt;noEnemyInterval&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;minEngageDist&gt; Min engage enemy dist.<LI>        <B>[MANDATORY]</B>  &lt;maxEngageDist&gt; Max engage enemy dist.<LI>        <B>[MANDATORY]</B>  &lt;noEnemyInterval&gt; How often cover should be searched when without an enemy</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Generates a new next find cover time<BR><B>EXAMPLE:  </B>behaviorTreeEntity.nextFindBestCoverTime = GetActorNextFindBestCoverTime( behaviorTreeEntity.engageMinDist, behaviorTreeEntity.engagemaxdist, behaviorTreeEntity.coversearchinterval )<BR></OL><P>
<HR><H1>void &lt;actor&gt; GetNodeOffsetAngles()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the angles the actor thinks the node is facing, this can contain additional rotation from the node's actual angles.<BR><B>EXAMPLE:  </B>self GetNodeOffsetAngles( self.node )<BR></OL><P>
<HR><H1>void &lt;actor&gt; GetNodeOffsetPosition()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the position the actor thinks the node's origin is at, this can be offset from where the actual node's position in the world is.<BR><B>EXAMPLE:  </B>self GetNodeOffsetPosition( self.node )<BR></OL><P>
<HR><H1>void &lt;actor&gt; GetOrientMode()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the orient mode of this actor.<BR><B>EXAMPLE:  </B>orientMode = randAlly GetOrientMode()<BR></OL><P>
<HR><H1>void &lt;actor&gt; GetPathLength()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the length of the path being used by this actor<BR><B>EXAMPLE:  </B>self GetPathLength()<BR></OL><P>
<HR><H1>void &lt;actor&gt; GetPathMode()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the path mode of this actor.<BR><B>EXAMPLE:  </B>pathMode = randAlly GetPathMode()<BR></OL><P>
<HR><H1>void &lt;actor&gt; GetPerfectInfo(<I>&lt;entity&gt;</I>,<I>[update sight]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity to become aware of. Must be a sentient (i.e. AI or player)<LI>        <B>[OPTIONAL]</B>  [update sight] If true then it will update the last seen position also.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Forces the AI to become aware of this entity regardless of whether it can be seen or not.<BR><B>EXAMPLE:  </B>self GetPerfectInfo( get_players()[0] )<BR></OL><P>
<HR><H1>void &lt;sentient&gt; GetPersonalThreatBias(<I>&lt;sentient&gt;</I>,<I>&lt;enemy&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;sentient&gt; Self<LI>        <B>[MANDATORY]</B>  &lt;enemy&gt; The enemy to get threat bias for</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>return the personal threat bias for this sentient versus the other sentient<BR><B>EXAMPLE:  </B>value = self GetPersonalThreatBias( self.enemy )<BR></OL><P>
<HR><H1>pathnode &lt;actor&gt; GetReacquireNode()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the reacquire node of this actor.<BR><B>EXAMPLE:  </B>guy GetReacquireNode()<BR></OL><P>
<HR><H1>void &lt;sentient&gt; GetStealthSightValue(<I>&lt;otherSentient&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;otherSentient&gt; other sentient you want to get the value on this sentient for</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the current stealth sight value for this sentient seeing another sentient (floating point from 0.0 to 1.0)<BR><B>EXAMPLE:  </B>aiGuy GetStealthSightValue( forOtherGuy )<BR></OL><P>
<HR><H1>void GetThreatBias(<I>&lt;of group&gt;</I>,<I>&lt;against group&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;of group&gt;(string) threat bias group for.<LI>        <B>[MANDATORY]</B>  &lt;against group&gt;(string) threat bias group against.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get threat bias of first group against second group<BR><B>EXAMPLE:  </B>GetThreatBias( "axis", "flanking_team" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetThreatBiasGroup()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the threat bias group of an AI or player<BR><B>EXAMPLE:  </B>GetThreatBiasGroup()<BR></OL><P>
<HR><H1>void &lt;actor&gt; GetTurnExitYaw()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Predicts exit yaw vector using havok pathfinding.<BR></OL><P>
<HR><H1>void &lt;actor&gt; GrenadeThrow()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Throw a grenade. CheckGrenadeThrowPos() or CheckGrenadeThrow() must be called first.<BR><B>EXAMPLE:  </B>self GrenadeThrow()<BR></OL><P>
<HR><H1>void &lt;sentient&gt; HasPath()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns true/false if AI has a path<BR><B>EXAMPLE:  </B>self HasPAth()<BR></OL><P>
<HR><H1>void &lt;actor&gt; HasValidInterrupt(<I>&lt;interrupt name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;interrupt name&gt; The name of the interrupt</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Return true if there is a valid interrupt with the given name alive on the current server frame.<BR><B>EXAMPLE:  </B>if ( entity HasValidInterrupt("pain") )<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsActorShooting(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An actor</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this entity is an ai is shooting<BR><B>EXAMPLE:  </B>if ( meanGuy IsActorShooting() ) ...<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsApproachingGoal()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns true/false if actor at the goal or approaching the goal.<BR><B>EXAMPLE:  </B>self IsApproachingGoal()<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsAtCoverNode()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns true/false if actor is at cover node. (exposed node is considered as covernode)<BR><B>EXAMPLE:  </B>self IsAtCoverNode()<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsAtCoverNodeStrict()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns true/false if actor is at cover node. (exposed node is not considered as covernode)<BR><B>EXAMPLE:  </B>self IsAtCoverNode()<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsAtGoal()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns true/false if actor has at/reached its current goal, similar to waiting for "goal" notify.<BR><B>EXAMPLE:  </B>self IsAtGoal()<BR></OL><P>
<HR><H1>void &lt;entity&gt; IsBadGuy()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the sentient is on the bad guy team (not 'allies', not 'neutral').<BR><B>EXAMPLE:  </B>if ( ai IsBadGuy() )<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsCoverValid(<I>&lt;pathnode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;pathnode&gt; The pathnode to check for validity</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Return true if the passed in node is a valid cover node.<BR><B>EXAMPLE:  </B>if( self IsCoverValid( pathnode ) )<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsCurrentBTActionLooping()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Return true if there is an action running and its looping.<BR><B>EXAMPLE:  </B>if( behaviorTreeEntity IsCurrentBTActionLooping() )<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsDeflected()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the actor has been deflected.<BR><B>EXAMPLE:  </B>self IsDeflected()<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsFlankedAtCoverNode()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns true/false if actor is at is flanked at cover node<BR><B>EXAMPLE:  </B>self IsFlankedAtCoverNode()<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsGrenadePosSafe(<I>&lt;throw pos&gt;</I>,<I>[radius]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;throw pos&gt; (vector) position to throw at<LI>        <B>[OPTIONAL]</B>  [radius] (float) safety radius</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks a grenade throw target position is safe.<BR><B>EXAMPLE:  </B>if ( self IsGrenadeThrowSafe( throwPos, 200 ) )<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsInAnyBadPlace()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns whether the AI is in a bad place.<BR><B>EXAMPLE:  </B>self IsInAnyBadPlace()<BR></OL><P>
<HR><H1>void &lt;sentient&gt; IsInGoal(<I>&lt;point&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;point&gt; which point to check.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Determine whether a given point is in the actor's current goal area<BR><B>EXAMPLE:  </B>if ( ai IsInGoal( point ) )<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsInScriptedState()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks if actor is in a scripted state (animscripted, custom, negotiation)<BR><B>EXAMPLE:  </B>self isInScripteState()<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsKnownEnemyInRadius(<I>&lt;position&gt;</I>,<I>&lt;radius&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; center of radius to check.<LI>        <B>[MANDATORY]</B>  &lt;radius&gt; .</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks if there is a known enemy in a radius for an AI.<BR><B>EXAMPLE:  </B>if ( self IsKnownEnemyInRadius( pos, radius ) ) ...<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsKnownEnemyInVolume(<I>&lt;volume&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;volume&gt; volume entity to check in.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks if there is a known enemy in a volume for an AI.<BR><B>EXAMPLE:  </B>if ( self isKnownEnemyInVolume( volume ) )<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsMoveSuppressed()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this actor is in a suppressed state ( blocked by friendly fire ).<BR><B>EXAMPLE:  </B>while ( self IsMoveSuppressed() )...<BR></OL><P>
<HR><H1>void &lt;sentient&gt; IsNoTarget()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns if the sentient is marked no target<BR><B>EXAMPLE:  </B>if ( self IsNoTarget() )<BR><B>NOTES:  </B>either AI or player<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsPathDirect()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check whether the actor's current path is direct<BR><B>EXAMPLE:  </B>self IsPathDirect()<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsPosAtGoal()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns true/false if position is inside the current goal<BR><B>EXAMPLE:  </B>self IsPosAtGoal(position)<BR></OL><P>
<HR><H1>void &lt;sentient&gt; IsPosInClaimedLocation()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns true/false if position is claimed by another sentient<BR><B>EXAMPLE:  </B>self IsPosInClaimedLocation( position )<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsSafeFromGrenade()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns true/false if actor is within a blast radius of a grenade.<BR><B>EXAMPLE:  </B>self IsSafeFromGrenade()<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsStanceAllowed(<I>&lt;stance&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;stance&gt; (string) A stance, can be 'prone', 'crouch', 'stand'.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this actor can go to the given stance.<BR><B>EXAMPLE:  </B>if ( self IsStanceAllowed( "stand" ) )...<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsSuppressed()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this actor is in a suppressed state ( under fire ).<BR><B>EXAMPLE:  </B>while ( self IsSuppressed() )...<BR></OL><P>
<HR><H1>void &lt;actor&gt; IsSuppressionWaiting()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks whether this actor is still doing suppression wait.<BR><B>EXAMPLE:  </B>while ( self IsSuppressionWaiting() )...<BR></OL><P>
<HR><H1>void &lt;sentient&gt; IsThreateningMyProtectEntity(<I>&lt;target&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target&gt; (sentient) The sentient to check.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the enemy is currently threatening my protect entity.<BR><B>EXAMPLE:  </B>if ( self IsThreateningMyProtectEntity( self.enemy ) )<BR></OL><P>
<HR><H1>void &lt;actor&gt; Knockback(<I>&lt;true/false&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;true/false&gt; if true, actor affected by knockback</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Turn knockback on and off for an actor<BR><B>EXAMPLE:  </B>self Knockback( true )<BR></OL><P>
<HR><H1>void &lt;sentient&gt; LastKnownPos(<I>&lt;target&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target&gt; (sentient) The sentient to check.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Return the last known pos of an AI.<BR><B>EXAMPLE:  </B>if ( self lastKnownPos( player ) )<BR></OL><P>
<HR><H1>void &lt;sentient&gt; LastKnownTime(<I>&lt;target&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target&gt; (sentient) The sentient to check.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Return the last time an AI was aware of target. Includes visibility and ai events like footstep, gunshot etc.<BR><B>EXAMPLE:  </B>if( self lastKnownTime( player ) )<BR></OL><P>
<HR><H1>void &lt;actor&gt; LerpPosition(<I>&lt;origin&gt;</I>,<I>&lt;angles&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt;(vector) the position to interpolate to.<LI>        <B>[MANDATORY]</B>  &lt;angles&gt;(vector) the angles to interpolate to.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Interpolate an actor's position, and angles.<BR><B>EXAMPLE:  </B>self LerpPosition( entry['origin'], entry['angles'] )<BR></OL><P>
<HR><H1>void &lt;actor&gt; MayMoveFromPointToPoint(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>,<I>[check drop]</I>,<I>&lt;Position&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt; (point) start position.<LI>        <B>[MANDATORY]</B>  &lt;end&gt; (point) end position.<LI>        <B>[OPTIONAL]</B>  [check drop] checks if the point would cause the AI to drop. Defaults to true.<LI>        <B>[OPTIONAL]</B>  [check direct] checks if there are no obstructions between actor origin and &lt;Position&gt;.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check whether the actor can move from a given point to a given point. Does not check friendly fire and in goal radius unlike maymovetopoint<BR><B>EXAMPLE:  </B>if ( !self MayMoveFromPointToPoint( startPoint endPoint ) )...<BR></OL><P>
<HR><H1>void &lt;actor&gt; MayMoveToPoint(<I>&lt;position&gt;</I>,<I>[check drop]</I>,<I>&lt;Position&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; (point) The position that the actor may be able to move to.<LI>        <B>[OPTIONAL]</B>  [check drop] checks if the point would cause the AI to drop. Defaults to true.<LI>        <B>[OPTIONAL]</B>  [check direct] checks if there are no obstructions between actor origin and &lt;Position&gt;.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check whether the actor can move to a given point.<BR><B>EXAMPLE:  </B>if ( !self MayMoveToPoint( endPoint ) )...<BR></OL><P>
<HR><H1>entity &lt;actor&gt; Melee(<I>[direction]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [direction] direction to attack, if not specified, uses direction to current enemy.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Makes this actor melee attack. Returns the entity hit, if any.<BR><B>EXAMPLE:  </B>guy Melee()<BR></OL><P>
<HR><H1>entity &lt;actor&gt; MeleeWithOffset(<I>&lt;offset&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;offset&gt; A vector offset added to the actor's eye position from which to start the melee trace.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Makes this actor melee attack. Returns the entity hit, if any.<BR><B>EXAMPLE:  </B>guy MeleeWithOffset( (0,0,32) )<BR></OL><P>
<HR><H1>void &lt;actor&gt; NearClaimNode()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Determine whether this actor is near its claim node.<BR><B>EXAMPLE:  </B>if ( ai NearClaimNode() )...<BR></OL><P>
<HR><H1>void &lt;actor&gt; NearClaimNodeAndAngle()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Determine whether this actor is near its claim node and nearly matches the angle.<BR><B>EXAMPLE:  </B>if ( ai NearClaimNodeAndAngle() )...<BR></OL><P>
<HR><H1>void &lt;actor&gt; NearNode(<I>&lt;node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; The path node to check.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Determine whether this actor is near to a given path node.<BR><B>EXAMPLE:  </B>if ( ai NearNode( node ) )...<BR></OL><P>
<HR><H1>void &lt;actor&gt; OrientMode(<I>&lt;orient mode&gt;</I>,<I>[face angle]</I>,<I>[direction vector]</I>,<I>[face position]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;orient mode&gt; (const string) OrientMode must be 'face angle', 'face current', 'face direction', 'face enemy', 'face enemy or motion', 'face goal', 'face motion', 'face point', or 'face default'<LI>        <B>[OPTIONAL]</B>  [face angle] (float) The yaw angle to face if orient mode is 'face angle'<LI>        <B>[OPTIONAL]</B>  [direction vector] (vector) The direction vector to face if orient mode is 'face direction'<LI>        <B>[OPTIONAL]</B>  [face position] (vector) The point to face if orient mode is 'face point'</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the orient mode of this actor.<BR><B>EXAMPLE:  </B>randAlly OrientMode("face direction", player.origin-randAlly.origin )<BR></OL><P>
<HR><H1>void &lt;actor&gt; PathMode(<I>&lt;path mode&gt;</I>,<I>[clear path]</I>,<I>[path delay]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;path mode&gt; (const string) PathMode must be 'dont move', 'move allowed', or 'move delayed'<LI>        <B>[OPTIONAL]</B>  [clear path] (integer) 1 to clear path<LI>        <B>[OPTIONAL]</B>  [path delay] (float) Amount of time (seconds) to wait if path mode is 'move delayed'</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the path mode of this actor.<BR><B>EXAMPLE:  </B>randAlly PathMode("dont move")<BR></OL><P>
<HR><H1>void &lt;actor&gt; PickUpGrenade()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Pick up a grenade<BR><B>EXAMPLE:  </B>self PickUpGrenade()<BR></OL><P>
<HR><H1>void &lt;actor&gt; PredictArrival()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Predicts the arrival direction vector using havok corner predictor.<BR></OL><P>
<HR><H1>void &lt;actor&gt; PredictExit()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Predicts the exit direction vector using havok corner predictor.<BR><B>EXAMPLE:  </B>predictedLookAheadInfo = self PredictExit()<BR></OL><P>
<HR><H1>void &lt;actor&gt; PredictPath()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Predicts the path to look for upcoming corner using havok corner predictor.<BR><B>EXAMPLE:  </B>predictedLookAheadInfo = self PredictPath()<BR></OL><P>
<HR><H1>void &lt;actor&gt; PushPlayer(<I>&lt;can push player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;can push player&gt;(bool) True if this character can push the player.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set whether this character can push the player. Don't call this unless you know what you are doing.<BR><B>EXAMPLE:  </B>level.elder PushPlayer( true )<BR></OL><P>
<HR><H1>void &lt;actor&gt; ReacquireMove()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Start the reaquire move<BR></OL><P>
<HR><H1>void &lt;actor&gt; ReacquireStep(<I>&lt;dist&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;dist&gt;(floating point number) amount to side step left or right</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Do side step move to safe place left or right while facing enemy.<BR><B>EXAMPLE:  </B>reacquirePos = entity ReacquireStep( step_size )<BR></OL><P>
<HR><H1>void &lt;sentient&gt; RemoveSentientEventListener(<I>[event]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [event] The event name</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>De-Registers entity to listen to a specific event. if event is undefined, entity will stop listening to all the evnets.<BR><B>EXAMPLE:  </B>self RemoveSentientEventListener("bulletwhizby")<BR></OL><P>
<HR><H1>void ResetVisibilityCacheWithinRadius(<I>&lt;origin&gt;</I>,<I>&lt;radius&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; Center of reset bounds<LI>        <B>[MANDATORY]</B>  &lt;radius&gt; Distance around the origin to scan for sentients</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Reset the viscache for sentients within the specified radius<BR><B>EXAMPLE:  </B>ResetVisibilityCacheWithinRadius(origin, 500)<BR></OL><P>
<HR><H1>void &lt;sentient&gt; SeeRecently(<I>&lt;target&gt;</I>,<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target&gt; (entity) The entity to check.<LI>        <B>[MANDATORY]</B>  &lt;time&gt; (int) seconds.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check to see if the AI saw the given sentient in the past &lt;time&gt;. If called on a non-sentient, just does a cansee check<BR><B>EXAMPLE:  </B>if( self SeeRecently( player ) )<BR></OL><P>
<HR><H1>void &lt;actor&gt; SetEntityOwner(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity for owner.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set an entity as the AI's owner. The owner will never be targeted.<BR><B>EXAMPLE:  </B>self SetEntityOwner( vehicle_entity )<BR></OL><P>
<HR><H1>void &lt;actor&gt; SetEntityTarget(<I>&lt;entity&gt;</I>,<I>[threat]</I>,<I>[tag name]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; An entity to target (cannot be server only entity).<LI>        <B>[OPTIONAL]</B>  [threat] A fraction of maximum possible threat an AI can have. Must be in 0 to 1 range. Defaults to 1.<LI>        <B>[OPTIONAL]</B>  [tag name] Tag to aim/shoot at on this entity. Defaults to tag_eye for actors/players".</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set an entity as the AI's target. This is for special cases only. Do not set AI or player targets with this.<BR><B>EXAMPLE:  </B>self SetEntityTarget( vehicle_entity, 0.7, "tag_head" )<BR></OL><P>
<HR><H1>void &lt;actor&gt; SetFixedNodeSafeVolume(<I>&lt;volume entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;volume entity&gt;(entity) The safe volume entity.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set this actor's fixed node safe volume.<BR><B>EXAMPLE:  </B>self SetFixedNodeSafeVolume( volume )<BR></OL><P>
<HR><H1>void &lt;actor&gt; SetFlashBanged(<I>&lt;flashed&gt;</I>,<I>[strength]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flashed&gt; Whether or not the actor is under the affect of a flashbang.<LI>        <B>[OPTIONAL]</B>  [strength] If actor is flashed, how severely they were initially affected. Between 0.0 and 1.0 (full strength).</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether an actor is under a flashbang effect.<BR><B>EXAMPLE:  </B>self SetFlashBanged( true, 0.8 )<BR></OL><P>
<HR><H1>void &lt;actor&gt; SetFlashbangImmunity(<I>&lt;immune&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;immune&gt; If the actor can be affected by flashbangs.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether an actor is succeptable to flashbangs.<BR><B>EXAMPLE:  </B>level.suicideguy SetFlashbangImmunity( true )<BR></OL><P>
<HR><H1>void &lt;actor&gt; SetFreeCameraLockOnAllowed(<I>&lt;allowed&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;allowed&gt; boolean of whether it is allowed</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether the ai is allowed to be locked onto in the demo free camera<BR></OL><P>
<HR><H1>void &lt;sentient&gt; SetGoal(<I>&lt;pos&gt;</I>,<I>[forced]</I>,<I>[goalradius]</I>,<I>[goalheight]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;pos&gt;/&lt;node&gt;/&lt;entity&gt;/&lt;volume&gt;<LI>        <B>[OPTIONAL]</B>  [forced](bool) should go directly to this pos/node/entity. Forced means AI will get within approx 4 units of the entity.<LI>        <B>[OPTIONAL]</B>  [goalradius] radius of the goal. Applicable for entity and position/node and not the volume or forcedGoal.<LI>        <B>[OPTIONAL]</B>  [goalheight] height of the goal. Applicable for entity and position/node and not the volume or forcedGoal.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set this AI 's goal. Any of the above function name will work. They all call into SetGoal function internally.<BR><B>EXAMPLE:  </B>self SetGoal( node )<BR></OL><P>
<HR><H1>void &lt;sentient&gt; setgoalentity(<I>&lt;pos&gt;</I>,<I>[forced]</I>,<I>[goalradius]</I>,<I>[goalheight]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;pos&gt;/&lt;node&gt;/&lt;entity&gt;/&lt;volume&gt;<LI>        <B>[OPTIONAL]</B>  [forced](bool) should go directly to this pos/node/entity. Forced means AI will get within approx 4 units of the entity.<LI>        <B>[OPTIONAL]</B>  [goalradius] radius of the goal. Applicable for entity and position/node and not the volume or forcedGoal.<LI>        <B>[OPTIONAL]</B>  [goalheight] height of the goal. Applicable for entity and position/node and not the volume or forcedGoal.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set this AI 's goal. Any of the above function name will work. They all call into SetGoal function internally.<BR><B>EXAMPLE:  </B>self SetGoal( node )<BR></OL><P>
<HR><H1>void &lt;sentient&gt; setgoalnode(<I>&lt;pos&gt;</I>,<I>[forced]</I>,<I>[goalradius]</I>,<I>[goalheight]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;pos&gt;/&lt;node&gt;/&lt;entity&gt;/&lt;volume&gt;<LI>        <B>[OPTIONAL]</B>  [forced](bool) should go directly to this pos/node/entity. Forced means AI will get within approx 4 units of the entity.<LI>        <B>[OPTIONAL]</B>  [goalradius] radius of the goal. Applicable for entity and position/node and not the volume or forcedGoal.<LI>        <B>[OPTIONAL]</B>  [goalheight] height of the goal. Applicable for entity and position/node and not the volume or forcedGoal.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set this AI 's goal. Any of the above function name will work. They all call into SetGoal function internally.<BR><B>EXAMPLE:  </B>self SetGoal( node )<BR></OL><P>
<HR><H1>void &lt;sentient&gt; setgoalpos(<I>&lt;pos&gt;</I>,<I>[forced]</I>,<I>[goalradius]</I>,<I>[goalheight]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;pos&gt;/&lt;node&gt;/&lt;entity&gt;/&lt;volume&gt;<LI>        <B>[OPTIONAL]</B>  [forced](bool) should go directly to this pos/node/entity. Forced means AI will get within approx 4 units of the entity.<LI>        <B>[OPTIONAL]</B>  [goalradius] radius of the goal. Applicable for entity and position/node and not the volume or forcedGoal.<LI>        <B>[OPTIONAL]</B>  [goalheight] height of the goal. Applicable for entity and position/node and not the volume or forcedGoal.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set this AI 's goal. Any of the above function name will work. They all call into SetGoal function internally.<BR><B>EXAMPLE:  </B>self SetGoal( node )<BR></OL><P>
<HR><H1>void &lt;sentient&gt; setgoalvolume(<I>&lt;pos&gt;</I>,<I>[forced]</I>,<I>[goalradius]</I>,<I>[goalheight]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;pos&gt;/&lt;node&gt;/&lt;entity&gt;/&lt;volume&gt;<LI>        <B>[OPTIONAL]</B>  [forced](bool) should go directly to this pos/node/entity. Forced means AI will get within approx 4 units of the entity.<LI>        <B>[OPTIONAL]</B>  [goalradius] radius of the goal. Applicable for entity and position/node and not the volume or forcedGoal.<LI>        <B>[OPTIONAL]</B>  [goalheight] height of the goal. Applicable for entity and position/node and not the volume or forcedGoal.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set this AI 's goal. Any of the above function name will work. They all call into SetGoal function internally.<BR><B>EXAMPLE:  </B>self SetGoal( node )<BR></OL><P>
<HR><H1>void &lt;sentient&gt; setgoalvolumeauto(<I>&lt;pos&gt;</I>,<I>[forced]</I>,<I>[goalradius]</I>,<I>[goalheight]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;pos&gt;/&lt;node&gt;/&lt;entity&gt;/&lt;volume&gt;<LI>        <B>[OPTIONAL]</B>  [forced](bool) should go directly to this pos/node/entity. Forced means AI will get within approx 4 units of the entity.<LI>        <B>[OPTIONAL]</B>  [goalradius] radius of the goal. Applicable for entity and position/node and not the volume or forcedGoal.<LI>        <B>[OPTIONAL]</B>  [goalheight] height of the goal. Applicable for entity and position/node and not the volume or forcedGoal.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set this AI 's goal. Any of the above function name will work. They all call into SetGoal function internally.<BR><B>EXAMPLE:  </B>self SetGoal( node )<BR></OL><P>
<HR><H1>void &lt;sentient&gt; SetIgnoreEnt(<I>&lt;sentient&gt;</I>,<I>&lt;ignored&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;sentient&gt; Another sentient entity<LI>        <B>[MANDATORY]</B>  &lt;ignored&gt; true/false</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set a sentient entity to ignore another specific sentient entity or not<BR><B>EXAMPLE:  </B>aiGuy SetIgnoreEnt( player, true )<BR></OL><P>
<HR><H1>void SetIgnoreMeGroup(<I>&lt;ignored group&gt;</I>,<I>&lt;ignoring group&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;ignored group&gt;(string) ignored group.<LI>        <B>[MANDATORY]</B>  &lt;ignoring group&gt;(string) ignoring group.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Make first group ignored by second group<BR><B>EXAMPLE:  </B>SetIgnoreMeGroup( "flanking_team", "axis" )<BR></OL><P>
<HR><H1>void &lt;sentient&gt; SetPersonalIgnore(<I>&lt;sentient&gt;</I>,<I>&lt;enemy&gt;</I>,<I>[duration]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;sentient&gt; Self<LI>        <B>[MANDATORY]</B>  &lt;enemy&gt; The enemy to set threat bias for<LI>        <B>[OPTIONAL]</B>  [duration] How long this threat bias lasts in seconds</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>self will not pick enemy as target for the duration<BR><B>EXAMPLE:  </B>self SetPersonalIgnore( self.enemy, 5 )<BR></OL><P>
<HR><H1>void &lt;sentient&gt; SetPersonalThreatBias(<I>&lt;sentient&gt;</I>,<I>&lt;enemy&gt;</I>,<I>&lt;threatBias&gt;</I>,<I>[duration]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;sentient&gt; Self<LI>        <B>[MANDATORY]</B>  &lt;enemy&gt; The enemy to set threat bias for<LI>        <B>[MANDATORY]</B>  &lt;threatBias&gt; The threat bias amount<LI>        <B>[OPTIONAL]</B>  [duration] How long this threat bias lasts in seconds</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets a personal threat bias for this sentient versus the other sentient.  It lasts for the given duration.<BR><B>EXAMPLE:  </B>self SetPersonalThreatBias( self.enemy, -1000 )<BR></OL><P>
<HR><H1>void &lt;actor&gt; SetPhysParams(<I>&lt;radius&gt;</I>,<I>&lt;minsz&gt;</I>,<I>&lt;maxsz&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;radius&gt; size of the actor.<LI>        <B>[MANDATORY]</B>  &lt;minsz&gt; min height of the actor.<LI>        <B>[MANDATORY]</B>  &lt;maxsz&gt; max height of the actor.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the collision bounds for an actor.<BR><B>EXAMPLE:  </B>self setPhysParams( 15, 0, 72 )<BR></OL><P>
<HR><H1>void &lt;actor&gt; SetPitchOrient()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set pitch orientation<BR><B>EXAMPLE:  </B>self setPitchOrient()<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetPotentialThreat(<I>&lt;dir&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;dir&gt; direction of the threat. This is the angle from which the NPC should expect danger</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>In non-combat situations. This is mostly useful for friendlies.<BR><B>EXAMPLE:  </B>self SetPotentialThreat( 90 )<BR></OL><P>
<HR><H1>void &lt;actor&gt; SetRepairPaths(<I>&lt;on_off&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;on_off&gt; true to enable repair paths, false otherwise</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>True allows havok to repath automatically if the AI moves off their predefined path.<BR><B>EXAMPLE:  </B>self SetRepairPaths( true )<BR></OL><P>
<HR><H1>void &lt;actor&gt; SetStairsExitTransform()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the base transform for the exit stairs animation using the current position in the looping anim<BR><B>EXAMPLE:  </B>self SetStairsExitTransform()<BR></OL><P>
<HR><H1>void SetStealthSight(<I>&lt;awareness&gt;</I>,<I>&lt;timeDecay&gt;</I>,<I>&lt;timeDistMin&gt;</I>,<I>&lt;timeDistMax&gt;</I>,<I>&lt;distMin&gt;</I>,<I>&lt;distMax&gt;</I>,<I>&lt;extendSight&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;awareness&gt; "unaware", "low_alert", "high_alert", or "combat"<LI>        <B>[MANDATORY]</B>  &lt;timeDecay&gt; float value of seconds stealth sight takes to fall off completely (0 for never/infinite)<LI>        <B>[MANDATORY]</B>  &lt;timeDistMin&gt; float value of seconds stealth sight takes to grow completely at min range (0 for never/infinite)<LI>        <B>[MANDATORY]</B>  &lt;timeDistMax&gt; float value of seconds stealth sight takes to grow completely at max range (0 for never/infinite)<LI>        <B>[MANDATORY]</B>  &lt;distMin&gt; float value of the min distance<LI>        <B>[MANDATORY]</B>  &lt;distMax&gt; float value of the max distance<LI>        <B>[OPTIONAL]</B>  &lt;extendSight&gt; indicates of sight continues beyond max range at the max rate</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the parameters for given awarenesslevel of stealth sight when active on an sentient<BR><B>EXAMPLE:  </B>SetStealthSight( "high_alert", 2, 1, 10, 200, 1000 )<BR></OL><P>
<HR><H1>void &lt;sentient&gt; SetStealthSightAwareness(<I>[awareness]</I>,<I>[decayEnabled]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [awareness] "unaware", "low_alert", "high_alert", "combat", or undefined to disable it (default disabled)<LI>        <B>[OPTIONAL]</B>  [decayEnabled] if true stealth sight will decay when other sentient is not in sight (default true)</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the current stealth sight awareness state for this sentient<BR><B>EXAMPLE:  </B>aiGuy SetStealthSightAwareness( "unaware", true )<BR></OL><P>
<HR><H1>void &lt;sentient&gt; SetStealthSightValue(<I>&lt;otherSentient&gt;</I>,<I>&lt;newValue&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;otherSentient&gt; other sentient you want to set the value on this sentient for<LI>        <B>[MANDATORY]</B>  &lt;newValue&gt; The new stealth sight value</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the current stealth sight value for this sentient seeing another sentient (floating point from 0.0 to 1.0)<BR><B>EXAMPLE:  </B>aiGuy SetStealthSightValue( forOtherGuy, 0.5 )<BR></OL><P>
<HR><H1>void &lt;actor&gt; SetSteeringMode(<I>&lt;steering mode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;steering mode&gt; Mode to set.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the steering mode for the actor.  Valid modes are "normal steering", "slow steering", "vignette steering".<BR><B>EXAMPLE:  </B>self SetSteeringMode( "slow steering" )<BR></OL><P>
<HR><H1>void SetThreatBias(<I>&lt;against group&gt;</I>,<I>&lt;for group&gt;</I>,<I>&lt;threat bias&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;against group&gt; (string) threat bias group against.<LI>        <B>[MANDATORY]</B>  &lt;for group&gt; (string) threat bias group for.<LI>        <B>[MANDATORY]</B>  &lt;threat bias&gt; (int) threat bias value.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set threat bias of second group against first group<BR><B>EXAMPLE:  </B>SetThreatBias( "axis", "flanking_team", 120 )<BR></OL><P>
<HR><H1>void SetThreatBiasAgainstAll(<I>&lt;group&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;group&gt; (string) threat bias group name.<LI>        <B>[MANDATORY]</B>  &lt;value&gt; (int) threat bias value.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the threatbias a group has against all others<BR><B>EXAMPLE:  </B>SetThreatBiasAgainstAll( "flanking_team", 120 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetThreatBiasGroup(<I>[threat_bias_group]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [threat_bias_group](string) threat bias group name. If none, remove actor from current threat bias group</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set or clear threat bias group of an AI or player<BR><B>EXAMPLE:  </B>SetThreatBiasGroup( "flanking_team" )<BR></OL><P>
<HR><H1>void &lt;actor&gt; Shoot(<I>[accuracy modifier]</I>,<I>[shoot override vector[ (vector) The shoot vector</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [accuracy modifier] (floating point number)<LI>        <B>[OPTIONAL]</B>  [shoot override vector[ (vector) The shoot vector</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Makes this actor shoot.<BR><B>EXAMPLE:  </B>guy shoot()<BR></OL><P>
<HR><H1>void &lt;actor&gt; ShouldFaceMotion()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Determines if the AI should face the motion direction. Use self.faceMotion instead of this except when the AI is just beginning to move.<BR><B>EXAMPLE:  </B>self ShouldFaceMotion()<BR></OL><P>
<HR><H1>void &lt;actor&gt; ShouldHoldGroundAgainstEnemy()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Return true if enemy is within pathEnemyFightDist.<BR><B>EXAMPLE:  </B>if( behaviorTreeEntity ShouldHoldGroundAgainstEnemy() )<BR></OL><P>
<HR><H1>void &lt;actor&gt; ShouldStartArrival()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns true/false if actor should start arriving at given node<BR><B>EXAMPLE:  </B>self ShouldStartArrival()<BR></OL><P>
<HR><H1>void &lt;actor&gt; ShouldStartTraversal()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns true/false if actor should start traversal<BR><B>EXAMPLE:  </B>self ShouldStartTraversal()<BR></OL><P>
<HR><H1>void &lt;actor&gt; ShouldUseCoverNode()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns true/false if actor is at is safe at cover node and use it as a cover<BR><B>EXAMPLE:  </B>self ShouldUseCoverNode()<BR></OL><P>
<HR><H1>void &lt;actor&gt; StartCoverArrival(<I>&lt;start pos&gt;</I>,<I>&lt;yaw angles&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start pos&gt; the offset to start the arrival animation from<LI>        <B>[MANDATORY]</B>  &lt;yaw angles&gt; the arrival angle</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Runs cover arrival animscript on an actor.<BR><B>EXAMPLE:  </B>soldier StartCoverArrival( pos, 45 )<BR></OL><P>
<HR><H1>void &lt;actor&gt; Teleport(<I>&lt;position&gt;</I>,<I>[angles]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; (point) The actor's new position.<LI>        <B>[OPTIONAL]</B>  [angles] (vector) The actor's new angles.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Teleport the actor to a new position with the given origin and angles.<BR><B>EXAMPLE:  </B>self Teleport( org, angles )<BR></OL><P>
<HR><H1>void ThreatBiasGroupExists(<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; threat bias group name.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if a threat bias group exists<BR><B>EXAMPLE:  </B>ThreatBiasGroupExists( "flanking_team" )<BR></OL><P>
<HR><H1>void &lt;actor&gt; TraverseMode(<I>&lt;traverse mode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;traverse mode&gt; (const string) Possible traverse modes are 'gravity', 'nogravity', or 'noclip'</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the traverse mode of this actor.<BR><B>EXAMPLE:  </B>self TraverseMode( "nogravity" )<BR></OL><P>
<HR><H1>void &lt;actor&gt; TrimPathtoAttack()</H1><OL><UL></UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Trims the path to attack.<BR></OL><P>
<HR><H1>void &lt;actor&gt; UseCoverNode(<I>&lt;path node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;path node&gt; The path node to use as cover</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Tells this actor to use the given cover node. This is invalid if the actor's keepclaimednode flag is set. Returns true or false depending on whether the actor can claim the node.<BR><B>EXAMPLE:  </B>guy UseCoverNode( covernode )<BR></OL><P>
<HR><H1>void &lt;actor&gt; UsePosition(<I>&lt;position&gt;</I>,<I>[arrivalfinalposition]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; The position for the actor to run to.<LI>        <B>[OPTIONAL]</B>  [arrivalfinalposition] The arrivalfinalposition if this is an arrival.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Override where the actor should run to. This overrides the goal pos and the claimed node.<BR><B>EXAMPLE:  </B>self UsePosition( pos )<BR></OL><P>
<HR><H1>void &lt;actor&gt; UseReacquireNode(<I>&lt;node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt;(path node) the node to use.</UL><B>CATEGORY:  </B>AI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Use the given reacquire node.<BR></OL><P>
<HR><H1>void AddBoltedFXExclusionVolume(<I>&lt;localClientNum&gt;</I>,<I>&lt;entity&gt;</I>,<I>&lt;tag name&gt;</I>,<I>&lt;half extents&gt;</I>,<I>&lt;offset&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client to create the volume on.<LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The entity to attach the volume to.<LI>        <B>[MANDATORY]</B>  &lt;tag name&gt; The tag to use as the volume's origin.<LI>        <B>[MANDATORY]</B>  &lt;half extents&gt; The half extents of the volume.<LI>        <B>[OPTIONAL]</B>  &lt;offset&gt; An offset from the tag name for the volume's origin; default is 0 0 0.</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Create a bolted volume that will exclude FX that are flagged as "Respect Exclusion Volumes". Returns volume ID.<BR><B>EXAMPLE:  </B>volumeID = AddBoltedFXExclusionVolume( 0, entity, tag_origin, (10, 10, 10) )<BR></OL><P>
<HR><H1>void &lt;entity&gt; AddDuplicateRenderOption(<I>&lt;dupeType&gt;</I>,<I>&lt;dupeMethod&gt;</I>,<I>&lt;mappedMaterialId&gt;</I>,<I>&lt;dupeCull&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;dupeType&gt; this is one of [DR_TYPE_FRAMEBUFFER|DR_TYPE_FRAMEBUFFER_DUPLICATE|DR_TYPE_OFFSCREEN], as defined in _duplicaterender.csc. Sets the duplicate type of this call<LI>        <B>[MANDATORY]</B>  &lt;dupeMethod&gt; this is one of [DR_CULL_ALWAYS|DR_CULL_NEVER], as defined in _duplicaterender.csc. Sets the render method of this call<LI>        <B>[OPTIONAL]</B>  &lt;mappedMaterialId&gt; This is the mapped material id<LI>        <B>[OPTIONAL]</B>  &lt;dupeCull&gt; this is one of [DR_METHOD_OFF|DR_METHOD_DEFAULT_MATERIAL|DR_METHOD_THERMAL_MATERIAL|DR_METHOD_CUSTOM_MATERIAL|DR_METHOD_FORCE_CUSTOM_MATERIAL], as defined in _duplicaterender.csc. Sets the render method of this call</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Add a duplicate render option for the entity<BR><B>EXAMPLE:  </B>myEnt AddDuplicateRenderOption( DR_TYPE_FRAMEBUFFER, DR_METHOD_THERMAL_MATERIAL, DR_CULL_ALWAYS )myEnt AddDuplicateRenderOption( DR_TYPE_OFFSCREEN, DR_METHOD_CUSTOM_MATERIAL, DR_CULL_NEVER, mapped_material_id(player,"gfx_my_material_2") )<BR></OL><P>
<HR><H1>void AddFXExclusionVolume(<I>&lt;localClientNum&gt;</I>,<I>&lt;center&gt;</I>,<I>&lt;angles&gt;</I>,<I>&lt;half extents&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client to create the volume on.<LI>        <B>[MANDATORY]</B>  &lt;center&gt; The center of the volume.<LI>        <B>[MANDATORY]</B>  &lt;angles&gt; The rotation angles of the volume.<LI>        <B>[MANDATORY]</B>  &lt;half extents&gt; The half extents of the volume.</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Create a volume that will exclude FX that are flagged as "Respect Exclusion Volumes". Returns volume ID.<BR><B>EXAMPLE:  </B>volumeID = AddFXExclusionVolume( 0, (0,0,0), (0, 45, 0), (10, 10, 10) )<BR></OL><P>
<HR><H1>void BeamKill(<I>&lt;localClientNum&gt;</I>,<I>&lt;beam handle&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client on which to play the beam<LI>        <B>[MANDATORY]</B>  &lt;beam handle&gt; The beam handle</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Kill the previously launched beam.<BR><B>EXAMPLE:  </B>BeamKill(0, beamHandle)<BR></OL><P>
<HR><H1>void BeamLaunch(<I>&lt;localClientNum&gt;</I>,<I>&lt;entity from&gt;</I>,<I>&lt;tag from&gt;</I>,<I>&lt;entity to&gt;</I>,<I>&lt;tag to&gt;</I>,<I>&lt;beam&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client on which to play the beam<LI>        <B>[MANDATORY]</B>  &lt;entity from&gt; The originating entity<LI>        <B>[MANDATORY]</B>  &lt;tag from&gt; The tag on the originating entity to start from<LI>        <B>[MANDATORY]</B>  &lt;entity to&gt; The target entity<LI>        <B>[MANDATORY]</B>  &lt;tag to&gt; The target tag<LI>        <B>[MANDATORY]</B>  &lt;beam&gt; The beam</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Launch this beam and return the internal handle.<BR><B>EXAMPLE:  </B>handle = BeamLaunch(0, launcher, launcherTag, target, targetTag, beam)<BR></OL><P>
<HR><H1>void BulletTracer(<I>&lt;start&gt;</I>,<I>&lt;end&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start&gt; The starting point bullet tracer<LI>        <B>[MANDATORY]</B>  &lt;end&gt; The end point bullet tracer</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>creates a bullet tracer from the start to end point<BR><B>EXAMPLE:  </B>BulletTracer(self.origin, target.origin)<BR></OL><P>
<HR><H1>void CaptureFrame(<I>&lt;localClientNum&gt;</I>,<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt;<LI>        <B>[MANDATORY]</B>  &lt;name&gt; The code image name</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Captures the current frame into the given code image - he image had to be already created with CreateSceneCodeImage()<BR><B>EXAMPLE:  </B>CaptureFrame( self.localClientNum, "freezeFrame" )<BR></OL><P>
<HR><H1>void ClearExtraCam()</H1><OL><UL></UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Finds the extracam associated with an entity and removes it<BR><B>EXAMPLE:  </B>cameraEnt ClearExtraCam()<BR></OL><P>
<HR><H1>void &lt;entity&gt; codeplaypostfxbundle()</H1><OL><UL></UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Displays a postfx on the screen <BR><B>EXAMPLE:  </B>entity PlayPostfxBundle( "myBundle" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; codestoppostfxbundle()</H1><OL><UL></UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Ends a postfx <BR><B>EXAMPLE:  </B>entity StopPostfxBundle( 2 )<BR></OL><P>
<HR><H1>void CreateSceneCodeImage(<I>&lt;localClientNum&gt;</I>,<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt;<LI>        <B>[MANDATORY]</B>  &lt;name&gt; A unique name</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Creates a scene size code image<BR><B>EXAMPLE:  </B>CreateSceneCodeImage( self.localClientNum, "freezeFrame" )<BR></OL><P>
<HR><H1>void DeleteFX(<I>&lt;localClientNum&gt;</I>,<I>&lt;effect id&gt;</I>,<I>[deleteImmediate]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; client on which to spawn effect.<LI>        <B>[MANDATORY]</B>  &lt;effect id&gt; The effect id returned by spawnfx<LI>        <B>[OPTIONAL]</B>  [deleteImmediate] whether effect will be deleted immediately. Default is 1.</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Delete a spawned effect.<BR><B>EXAMPLE:  </B>deletefx (0, fxRef)<BR></OL><P>
<HR><H1>void &lt;entity&gt; DisableDuplicateRendering()</H1><OL><UL></UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Disables duplicate rendering for the entity<BR><B>EXAMPLE:  </B>entity DisableDuplicateRendering()<BR></OL><P>
<HR><H1>void EnableFrontendLockedWeaponOverlay(<I>&lt;localClientNum&gt;</I>,<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt;<LI>        <B>[MANDATORY]</B>  &lt;enable&gt; 0-disable 1-enable</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Enable or disable the draw of the locked gun postfx in script.<BR><B>EXAMPLE:  </B>entity EnableFrontendLockedWeaponOverlay( 0, 0 )<BR></OL><P>
<HR><H1>void EnableFrontendStreamingOverlay(<I>&lt;localClientNum&gt;</I>,<I>&lt;enable&gt;</I>,<I>&lt;extracam&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt;<LI>        <B>[MANDATORY]</B>  &lt;enable&gt; 0-disable 1-enable<LI>        <B>[OPTIONAL]</B>  &lt;extracam&gt; 0-disable 1-enable - when enabled the overlay is drawn on extracam</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Enable or disable the draw of an alternate draw mode for high detail entities marked to use alt draw<BR><B>EXAMPLE:  </B>entity EnableFrontendStreamingOverlay( 0, 0 )<BR></OL><P>
<HR><H1>void EnableFrontendTokenLockedWeaponOverlay(<I>&lt;localClientNum&gt;</I>,<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt;<LI>        <B>[MANDATORY]</B>  &lt;enable&gt; 0-disable 1-enable</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Enable or disable the draw of the purchaseable gun postfx in script.<BR><B>EXAMPLE:  </B>entity EnableFrontendTokenLockedWeaponOverlay( 0, 0 )<BR></OL><P>
<HR><H1>void EnableThermalDraw(<I>&lt;localClientNum&gt;</I>,<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt;<LI>        <B>[MANDATORY]</B>  &lt;enable&gt; true/false</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Enables or disables the drawing entities into the thermal buffer<BR><B>EXAMPLE:  </B>EnableThermalDraw( player.localClientNum, true )<BR></OL><P>
<HR><H1>void &lt;entity&gt; EVEnable(<I>1 to enable,  0 to disable</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  1 to enable,  0 to disable</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Enable or disable ev mode<BR><B>EXAMPLE:  </B>entity EVEnable( 1 )<BR></OL><P>
<HR><H1>void EvStatus(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client to find the status of</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>returns the status of EV<BR><B>EXAMPLE:  </B>status = EVStatus( 1 )<BR></OL><P>
<HR><H1>void FindStaticModelIndex(<I>&lt;vector pos&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;vector pos&gt; The position to match to the static model origin or &lt;string targetname&gt; for the targetname of the static model</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns an index of a static model whose origin matches the passed in position<BR><B>EXAMPLE:  </B>smodelIndex = FindStaticModelIndex()<BR></OL><P>
<HR><H1>void FindStaticModelIndexArray(<I>&lt;string targetname&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string targetname&gt; The targetname of the static model's</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns an array indices of a static model whose name matches the passed in string<BR><B>EXAMPLE:  </B>smodelIndexArray = FindStaticModelIndex()<BR><B>NOTES:  </B>This function is potentially very expensive to call.  And, since it can directly impact frame rate due to it running on the client side, you should pre-cache the results during level init and use the results when needed rather than calling at that moment.<BR></OL><P>
<HR><H1>void FindVolumeDecalIndexArray(<I>&lt;string targetname&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string targetname&gt; The targetname of the volume decal</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns an array indices of a volume decal whose targetname matches the passed in string<BR><B>EXAMPLE:  </B>vdIndexArray = FindVolumeDecalIndexArray( "foo" )<BR><B>NOTES:  </B>This function is potentially very expensive to call.  And, since it can directly impact frame rate due to it running on the client side, you should pre-cache the results during level init and use the results when needed rather than calling at that moment.<BR></OL><P>
<HR><H1>void FreeCodeImage(<I>&lt;localClientNum&gt;</I>,<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt;<LI>        <B>[MANDATORY]</B>  &lt;name&gt; A unique name</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Frees a code image<BR><B>EXAMPLE:  </B>FreeCodeImage( self.localClientNum, "freezeFrame" )<BR></OL><P>
<HR><H1>void GetCameraSpikeCamStatic(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the camera-spike cam owner</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns 1 if a client sees static on the camera-spike cam, 0 otherwise<BR><B>EXAMPLE:  </B>GetCameraSpikeCamStatic( localClientNum )<BR></OL><P>
<HR><H1>void GetFXFromSurfaceTable(<I>&lt;surfacefxtable&gt;</I>,<I>&lt;surface type&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;surfacefxtable&gt; Surface fx table.<LI>        <B>[MANDATORY]</B>  &lt;surface type&gt; Surface type</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the fx for a given surface type from the surfacefxtable.<BR><B>EXAMPLE:  </B>fx = GetFXFromSurfaceTable( fx_surface_table, surface_type )<BR></OL><P>
<HR><H1>void GetServerVolumetricFogDensity(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Get the density of server volumetric fog<BR></OL><P>
<HR><H1>void GetSurfaceStrings()</H1><OL><UL></UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns an array containing all the surface names<BR><B>EXAMPLE:  </B>surfaceStringArray = GetSurfaceStrings()<BR></OL><P>
<HR><H1>void GetVisionSetNaked(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client which will have his vampire vision set changed</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Gets players' naked vision.<BR><B>EXAMPLE:  </B>GetVisionSetNaked( 0 )<BR></OL><P>
<HR><H1>void GetWorldFogScriptID(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; the local client</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>current active .fsi fog volumes script identity value -1 = global volume.<BR></OL><P>
<HR><H1>void HideStaticModel(<I>&lt;smodelIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;smodelIndex&gt; The index of the static model to toggle</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Hide a static model<BR><B>EXAMPLE:  </B>HideStaticModel( model )<BR></OL><P>
<HR><H1>void HideVolumeDecal(<I>&lt;volume decal Index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;volume decal Index&gt; The index of the volume decal to toggle</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Hide a static model<BR><B>EXAMPLE:  </B>HideStaticModel( model )<BR></OL><P>
<HR><H1>void IGCActive(<I>&lt;localClientNum&gt;</I>,<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client on which the igc is running<LI>        <B>[MANDATORY]</B>  &lt;enable&gt; 1-enables, 0-disables</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Flags if an IGC is on or off<BR><B>EXAMPLE:  </B>IGCActive( 1, 1 )<BR></OL><P>
<HR><H1>void IsFXPlaying(<I>&lt;localClientNum&gt;</I>,<I>&lt;effect id&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client the effect is playing on.<LI>        <B>[MANDATORY]</B>  &lt;effect id&gt; The effect id returned by playFx</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Return true if effect is still playing.<BR><B>EXAMPLE:  </B>IsFXPlaying ( fxId )<BR></OL><P>
<HR><H1>void IsIGCActive(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client to find the status of</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>returns the status of EV<BR><B>EXAMPLE:  </B>status = IsIGCActive( 1 )<BR></OL><P>
<HR><H1>void IsStereoOn()</H1><OL><UL></UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if the stereo is on<BR><B>EXAMPLE:  </B>isStereo = IsStereoOn()<BR></OL><P>
<HR><H1>void KillFX(<I>&lt;localClientNum&gt;</I>,<I>&lt;effect id&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client the effect is playing on.<LI>        <B>[MANDATORY]</B>  &lt;effect id&gt; The effect id returned by playFx</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Force kills a given fx.<BR><B>EXAMPLE:  </B>KillFX ( fxId )<BR></OL><P>
<HR><H1>void KillRadiantExploder(<I>&lt;localClientNum&gt;</I>,<I>&lt;exploderId&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client to play the effect on<LI>        <B>[MANDATORY]</B>  &lt;exploderId&gt; The id of the exploder to be stopped.</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Kill the specified Radiant exploder<BR><B>EXAMPLE:  </B>KillRadiantExploder( 0, "lights_on_exploder" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; MakeLight(<I>&lt;primaryLightIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;primaryLightIndex&gt; The Primary Light Index</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Create a light<BR><B>EXAMPLE:  </B>self MakeLight(1)<BR></OL><P>
<HR><H1>void MapMaterialIndex(<I>&lt;localClientNum&gt;</I>,<I>&lt;materialName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client on which to map the material<LI>        <B>[MANDATORY]</B>  &lt;materialName&gt; Material to map</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Maps the material to an index<BR><B>EXAMPLE:  </B>index = MapMaterial(1, "mymaterial")<BR></OL><P>
<HR><H1>void &lt;entity&gt; MotionPulse_Enable(<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;enable&gt; true to enable /false to disable</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Enable or disable the sitrep scan<BR><B>EXAMPLE:  </B>entity motionpulse_enable( false )<BR></OL><P>
<HR><H1>void &lt;entity&gt; MotionPulse_SetDesat(<I>&lt;level&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;level&gt; The desat level (float)</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the motion pulse desaturation level<BR><B>EXAMPLE:  </B>entity motionpulse_setdesat( level )<BR></OL><P>
<HR><H1>void &lt;entity&gt; MotionPulse_SetFadeOut(<I>&lt;fadeout&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;fadeout&gt; The fadeout (float)</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the motion pulse fadeout<BR><B>EXAMPLE:  </B>entity MotionPulse_SetFadeOut( fadeout )<BR></OL><P>
<HR><H1>void &lt;entity&gt; MotionPulse_SetFalloff(<I>&lt;falloff&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;falloff&gt; the falloff (float)</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the motion pulse falloff<BR><B>EXAMPLE:  </B>entity motionpulse_setfalloff( falloff )<BR></OL><P>
<HR><H1>void &lt;entity&gt; MotionPulse_SetLineWidth(<I>&lt;linewidth&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;linewidth&gt; the line width (float)</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the motion pulse line width<BR><B>EXAMPLE:  </B>entity motionpulse_setlinewidth( linewidth )<BR></OL><P>
<HR><H1>void &lt;entity&gt; MotionPulse_SetOutline(<I>&lt;outlinelevel&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;outlinelevel&gt; the outline level (float)</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the motion pulse outline level<BR><B>EXAMPLE:  </B>entity motionpulse_setoutline( outlinelevel )<BR></OL><P>
<HR><H1>void &lt;entity&gt; MotionPulse_SetRadius(<I>&lt;radius&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;radius&gt; the radius (float)</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the motion pulse radius<BR><B>EXAMPLE:  </B>entity motionpulse_setradius( radius )<BR></OL><P>
<HR><H1>void &lt;entity&gt; MotionPulse_SetSolid(<I>&lt;level&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;level&gt; The solid level (float)</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the motion pulse solid level<BR><B>EXAMPLE:  </B>entity motionpulse_setsolid( level )<BR></OL><P>
<HR><H1>void &lt;entity&gt; OED_NightVision_Enable(<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;enable&gt; true/false</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>EXAMPLE:  </B>entity oed_nightvision_enable( false )<BR></OL><P>
<HR><H1>void OED_NightVision_Reset(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  "CallOn: &lt;entity&gt; An entity</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Reset nightvision for entity<BR><B>EXAMPLE:  </B>entity oed_nightvision_reset()<BR></OL><P>
<HR><H1>void &lt;entity&gt; OED_NightVision_SetTextureLevel(<I>&lt;level&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;level&gt; The texture level (float)</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the night vision texture level for the entity<BR><B>EXAMPLE:  </B>entity oed_nightvision_settexturelevel( level )<BR></OL><P>
<HR><H1>void &lt;entity&gt; OED_SitRepScan_Enable(<I>&lt;type&gt;</I>,<I>&lt;AlphaType&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;type&gt; 0-disable 1-typeA 2-typeB<LI>        <B>[OPTIONAL]</B>  &lt;AlphaType&gt; 0-default 1-Alpha ( 0 by default )</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Enable or disable the sitrep scan<BR><B>EXAMPLE:  </B>entity oed_sitpepscan_enable( 0 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; OED_SitRepScan_SetDesat(<I>&lt;level&gt;</I>,<I>&lt;AlphaType&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;level&gt; the desat level (float)<LI>        <B>[OPTIONAL]</B>  &lt;AlphaType&gt; 0-default 1-Alpha ( 0 by default )</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the desaturation level for the sitrep scan<BR><B>EXAMPLE:  </B>entity oed_sitrepscan_setdesat( level )<BR></OL><P>
<HR><H1>void &lt;entity&gt; OED_SitRepScan_SetFalloff(<I>&lt;falloff&gt;</I>,<I>&lt;AlphaType&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;falloff&gt; The falloff (float)<LI>        <B>[OPTIONAL]</B>  &lt;AlphaType&gt; 0-default 1-Alpha ( 0 by default )</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the falloff for the sitrep scan<BR><B>EXAMPLE:  </B>entity oed_sitrepscan_setfalloff( falloff )<BR></OL><P>
<HR><H1>void &lt;entity&gt; OED_SitRepScan_SetLineWidth(<I>&lt;linewidth&gt;</I>,<I>&lt;AlphaType&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;linewidth&gt; The line width (float)<LI>        <B>[OPTIONAL]</B>  &lt;AlphaType&gt; 0-default 1-Alpha ( 0 by default )</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the line width for the sitrep scan<BR><B>EXAMPLE:  </B>entity oed_sitrepscan_setlinewidth( linewidth )<BR></OL><P>
<HR><H1>void &lt;entity&gt; OED_SitRepScan_SetOutline(<I>&lt;outlinelevel&gt;</I>,<I>&lt;AlphaType&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;outlinelevel&gt; The outline level (float)<LI>        <B>[OPTIONAL]</B>  &lt;AlphaType&gt; 0-default 1-Alpha ( 0 by default )</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the outline level for the sitrep scan<BR><B>EXAMPLE:  </B>entity oed_sitrepscan_setoutline( outlinelevel )<BR></OL><P>
<HR><H1>void &lt;entity&gt; OED_SitRepScan_SetRadius(<I>&lt;radius&gt;</I>,<I>&lt;AlphaType&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;radius&gt; The radius (float)<LI>        <B>[OPTIONAL]</B>  &lt;AlphaType&gt; 0-default 1-Alpha ( 0 by default )</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the radius for the sitrep scan<BR><B>EXAMPLE:  </B>entity oed_sitrepscan_setradius( radius )<BR></OL><P>
<HR><H1>void &lt;entity&gt; OED_SitRepScan_SetSolid(<I>&lt;level&gt;</I>,<I>&lt;AlphaType&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;level&gt; the solid level (float)<LI>        <B>[OPTIONAL]</B>  &lt;AlphaType&gt; 0-default 1-Alpha ( 0 by default )</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the solid level for the sitrep scan<BR><B>EXAMPLE:  </B>entity oed_sitrepscan_setsolid( level )<BR></OL><P>
<HR><H1>void PlayExtraCamXCam(<I>&lt;xcam name&gt;</I>,<I>[lerp_duration]</I>,<I>[camera_name]</I>,<I>[animation_name]</I>,<I>[origin]</I>,<I>[angles]</I>,<I>[target]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;xcam name&gt; The name of the xcam asset to play<LI>        <B>[OPTIONAL]</B>  [lerp_duration] The duration to lerp the start of the xcam over<LI>        <B>[OPTIONAL]</B>  [camera_name] The name of the sub camera from the XCam to play<LI>        <B>[OPTIONAL]</B>  [animation_name] The name of the frame (notetrack) to play<LI>        <B>[OPTIONAL]</B>  [origin] Base origin for the camera<LI>        <B>[OPTIONAL]</B>  [angles] Base angles for the camera<LI>        <B>[OPTIONAL]</B>  [target] If this xcam has model translation and rotation data, apply it to this entity.</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Plays an XCam on the extra cam associated with the entity starting at the current client time<BR><B>EXAMPLE:  </B>cameraEnt PlayExtraCamXCam( "ui_cam_ar_standard" )<BR></OL><P>
<HR><H1>void PlayFXOnDynEnt(<I>&lt;effect id&gt;</I>,<I>&lt;dynent&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;effect id&gt; The effect id returned by loadfx<LI>        <B>[MANDATORY]</B>  &lt;dynent&gt; The dyn entity to play the effect on</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Play this effect and return the internal handle.<BR><B>EXAMPLE:  </B>handle = PlayFXOnDynEnt( spark, lamp )<BR></OL><P>
<HR><H1>void PlayMainCamXCam(<I>&lt;localClientNum&gt;</I>,<I>&lt;xcam name&gt;</I>,<I>[lerp_duration]</I>,<I>[camera_name]</I>,<I>[animation_name]</I>,<I>[origin]</I>,<I>[angles]</I>,<I>[target]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client<LI>        <B>[MANDATORY]</B>  &lt;xcam name&gt; The name of the xcam asset to play<LI>        <B>[OPTIONAL]</B>  [lerp_duration] The duration to lerp the start of the xcam over<LI>        <B>[OPTIONAL]</B>  [camera_name] The name of the sub camera from the XCam to play<LI>        <B>[OPTIONAL]</B>  [animation_name] The name of the frame (notetrack) to play<LI>        <B>[OPTIONAL]</B>  [origin] Base origin for the camera<LI>        <B>[OPTIONAL]</B>  [angles] Base angles for the camera<LI>        <B>[OPTIONAL]</B>  [target] If this xcam has model translation and rotation data, apply it to this entity.</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Plays an XCam on the main camera associated with the player starting at the current client time<BR><B>EXAMPLE:  </B>PlayMainCamXCam( localClientNum, "ui_cam_ar_standard" )<BR></OL><P>
<HR><H1>void PlayRadiantExploder(<I>&lt;localClientNum&gt;</I>,<I>&lt;exploderId&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client to play the effect on<LI>        <B>[MANDATORY]</B>  &lt;exploderId&gt; The id of the exploder to be triggered.</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Play the specified Radiant exploder<BR><B>EXAMPLE:  </B>PlayRadiantExploder( 0, "lights_on_exploder" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; PlayRenderOverrideBundle()</H1><OL><UL></UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Applys a render override bundle to an entitys model <BR><B>EXAMPLE:  </B>entity PlayRenderOverrideBundle( "myBundle" )<BR></OL><P>
<HR><H1>void PlayTagFXSet(<I>&lt;localClientNum&gt;</I>,<I>&lt;tagfxset&gt;</I>,<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client on which to play the fx<LI>        <B>[MANDATORY]</B>  &lt;tagfxset&gt; The string name of the tag fx set<LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The entity to play the effect on</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Play a tagfx set on ajn entity. Do not specify loop fx<BR><B>EXAMPLE:  </B>PlayTagFXSet ( 0, self, smoke )<BR></OL><P>
<HR><H1>void PlayViewmodelFX(<I>&lt;local_client_num&gt;</I>,<I>&lt;name&gt;</I>,<I>&lt;tag&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;local_client_num&gt; The client number<LI>        <B>[MANDATORY]</B>  &lt;name&gt; The name of the fx<LI>        <B>[MANDATORY]</B>  &lt;tag&gt; The tag to play on</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR></OL><P>
<HR><H1>void &lt;entity&gt; RandomFade(<I>&lt;level&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;level&gt; 0 to disable, any other value to enable (float)</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Fade the level randomly<BR><B>EXAMPLE:  </B>entity randomfade( level )<BR></OL><P>
<HR><H1>void RegisterRewindFX(<I>&lt;local_client_num&gt;</I>,<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;local_client_num&gt; The client number<LI>        <B>[MANDATORY]</B>  &lt;name&gt; The name of the fx</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Registers an fx with the killcam rewind system<BR><B>EXAMPLE:  </B>RegisterRewindFX(local_client_num, "fxName")<BR></OL><P>
<HR><H1>void RemoveFXExclusionVolume(<I>&lt;localClientNum&gt;</I>,<I>&lt;volumeID&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client to remove the volume from.<LI>        <B>[MANDATORY]</B>  &lt;volumeID&gt; The volume to remove.</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Removes the given exclusion volume.<BR><B>EXAMPLE:  </B>RemoveFXExclusionVolume( 0, volumeID )<BR></OL><P>
<HR><H1>void SetAllowXCamRightStickRotation(<I>&lt;localClientNum&gt;</I>,<I>&lt;newValue&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client<LI>        <B>[MANDATORY]</B>  &lt;newValue&gt; True to allow, False, to disable right stick rotation</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Prevent or stop preventing right stick rotation on this xcam (the next playmaincamxcam resets this)<BR><B>EXAMPLE:  </B>SetAllowXCamRightStickRotation( 0, false )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetArmPulse()</H1><OL><UL></UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets arm pulse override values<BR><B>EXAMPLE:  </B>entity SetArmPulse( 2.0, 4, 3 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetArmPulsePosition()</H1><OL><UL></UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets arm pulse override values<BR><B>EXAMPLE:  </B>entity SetArmPulsePosition( 0.5 )<BR></OL><P>
<HR><H1>void SetCameraSpikeCamActive(<I>&lt;localClientNum&gt;</I>,<I>&lt;active&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the extra cam owner<LI>        <B>[MANDATORY]</B>  &lt;active&gt; 0 if inactive, 1 if active</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets whether a client's camera-spike cam is active.<BR><B>EXAMPLE:  </B>SetCameraSpikeCamActive( localClientNum, 1 )<BR></OL><P>
<HR><H1>void SetCameraSpikeCamAngles(<I>&lt;localClientNum&gt;</I>,<I>&lt;angles&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the camera-spike cam owner<LI>        <B>[MANDATORY]</B>  &lt;angles&gt; New pitch, yaw, and roll of the camera-spike cam</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the orientation of a client's extra cam.<BR><B>EXAMPLE:  </B>SetCameraSpikeCamAngles( localClientNum, angles )<BR></OL><P>
<HR><H1>void SetCameraSpikeCamEntity(<I>&lt;localClientNum&gt;</I>,<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the extra cam owner<LI>        <B>[MANDATORY]</B>  &lt;entity&gt; Camera entity, or undefined</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets an camera-spike cam entity for the client.<BR><B>EXAMPLE:  </B>CScr_SetCameraSpikeCamEntity( localClientNum, cameraSpike )<BR></OL><P>
<HR><H1>void SetCameraSpikeCamOrigin(<I>&lt;localClientNum&gt;</I>,<I>&lt;origin&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the camera-spike cam owner<LI>        <B>[MANDATORY]</B>  &lt;origin&gt; New origin of the camera-spike cam</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the origin of a client's camera-spike cam<BR><B>EXAMPLE:  </B>SetCameraSpikeCamOrigin( localClientNum, origin )<BR></OL><P>
<HR><H1>void SetCameraSpikeCamStatic(<I>&lt;localClientNum&gt;</I>,<I>&lt;active&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Client number of the camera-spike cam owner<LI>        <B>[MANDATORY]</B>  &lt;active&gt; 0 if inactive, 1 if active</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets whether a client sees static on the camera-spike cam<BR><B>EXAMPLE:  </B>SetCameraSpikeCamStatic( localClientNum, 1 )<BR></OL><P>
<HR><H1>void SetClientVolumetricFog(<I>&lt;startDist&gt;</I>,<I>&lt;halfwayDist&gt;</I>,<I>&lt;halfwayHeight&gt;</I>,<I>&lt;baseHeight&gt;</I>,<I>&lt;red&gt;</I>,<I>&lt;green&gt;</I>,<I>&lt;blue&gt;</I>,<I>&lt;fogColorScale&gt;</I>,<I>[sunFogColorR]</I>,<I>[sunFogColorG]</I>,<I>[sunFogColorB]</I>,<I>[sunFogDirX]</I>,<I>[sunFogDirY]</I>,<I>[sunFogDirZ]</I>,<I>[sunFogStartAng]</I>,<I>[sunFogEndAng]</I>,<I>[]</I>,<I>[fogMaxOpacity]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;startDist&gt; The start distance of the volume<LI>        <B>[MANDATORY]</B>  &lt;halfwayDist&gt; The halfway distance of the volume<LI>        <B>[MANDATORY]</B>  &lt;halfwayHeight&gt; The halfway height of the volume<LI>        <B>[MANDATORY]</B>  &lt;baseHeight&gt; The base height of the volume<LI>        <B>[MANDATORY]</B>  &lt;red&gt; The red value<LI>        <B>[MANDATORY]</B>  &lt;green&gt; The green value<LI>        <B>[MANDATORY]</B>  &lt;blue&gt; The blue value<LI>        <B>[MANDATORY]</B>  &lt;fogColorScale&gt; The color scale of the fog<LI>        <B>[OPTIONAL]</B>  [sunFogColorR] The sun fog red value<LI>        <B>[OPTIONAL]</B>  [sunFogColorG] The sun fog green value<LI>        <B>[OPTIONAL]</B>  [sunFogColorB] The sun fog blue value<LI>        <B>[OPTIONAL]</B>  [sunFogDirX] The sun direction X value<LI>        <B>[OPTIONAL]</B>  [sunFogDirY] The sun direction Y value<LI>        <B>[OPTIONAL]</B>  [sunFogDirZ] The sun direction Z value<LI>        <B>[OPTIONAL]</B>  [sunFogStartAng] Angle from the sun position where the sun fades in<LI>        <B>[OPTIONAL]</B>  [sunFogEndAng] Angle from the sun position where the sun has faded out<LI>        <B>[OPTIONAL]</B>  []<LI>        <B>[OPTIONAL]</B>  [fogMaxOpacity] The maximum opacity of the fog as a value between 0 and 1</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the client volumetric fog properties<BR></OL><P>
<HR><H1>void SetExposureActiveBank(<I>&lt;localClientNum&gt;</I>,<I>&lt;bank mask&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; the local client<LI>        <B>[MANDATORY]</B>  &lt;bank mask&gt; The new bank mask</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set exposure volumes active bank bit mask.<BR><B>EXAMPLE:  </B>SetExposureActiveBank( localClientNum, 2 )<BR></OL><P>
<HR><H1>void SetExposureIgnoreTeleport(<I>&lt;localClientNum&gt;</I>,<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; the local client<LI>        <B>[MANDATORY]</B>  &lt;enable&gt; Enable or disable the exposure always adapt flag</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Always do fully adaptive exposure and ignore teleports<BR><B>EXAMPLE:  </B>SetExposureIgnoreTeleport( localClientNum, newVal )<BR></OL><P>
<HR><H1>void SetExposureInstantSnap(<I>&lt;localClientNum&gt;</I>,<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; the local client<LI>        <B>[MANDATORY]</B>  &lt;enable&gt; Enable or disable the exposure snap</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>snap exposure to base calculated probe value, ignore iris adaption and damping<BR><B>EXAMPLE:  </B>SetExposureInstantSnap( localClientNum, newVal )<BR></OL><P>
<HR><H1>void SetExtraCam(<I>&lt;camera index&gt;</I>,<I>&lt;rendered width&gt;</I>,<I>&lt;rendered height&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;camera index&gt; which extra cam references this entity. Valid values are 0 - 3<LI>        <B>[OPTIONAL]</B>  &lt;rendered width&gt; Width of the extra cam rendered target. The width will be calculated from the height if width is negative (keeping the aspect ration at 16:9)<LI>        <B>[OPTIONAL]</B>  &lt;rendered height&gt; Height of the extra cam rendered target. The height will be calculated from the width if height is negative (keeping the aspect ration at 16:9)</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Activates the extra cam and sets the given entity as cam reference.<BR><B>EXAMPLE:  </B>cameraEnt SetExtraCam( 1, 640, 480 )<BR></OL><P>
<HR><H1>void SetExtraCamFocalLength(<I>&lt;camera index&gt;</I>,<I>&lt;fov&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;camera index&gt; which extra cam references this entity. Valid values are 0 - 3<LI>        <B>[MANDATORY]</B>  &lt;fov&gt; camera fov</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the extra cam fov<BR><B>EXAMPLE:  </B>cameraEnt SetExtraCamFOV( 1, 65 )<BR></OL><P>
<HR><H1>void SetFilterBitFlag(<I>&lt;localClientNum&gt;</I>,<I>&lt;filterIndex&gt;</I>,<I>&lt;bitIndex&gt;</I>,<I>&lt;setOrClear&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt;<LI>        <B>[MANDATORY]</B>  &lt;filterIndex&gt; Must be between 0 - 3<LI>        <B>[MANDATORY]</B>  &lt;bitIndex&gt; Must be between 0 - 31<LI>        <B>[MANDATORY]</B>  &lt;setOrClear&gt; Must be between 0 - 1</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set or clear the filter bit flag<BR><B>EXAMPLE:  </B>SetFilterBitFlag( self.localClientNum, 1, 10 )<BR></OL><P>
<HR><H1>void SetFilterPassCodeTexture(<I>&lt;localClientNum&gt;</I>,<I>&lt;filterIndex&gt;</I>,<I>&lt;passIndex&gt;</I>,<I>&lt;texture Index&gt;</I>,<I>&lt;texture name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt;<LI>        <B>[MANDATORY]</B>  &lt;filterIndex&gt; Must be between 0 - 3<LI>        <B>[MANDATORY]</B>  &lt;passIndex&gt; Must be between 0 - 15<LI>        <B>[MANDATORY]</B>  &lt;texture Index&gt; Must be between 0 - 1<LI>        <B>[MANDATORY]</B>  &lt;texture name&gt; has to have been created by captureFrame() before - if empty string sets to null.</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets a code texture for a filter pass - the tetxure has be to created beforehand<BR><B>EXAMPLE:  </B>SetFilterPassMaterial( self.localClientNum, 1, 12, 0, "myBundle")<BR></OL><P>
<HR><H1>void SetFilterPassConstant(<I>&lt;filterIndex&gt;</I>,<I>&lt;passIndex&gt;</I>,<I>&lt;constantIndex&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;filterIndex&gt; Must be between 0 - 3<LI>        <B>[MANDATORY]</B>  &lt;passIndex&gt; Must be between 0 - 16<LI>        <B>[MANDATORY]</B>  &lt;constantIndex&gt; Must be between 0 - 16<LI>        <B>[MANDATORY]</B>  &lt;value&gt; The value for the constant</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the filter pass constant<BR><B>EXAMPLE:  </B>SetFilterPassConstant( self.localClientNum, 1, 12, 12, 2.5 )<BR></OL><P>
<HR><H1>void SetFilterPassEnabled(<I>&lt;localClientNum&gt;</I>,<I>&lt;filterIndex&gt;</I>,<I>&lt;passIndex&gt;</I>,<I>&lt;passEnable&gt;</I>,<I>[hdrFilter&gt;]</I>,<I>[firstPersonOnly&gt;]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt;<LI>        <B>[MANDATORY]</B>  &lt;filterIndex&gt; Must be between 0 - 3<LI>        <B>[MANDATORY]</B>  &lt;passIndex&gt; Must be between 0 - 16<LI>        <B>[MANDATORY]</B>  &lt;passEnable&gt; true/false<LI>        <B>[OPTIONAL]</B>  [hdrFilter&gt;] true/false - if true the filter is applied to the scene (HDR) otherwise will be applied after the LDT and dof (default false)<LI>        <B>[OPTIONAL]</B>  [firstPersonOnly&gt;] true/false - if true the filter is applied to the scene only if you are in or spectating a player in first person</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the filter pass enabled or disabled<BR><B>EXAMPLE:  </B>SetFilterPassEnabled( self.localClientNum, 1, 12, false)<BR></OL><P>
<HR><H1>void SetFilterPassMaterial(<I>&lt;localClientNum&gt;</I>,<I>&lt;filterIndex&gt;</I>,<I>&lt;passIndex&gt;</I>,<I>&lt;materialIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt;<LI>        <B>[MANDATORY]</B>  &lt;filterIndex&gt; Must be between 0 - 3<LI>        <B>[MANDATORY]</B>  &lt;passIndex&gt; Must be between 0 - 15<LI>        <B>[MANDATORY]</B>  &lt;materialIndex&gt; Must be between 0 - 63</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the filter pass material<BR><B>EXAMPLE:  </B>SetFilterPassMaterial( self.localClientNum, 1, 12, 20 )<BR></OL><P>
<HR><H1>void SetFilterPassQuads(<I>&lt;localClientNum&gt;</I>,<I>&lt;filterIndex&gt;</I>,<I>&lt;passIndex&gt;</I>,<I>&lt;passQuads&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt;<LI>        <B>[MANDATORY]</B>  &lt;filterIndex&gt; Must be between 0 - 3<LI>        <B>[MANDATORY]</B>  &lt;passIndex&gt; Must be between 0 - 16<LI>        <B>[MANDATORY]</B>  &lt;passQuads&gt; Must be between 0 - 2048</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets the filter pass quads<BR><B>EXAMPLE:  </B>SetFilterPassQuads( self.localClientNum, 1, 12, 200)<BR></OL><P>
<HR><H1>void SetFXIgnorePause(<I>&lt;localClientNum&gt;</I>,<I>&lt;effect id&gt;</I>,<I>&lt;ignore pause&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client the effect is playing on.<LI>        <B>[MANDATORY]</B>  &lt;effect id&gt; The effect id returned by playFx<LI>        <B>[MANDATORY]</B>  &lt;ignore pause&gt; Whether or not to respect a paused world state.</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Tells an effect whether or not to respect a paused world state.<BR><B>EXAMPLE:  </B>SetFXIgnorePause( localClientNum, fxId, 1 )<BR></OL><P>
<HR><H1>void SetFXOutdoor(<I>&lt;localClientNum&gt;</I>,<I>&lt;effect id&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client the effect is playing on.<LI>        <B>[MANDATORY]</B>  &lt;effect id&gt; The effect id returned by playFx</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Flag the FX as one that only plays outdoors.<BR><B>EXAMPLE:  </B>SetFXOutdoor( fxId )<BR></OL><P>
<HR><H1>void SetFXTeam(<I>&lt;localClientNum&gt;</I>,<I>&lt;effect handle &gt;</I>,<I>&lt;entity or team&gt;</I>,<I>&lt;invert team&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client on which to play the fx<LI>        <B>[MANDATORY]</B>  &lt;effect handle &gt; The handle from the created fx<LI>        <B>[MANDATORY]</B>  &lt;entity or team&gt; The team<LI>        <B>[OPTIONAL]</B>  &lt;invert team&gt; Treat the team as the one to show the enemy fx for.</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the team of the fx either by team or by entity which has a team set.<BR><B>EXAMPLE:  </B>handle = SetFXTeam(localClientNum, fxHandle, owner)<BR></OL><P>
<HR><H1>void SetGenericSceneValue(<I>&lt;localClientNum&gt;</I>,<I>&lt;index&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client number.<LI>        <B>[MANDATORY]</B>  &lt;index&gt; The scene vector index ( 0 - 15 )<LI>        <B>[MANDATORY]</B>  &lt;value&gt; Some generic float used by SW shaders.</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets one of the 16 generic scene vectors used by SW shaders.<BR><B>EXAMPLE:  </B>SetGenericSceneValue(0, 20)<BR></OL><P>
<HR><H1>void &lt;entity&gt; SetHotZone()</H1><OL><UL></UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets HotZone control values<BR><B>EXAMPLE:  </B>entity SetHotZone( 100, 1000, 5.0, 3.0, 0.5, 50  )<BR></OL><P>
<HR><H1>void SetLitFogBank(<I>&lt;localClientNum&gt;</I>,<I>&lt;scriptid&gt;</I>,<I>&lt;bank&gt;</I>,<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client<LI>        <B>[MANDATORY]</B>  &lt;scriptid&gt; Volume identifier set in Radiant. (0-255). -1 = all.<LI>        <B>[MANDATORY]</B>  &lt;bank&gt; Bank selection (0-3).<LI>        <B>[MANDATORY]</B>  &lt;time&gt; Time in seconds to make the transition over. -1 to use the 'fogtime' parameter set in the volume.</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets which bank to use for all lit fog volumes with matching script id<BR><B>EXAMPLE:  </B>SetLitFogBank( 0, 1, 5.0 )<BR></OL><P>
<HR><H1>void SetLutScriptIndex(<I>&lt;localClientNum&gt;</I>,<I>&lt;lut index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt;  the local client<LI>        <B>[MANDATORY]</B>  &lt;lut index&gt; The lut index</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set lut index from script.<BR><B>EXAMPLE:  </B>SetLutScriptIndex( lcn, 2 )<BR></OL><P>
<HR><H1>void SetLutVolumeActiveBank(<I>&lt;localClientNum&gt;</I>,<I>&lt;bank mask&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; the local client<LI>        <B>[MANDATORY]</B>  &lt;bank mask&gt; The new bank mask</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set lut volumes active bank bit mask.<BR><B>EXAMPLE:  </B>SetLutVolumeActiveBank( localClientNum, 2 )<BR></OL><P>
<HR><H1>void SetOverlayConstant(<I>&lt;localClientNum&gt;</I>,<I>&lt;overlayIndex&gt;</I>,<I>&lt;constantIndex&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt;<LI>        <B>[MANDATORY]</B>  &lt;overlayIndex&gt; Must be between 0 - 3<LI>        <B>[MANDATORY]</B>  &lt;constantIndex&gt; Must be between 0 - 16<LI>        <B>[MANDATORY]</B>  &lt;value&gt; The value to set</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the overlay constant<BR><B>EXAMPLE:  </B>SetOverlayConstant( self.lcoalClientNum, 2, 5, 1.4 )<BR></OL><P>
<HR><H1>void SetOverlayEnabled(<I>&lt;overlayIndex&gt;</I>,<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;overlayIndex&gt; Must be between 0 - 3<LI>        <B>[MANDATORY]</B>  &lt;enable&gt; true/false</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Enables or disables the overlay<BR><B>EXAMPLE:  </B>SetOverlayEnabled( self.localClientNum, 2, false )<BR></OL><P>
<HR><H1>void SetOverlayMaterial(<I>&lt;localClientNum&gt;</I>,<I>&lt;overlayIndex&gt;</I>,<I>&lt;materialIndex&gt;</I>,<I>&lt;sortIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt;<LI>        <B>[MANDATORY]</B>  &lt;overlayIndex&gt; Must be between 0 - 3<LI>        <B>[MANDATORY]</B>  &lt;materialIndex&gt; Must be between 0 - 63<LI>        <B>[MANDATORY]</B>  &lt;sortIndex&gt; Must be between 0 - 2</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the overlay material<BR><B>EXAMPLE:  </B>SetOverlayMaterial( self.localClientNum, 2, 20, 1 )<BR></OL><P>
<HR><H1>void SetPBGActiveBank(<I>&lt;localClientNum&gt;</I>,<I>&lt;bank mask&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; the local client<LI>        <B>[MANDATORY]</B>  &lt;bank mask&gt; The bank bit mask</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set PBG bank mask from script.<BR><B>EXAMPLE:  </B>SetPBGActiveBank( lcn, 1 )<BR></OL><P>
<HR><H1>void SetRimIntensity(<I>&lt;localClientNum&gt;</I>,<I>&lt;rimIntensity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client number.<LI>        <B>[MANDATORY]</B>  &lt;rimIntensity&gt; Character skin/cloth rim intensity.</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Global character skin/cloth rim lighting intensity.<BR><B>EXAMPLE:  </B>SetRimIntensity(0, 20)<BR></OL><P>
<HR><H1>void SetRippleWave(<I>&lt;client&gt;</I>,<I>&lt;center xpos&gt;</I>,<I>&lt;center ypos&gt;</I>,<I>&lt;width&gt;</I>,<I>&lt;speed scale&gt;</I>,<I>&lt;amplitude width ratio&gt;</I>,<I>&lt;fade in start&gt;</I>,<I>&lt;fade in end&gt;</I>,<I>&lt;fade out start&gt;</I>,<I>&lt;fade out end&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;client&gt; The local client<LI>        <B>[MANDATORY]</B>  &lt;center xpos&gt; The x coord<LI>        <B>[MANDATORY]</B>  &lt;center ypos&gt; The y coord<LI>        <B>[MANDATORY]</B>  &lt;width&gt; The width of the wave<LI>        <B>[MANDATORY]</B>  &lt;speed scale&gt; The speed modifier<LI>        <B>[MANDATORY]</B>  &lt;amplitude width ratio&gt; The amplitude<LI>        <B>[MANDATORY]</B>  &lt;fade in start&gt; The fade in at start<LI>        <B>[MANDATORY]</B>  &lt;fade in end&gt; The fade in at the end<LI>        <B>[MANDATORY]</B>  &lt;fade out start&gt; The fade out at start<LI>        <B>[MANDATORY]</B>  &lt;fade out end&gt; The fade out at the end</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Trigger vertex ripple wave for material set to use it.<BR><B>EXAMPLE:  </B>setripplewave( 0, 100.0, 100.0, 200.0, 1.0, 1.0, 0.0, 250.0, 1000.0, 1500.0 )<BR></OL><P>
<HR><H1>void SetServerVolumetricFogDensity(<I>&lt;localClientNum&gt;</I>,<I>&lt;density&gt;</I>,<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client number<LI>        <B>[MANDATORY]</B>  &lt;density&gt; The density to set<LI>        <B>[MANDATORY]</B>  &lt;time&gt; The time to lerp to the new value</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the density of server volumetric fog<BR></OL><P>
<HR><H1>void SetUkkoScriptIndex(<I>&lt;localClientNum&gt;</I>,<I>&lt;ukko index&gt;</I>,<I>&lt;ukko blend&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt;  the local client<LI>        <B>[MANDATORY]</B>  &lt;ukko index&gt; The ukko index<LI>        <B>[MANDATORY]</B>  &lt;ukko blend&gt; The ukko index blend amount</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set ukko index from script.<BR><B>EXAMPLE:  </B>SetUkkoScriptIndex( lcn, 2, 1.0 )<BR></OL><P>
<HR><H1>void StartWaterSheetingFX(<I>&lt;localClientNum&gt;</I>,<I>[duration]</I>,<I>[magnitude]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client on which to play the fx<LI>        <B>[OPTIONAL]</B>  [duration] The number of seconds to play the fx before it stops automatically. Use 0 for infinite time. Defaults to 0.<LI>        <B>[OPTIONAL]</B>  [magnitude] default is from a dvar (r_waterSheetingFX_magnitude)</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Play a fullscreen water effect.<BR><B>EXAMPLE:  </B>StartWaterSheetingFX(localClientNum, 8)<BR></OL><P>
<HR><H1>void StopExtraCamXCam()</H1><OL><UL></UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Stops an XCam on the extra cam associated with the entity<BR><B>EXAMPLE:  </B>cameraEnt StopExtraCamXCam()<BR></OL><P>
<HR><H1>void StopFX(<I>&lt;localClientNum&gt;</I>,<I>&lt;effect id&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client the effect is playing on.<LI>        <B>[MANDATORY]</B>  &lt;effect id&gt; The effect id returned by playFx</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Stops a given fx.<BR><B>EXAMPLE:  </B>StopFX ( fxId )<BR></OL><P>
<HR><H1>void StopMainCamXCam(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Stops an XCam on the main cam associated with the entity<BR><B>EXAMPLE:  </B>StopMainCamXCam( 0 )<BR></OL><P>
<HR><H1>void StopRadiantExploder(<I>&lt;localClientNum&gt;</I>,<I>&lt;exploderId&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client to play the effect on<LI>        <B>[MANDATORY]</B>  &lt;exploderId&gt; The id of the exploder to be stopped.</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Stop the specified Radiant exploder<BR><B>EXAMPLE:  </B>StopRadiantExploder( 0, "lights_on_exploder" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; StopRenderOverrideBundle()</H1><OL><UL></UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Ends a Render Override Bundle<BR><B>EXAMPLE:  </B>entity StopRenderOverrideBundle()<BR></OL><P>
<HR><H1>void StopWaterSheetingFX(<I>&lt;localClientNum&gt;</I>,<I>[duration]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client on which to play the fx<LI>        <B>[OPTIONAL]</B>  [duration] The number of seconds it takes the effect to fade. Use 0 for immediate turn off. Defaults to 0.</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Stop the fullscreen water effect<BR><B>EXAMPLE:  </B>StopWaterSheetingFX( localClientNum, 1 )<BR></OL><P>
<HR><H1>void SwitchToClientVolumetricFog(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Switch to the client volumetric fog<BR></OL><P>
<HR><H1>void SwitchToServerVolumetricFog(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Switch to the server volumetric fog<BR></OL><P>
<HR><H1>void &lt;entity&gt; TmodeClearFlag()</H1><OL><UL></UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Clears flag bit for tmode.<BR><B>EXAMPLE:  </B>entity TmodeClearFlag( 2 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; TmodeEnable(<I>1 to enable,  0 to disable</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  1 to enable,  0 to disable</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Enable or disable tactical mode<BR><B>EXAMPLE:  </B>entity TmodeEnable( 1 )<BR></OL><P>
<HR><H1>void &lt;entity&gt; TmodeSetFlag()</H1><OL><UL></UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets flag bit for tmode.<BR><B>EXAMPLE:  </B>entity TmodeSetFlag( 1 )<BR></OL><P>
<HR><H1>void TmodeStatus(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client to find the status of</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>returns the status of tmode<BR><B>EXAMPLE:  </B>status = TmodeStatus( 1 )<BR></OL><P>
<HR><H1>void umbra_clearpersistenttometrigger(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt;</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>clears the current tome trigger that persisted due to touching a prior tome trigger<BR><B>EXAMPLE:  </B>umbra_clearpersistenttometrigger( localClientNum )<BR></OL><P>
<HR><H1>void Umbra_SetAccurateOcclusionThreshold()</H1><OL><UL></UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set Umbra Accurate Occlusion Threshold parameter<BR><B>EXAMPLE:  </B>Umbra_SetAccurateOcclusionThreshold( localClientNum, 2048 )<BR></OL><P>
<HR><H1>void Umbra_SetDistanceScale()</H1><OL><UL></UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set Umbra Distance Scale parameter<BR><B>EXAMPLE:  </B>Umbra_SetDistanceScale( localClientNum, 2.0 )<BR></OL><P>
<HR><H1>void Umbra_SetMinimumContributionThreshold()</H1><OL><UL></UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set Umbra Accurate Occlusion Threshold parameter<BR><B>EXAMPLE:  </B>Umbra_SetAccurateOcclusionThreshold( localClientNum, 8 )<BR></OL><P>
<HR><H1>void umbra_settometrigger(<I>&lt;localClientNum&gt;</I>,<I>&lt;tometrigger name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt;<LI>        <B>[MANDATORY]</B>  &lt;tometrigger name&gt; name of a tome trigger. Use empty string "" to deactivate tome triggers</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets current active tome trigger<BR><B>EXAMPLE:  </B>Umbra_SetTomeTrigger( localClientNum, "my_really_cool_tome_trigger" )<BR></OL><P>
<HR><H1>void umbra_settometriggeronce(<I>&lt;localClientNum&gt;</I>,<I>&lt;tometrigger name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt;<LI>        <B>[MANDATORY]</B>  &lt;tometrigger name&gt; name of a tome trigger. Use empty string "" to deactivate tome triggers</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set the active tome trigger without interferring with any other tome logic.<BR><B>EXAMPLE:  </B>Umbra_SetTomeTriggerOnce( localClientNum, "my_really_cool_tome_trigger" )<BR></OL><P>
<HR><H1>void UnhideStaticModel(<I>&lt;smodelIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;smodelIndex&gt; The index of the static model to toggle</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Unhide a static model<BR><B>EXAMPLE:  </B>UnhideStaticModel( model )<BR></OL><P>
<HR><H1>void UnhideVolumeDecal(<I>&lt;volume decal Index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;volume decal Index&gt; The index of the volume decal to toggle</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Unhide a static model<BR><B>EXAMPLE:  </B>UnhideStaticModel( model )<BR></OL><P>
<HR><H1>void VisionSetLastStandLerp(<I>&lt;localClientNum&gt;</I>,<I>&lt;vision name to&gt;</I>,<I>&lt;vision name from&gt;</I>,<I>&lt;lerp fraction&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client which will have his vampire vision set changed<LI>        <B>[MANDATORY]</B>  &lt;vision name to&gt; Vision to transition to.<LI>        <B>[MANDATORY]</B>  &lt;vision name from&gt; Vision to transition from.<LI>        <B>[MANDATORY]</B>  &lt;lerp fraction&gt; The lerp fraction to use when transitioning to the new vision set if a transition is possible.  Default is one second.</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets players' last stand vision.  Optionally give a transition time from the current vision.<BR><B>EXAMPLE:  </B>VisionSetLastStandLerp( localClientNum, curr_info.visionset_to, curr_info.visionset_from, state.curr_lerp )<BR></OL><P>
<HR><H1>void VisionSetNakedLerp(<I>&lt;localClientNum&gt;</I>,<I>&lt;vision name to&gt;</I>,<I>&lt;vision name from&gt;</I>,<I>&lt;lerp fraction&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client which will have his vampire vision set changed<LI>        <B>[MANDATORY]</B>  &lt;vision name to&gt; Vision to transition to.<LI>        <B>[MANDATORY]</B>  &lt;vision name from&gt; Vision to transition from.<LI>        <B>[MANDATORY]</B>  &lt;lerp fraction&gt; The lerp fraction to use when transitioning to the new vision set if a transition is possible.  Default is one second.</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets players' naked vision.  Optionally give a transition time from the current vision.<BR><B>EXAMPLE:  </B>VisionSetNakedLerp( localClientNum, curr_info.visionset_to, curr_info.visionset_from, state.curr_lerp )<BR></OL><P>
<HR><H1>void &lt;entity&gt; WeakPoint_Enable(<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  1,2 &lt;enable&gt;  0 to disable</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Enable or disable the weakpoint fx<BR><B>EXAMPLE:  </B>entity weakpoint_enable( 2 )<BR></OL><P>
<HR><H1>void ZombieShooterSpotted(<I>&lt;localClientNum&gt;</I>,<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Local client on which to map the material<LI>        <B>[MANDATORY]</B>  &lt;enable&gt; 1-enables, 0-disables</UL><B>CATEGORY:  </B>Gfx<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Enables the Zombie Shooter Spotted HUD display<BR><B>EXAMPLE:  </B>ZombieShooterSpotted(1, 1)<BR></OL><P>
<HR><H1>void Abs(<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;value&gt; A float or integer value.</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the absolute value of a float<BR><B>EXAMPLE:  </B>x = Abs( x )<BR></OL><P>
<HR><H1>void AbsAngleClamp180(<I>&lt;angles&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;angles&gt; Angle to be clamped</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns abs angle value clamped between [0,180].<BR><B>EXAMPLE:  </B>deltaAngle = AbsAngleClamp180( currentAngle )<BR></OL><P>
<HR><H1>void AbsAngleClamp360(<I>&lt;angle&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;angle&gt; An angle.</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns &lt;angle&gt; as a value in the range of 0 and 360 degrees.<BR><B>EXAMPLE:  </B>new_angle = AbsAngleClamp360( boatAngles[2] )<BR></OL><P>
<HR><H1>void ACos(<I>&lt;cos value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;cos value&gt; A cosine value</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns an angle corresponding to a particular cosine value<BR><B>EXAMPLE:  </B>upAngle = ACos( distanceratio )<BR></OL><P>
<HR><H1>void AngleClamp180(<I>&lt;angles&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;angles&gt; Angle to be clamped</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns angle value clamped between [-180,180].<BR><B>EXAMPLE:  </B>deltaAngle = AngleClamp180( currentAngle )<BR></OL><P>
<HR><H1>void AngleLerp(<I>&lt;from&gt;</I>,<I>&lt;to&gt;</I>,<I>&lt;fraction&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;from&gt; An angle.<LI>        <B>[MANDATORY]</B>  &lt;to&gt; An angle.<LI>        <B>[MANDATORY]</B>  &lt;fraction&gt; A float from 0-1.</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns &lt;angle&gt; lerped angle value.<BR><B>EXAMPLE:  </B>180 = AngleLerp( 0, 360, 0.5 )<BR></OL><P>
<HR><H1>void AnglesToForward(<I>&lt;angles&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;angles&gt; A set of angles</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the forward vector corresponding to a set of angles.<BR><B>EXAMPLE:  </B>forward = AnglesToForward( forward )<BR></OL><P>
<HR><H1>void AnglesToRight(<I>&lt;angles&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;angles&gt; A set of angles</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the right vector corresponding to a set of angles.<BR><B>EXAMPLE:  </B>right = AnglesToRight(angles)<BR></OL><P>
<HR><H1>void AnglesToUp(<I>&lt;angles&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;angles&gt; A set of angles</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the up vector corresponding to a set of angles.<BR><B>EXAMPLE:  </B>up = AnglesToUp(angles)<BR></OL><P>
<HR><H1>void ASin(<I>&lt;sin value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;sin value&gt; A sin value</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns an angle corresponding to a particular sin value<BR><B>EXAMPLE:  </B>upAngle = ASin( upAmount )<BR></OL><P>
<HR><H1>void ATan(<I>&lt;tan value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;tan value&gt; A tangential value</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns an angle corresponding to a particular tangential value<BR><B>EXAMPLE:  </B>upAngle = ATan( height/distance )<BR></OL><P>
<HR><H1>void Ceil(<I>&lt;a&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;a&gt; A float or integer value.</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the ceiling of floating point value &lt;a&gt;. This effectively rounds up Ceil(2.7) == 3, Ceil(3.9) == 4.<BR><B>EXAMPLE:  </B>rounded_down = Floor( val )<BR></OL><P>
<HR><H1>void Closer(<I>&lt;reference&gt;</I>,<I>&lt;point a&gt;</I>,<I>&lt;point b&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;reference&gt; The base position<LI>        <B>[MANDATORY]</B>  &lt;point a&gt; The first point<LI>        <B>[MANDATORY]</B>  &lt;point b&gt; The second point</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Tests which of two points is the closest. Returns true if point a is closer to the reference than point b<BR><B>EXAMPLE:  </B>if( Closer( center, models[j].origin , models[i].origin ))...<BR></OL><P>
<HR><H1>void CombineAngles(<I>&lt;angles a&gt;</I>,<I>&lt;angles b&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;angles a&gt; Angles representing the orientation in which to place &lt;angles b&gt;<LI>        <B>[MANDATORY]</B>  &lt;angles b&gt; Angles which will be reoriented</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns angles b reoriented by angles a.<BR><B>EXAMPLE:  </B>crateAnglesInWorld = CombineAngles( boatAngles, crateAnglesInBoat )<BR></OL><P>
<HR><H1>void Cos(<I>&lt;angle&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;angle&gt; An angle in degrees</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the cos of an angle<BR><B>EXAMPLE:  </B>frac = Cos( degrees )<BR></OL><P>
<HR><H1>void DiffTrack(<I>&lt;to&gt;</I>,<I>&lt;from&gt;</I>,<I>&lt;rate&gt;</I>,<I>&lt;deltaTime&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;to&gt; Float, start of the range<LI>        <B>[MANDATORY]</B>  &lt;from&gt; Float, end of the range<LI>        <B>[MANDATORY]</B>  &lt;rate&gt; Floating point<LI>        <B>[MANDATORY]</B>  &lt;deltaTime&gt; Time elapsed</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns a lagged value between &lt;from&gt; and &lt;to&gt; based on &lt;rate&gt; and &lt;deltaTime&gt<BR></OL><P>
<HR><H1>void DiffTrackAngle(<I>&lt;to&gt;</I>,<I>&lt;from&gt;</I>,<I>&lt;rate&gt;</I>,<I>&lt;deltaTime&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;to&gt; Float, start of the range<LI>        <B>[MANDATORY]</B>  &lt;from&gt; Float, end of the range<LI>        <B>[MANDATORY]</B>  &lt;rate&gt; Floating point<LI>        <B>[MANDATORY]</B>  &lt;deltaTime&gt; Time elapsed</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns a lagged angle between &lt;from&gt; and &lt;to&gt; based on &lt;rate&gt; and &lt;deltaTime&gt;. Properly accounts for wrapping 2pi<BR></OL><P>
<HR><H1>void Distance(<I>&lt;point1&gt;</I>,<I>&lt;point2&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;point1&gt; The first point<LI>        <B>[MANDATORY]</B>  &lt;point2&gt; The second point</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the distance between two points<BR><B>EXAMPLE:  </B>dist = Distance( org, ai[i].origin )<BR></OL><P>
<HR><H1>void Distance2D(<I>&lt;point1&gt;</I>,<I>&lt;point2&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;point1&gt; The first point<LI>        <B>[MANDATORY]</B>  &lt;point2&gt; The second point</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the distance between two points, ignores height difference.<BR><B>EXAMPLE:  </B>dist = Distance2D( org, ai[i].origin )<BR></OL><P>
<HR><H1>void Distance2DSquared(<I>&lt;point1&gt;</I>,<I>&lt;point2&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;point1&gt; The first point<LI>        <B>[MANDATORY]</B>  &lt;point2&gt; The second point</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the squared distance between two points, ignores height difference.<BR><B>EXAMPLE:  </B>distsq = Distance2DSquared( org, ai[i].origin )<BR></OL><P>
<HR><H1>void DistanceSquared(<I>&lt;point1&gt;</I>,<I>&lt;point2&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;point1&gt; The first point<LI>        <B>[MANDATORY]</B>  &lt;point2&gt; The second point</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the squared distance between two points - this is cheaper than the actual distance as it doesn't involve a square root<BR><B>EXAMPLE:  </B>dist2 = DistanceSquared(models[j].origin, center)<BR></OL><P>
<HR><H1>void Float(<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;value&gt; A string or integer number to cast to a float</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Casts a string or an integer to a float<BR><B>EXAMPLE:  </B>x = Float( floatValString )<BR></OL><P>
<HR><H1>void Floor(<I>&lt;a&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;a&gt; A float or integer value.</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the floor of floating point value &lt;a&gt;. This effectively rounds down Floor(2.7) == 2, Floor(3.9) == 3.<BR><B>EXAMPLE:  </B>rounded_down = Floor( val )<BR></OL><P>
<HR><H1>void ForwardRotateAroundUpByAngle(<I>&lt;angles1&gt;</I>,<I>&lt;degrees&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;angles1&gt;<LI>        <B>[MANDATORY]</B>  &lt;degrees&gt;</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>returns a vector that is the result of angles1 forward vector rotated around its up by degrees<BR><B>EXAMPLE:  </B>v=ForwardRotateByAngles( player_angles, frustum_edge_angle )<BR></OL><P>
<HR><H1>void GetMinBitCountForNum(<I>&lt;uint&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;uint&gt; The integer a minimum bit count is needed for</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the minimum number of bits needed to express the provided integer<BR><B>EXAMPLE:  </B>GetMinBitCountForNum( 15 ) returns 4<BR></OL><P>
<HR><H1>void Int(<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;value&gt; A string or floating point number to cast to an integer</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Casts a floating point number or a string to an integer<BR><B>EXAMPLE:  </B>x = Int( self.HUDHealthHeight )<BR></OL><P>
<HR><H1>void Length(<I>&lt;vector&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;vector&gt; A vector</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the length of the given vector<BR><B>EXAMPLE:  </B>dist = Length(models[j].origin - center)<BR></OL><P>
<HR><H1>void LengthSquared(<I>&lt;vector&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;vector&gt; A vector</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the squared vector length for the given vector - this is cheaper than the actual vector length as it doesn't involve a square root<BR><B>EXAMPLE:  </B>dist2 = LengthSquared(models[j].origin - center)<BR></OL><P>
<HR><H1>void LerpFloat(<I>&lt;from&gt;</I>,<I>&lt;to&gt;</I>,<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;from&gt; Floating point value, start of the range<LI>        <B>[MANDATORY]</B>  &lt;to&gt; Floating point value, end of the range<LI>        <B>[MANDATORY]</B>  &lt;time&gt; Floating point value in the range of 0 - 1</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns a lerped value between &lt;from&gt; and &lt;to&gt; based on &lt;time&gt<BR><B>EXAMPLE:  </B>val = LerpFloat( 0, 10, 0.5);	// would return 5.0<BR></OL><P>
<HR><H1>void LerpVector(<I>&lt;from&gt;</I>,<I>&lt;to&gt;</I>,<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;from&gt; Vector, start of the range<LI>        <B>[MANDATORY]</B>  &lt;to&gt; Vector, end of the range<LI>        <B>[MANDATORY]</B>  &lt;time&gt; Floating point value in the range of 0 - 1</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns a lerped vector value between &lt;from&gt; and &lt;to&gt; based on &lt;time&gt<BR><B>EXAMPLE:  </B>val = LerpVector( (0,0,0), (5,5,5), 0.5);	// would return (2.5, 2.5, 2.5)<BR></OL><P>
<HR><H1>void Log(<I>&lt;number&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;number&gt;</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the logarithm of a number to base 10<BR><B>EXAMPLE:  </B>y = Log( x )<BR></OL><P>
<HR><H1>void MapFloat(<I>&lt;timeMin&gt;</I>,<I>&lt;timeMax&gt;</I>,<I>&lt;from&gt;</I>,<I>&lt;to&gt;</I>,<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;timeMin&gt; Floating point value, min time value<LI>        <B>[MANDATORY]</B>  &lt;timeMax&gt; Floating point value, max time value<LI>        <B>[MANDATORY]</B>  &lt;from&gt; Floating point value, start of the result range<LI>        <B>[MANDATORY]</B>  &lt;to&gt; Floating point value, end of the result range<LI>        <B>[MANDATORY]</B>  &lt;time&gt; Floating point value in the range from &lt;timeMin&gt; to &lt;timeMax&gt;</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns a lerped value between &lt;from&gt; and &lt;to&gt; based on &lt;time&gt;. &lt;time&gt; is a value between &lt;timeMin&gt; and &lt;timeMax&gt;.<BR><B>EXAMPLE:  </B>val = MapFloat( 1, 2, 0, 10, 1.5); // would return 5.0<BR></OL><P>
<HR><H1>void Max(<I>&lt;a&gt;</I>,<I>&lt;b&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;a&gt; A float or integer value.<LI>        <B>[MANDATORY]</B>  &lt;b&gt; A float or integer value.</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns whichever of &lt;a&gt; or &lt;b&gt; is larger.<BR><B>EXAMPLE:  </B>largest = Max( val1, val2 )<BR></OL><P>
<HR><H1>void Min(<I>&lt;a&gt;</I>,<I>&lt;b&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;a&gt; A float or integer value.<LI>        <B>[MANDATORY]</B>  &lt;b&gt; A float or integer value.</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns whichever of &lt;a&gt; or &lt;b&gt; is smallest.<BR><B>EXAMPLE:  </B>smallest = Min( val1, val2 )<BR></OL><P>
<HR><H1>void PackRgba(<I>&lt;red&gt;</I>,<I>&lt;green&gt;</I>,<I>&lt;blue&gt;</I>,<I>&lt;alpha&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;red&gt; as a float 0.0-1.0<LI>        <B>[MANDATORY]</B>  &lt;green&gt; as a float 0.0-1.0<LI>        <B>[MANDATORY]</B>  &lt;blue&gt; as a float 0.0-1.0<LI>        <B>[MANDATORY]</B>  &lt;alpha&gt; as a float 0.0-1.0</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Packs rgba into a single int.<BR><B>EXAMPLE:  </B>Byte4PackRgba( 1.0, 1.0, 1.0, 1.0 )<BR></OL><P>
<HR><H1>void PointOnSegmentNearestToPoint(<I>&lt;SegmentA&gt;</I>,<I>&lt;SegmentB&gt;</I>,<I>&lt;P&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;SegmentA&gt; One endpoint of the line segment<LI>        <B>[MANDATORY]</B>  &lt;SegmentB&gt; Other endpoint of the line segment<LI>        <B>[MANDATORY]</B>  &lt;P&gt; The point</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Given a line segment and a point P, this returns the point on the segment that is closest to P.<BR><B>EXAMPLE:  </B>nearestPoint = PointOnSegmentNearestToPoint( A, B, P )<BR><B>NOTES:  </B>This function will return A or B if P is beyond these two points.<BR></OL><P>
<HR><H1>void Pow(<I>&lt;exp&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;exp&gt; A float or integer value, &lt;b&gt;."</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Return the value of base raised to exp power.<BR><B>EXAMPLE:  </B>c = pow( 2, 4 )<BR></OL><P>
<HR><H1>void Project2Dto3D(<I>&lt;clientnum&gt;</I>,<I>&lt;x&gt;</I>,<I>&lt;y&gt;</I>,<I>&lt;depth&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;clientnum&gt; clientnumber - needed for viewport selection.<LI>        <B>[MANDATORY]</B>  &lt;x&gt; screen space x coord (-1,1)<LI>        <B>[MANDATORY]</B>  &lt;y&gt; screen space y coord (-1,1)<LI>        <B>[MANDATORY]</B>  &lt;depth&gt; depth to assume near clip is at (at this depth the screen will be edge to edge)</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>returns a world coordinate that projects to the given 2d coordinate ((-1,1),(-1,1))<BR><B>EXAMPLE:  </B>v=Project2DTo3D( 0, -1, -1, 5)<BR></OL><P>
<HR><H1>void Project3Dto2D(<I>&lt;clientnum&gt;</I>,<I>&lt;world_coordinate&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;clientnum&gt; client number - needed for viewport selection.<LI>        <B>[MANDATORY]</B>  &lt;world_coordinate&gt; world space vector</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>returns a screen coordinate vector (virtual UI coord) of a 3d coordinate <BR><B>EXAMPLE:  </B>hudPosition = Project3DTo2D( 0, target_pos )<BR></OL><P>
<HR><H1>void RandomFloat(<I>&lt;max&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;max&gt; The maximum floating point size</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns a random floating point number r, where 0 &lt;= r &lt; max<BR><B>EXAMPLE:  </B>if ( RandomFloat( 100 ) &gt; 50 ) ...<BR></OL><P>
<HR><H1>void RandomFloatRange(<I>&lt;min&gt;</I>,<I>&lt;max&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;min&gt; The minimum result<LI>        <B>[MANDATORY]</B>  &lt;max&gt; The maximum result</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns a random floating point number r, where min &lt;= r &lt; max<BR><B>EXAMPLE:  </B>rand = RandomFloatRange( 3.0, 5.0 )<BR></OL><P>
<HR><H1>void RandomInt(<I>&lt;max&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;max&gt; The maximum integer size</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns a random integer between 0 and max-1 inclusive<BR><B>EXAMPLE:  </B>if ( RandomInt( 100 ) &gt; 50 ) ...<BR></OL><P>
<HR><H1>void RandomIntRange(<I>&lt;min&gt;</I>,<I>&lt;max&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;min&gt; The minimum result<LI>        <B>[MANDATORY]</B>  &lt;max&gt; The maximum result + 1</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns a random integer r, where min &lt;= r &lt; max<BR><B>EXAMPLE:  </B>rand = RandomIntRange( 3, 5 )<BR></OL><P>
<HR><H1>void RotatePoint(<I>&lt;point&gt;</I>,<I>&lt;angles&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;point&gt; A point.<LI>        <B>[MANDATORY]</B>  &lt;angles&gt; An angle.</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns &lt;angle&gt; lerped angle value.<BR><B>EXAMPLE:  </B>rotatedPoint = RotatePoint(point, angle )<BR></OL><P>
<HR><H1>void RotatePointAroundAxis(<I>&lt;point&gt;</I>,<I>&lt;axis direction&gt;</I>,<I>&lt;degrees&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;point&gt;<LI>        <B>[MANDATORY]</B>  &lt;axis direction&gt;<LI>        <B>[MANDATORY]</B>  &lt;degrees&gt;</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>returns a vector that is the result of point rotated around the axis vector by num degrees<BR><B>EXAMPLE:  </B>v = RotatePointAroundAxis( point, up, degrees )<BR></OL><P>
<HR><H1>void Sin(<I>&lt;angle&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;angle&gt; An angle in degrees</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the sin of an angle<BR><B>EXAMPLE:  </B>frac = Sin( degrees )<BR></OL><P>
<HR><H1>void Sqrt(<I>&lt;a&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;a&gt; A float or integer value.</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the square-root of floating point value &lt;a&gt;.<BR><B>EXAMPLE:  </B>c = sqrt( (a*a) + (b*b) )<BR></OL><P>
<HR><H1>void Tan(<I>&lt;angle&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;angle&gt; An angle in degrees</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the tan of an angle<BR><B>EXAMPLE:  </B>frac = Tan( degrees )<BR></OL><P>
<HR><H1>void VectorCross(<I>&lt;vector a&gt;</I>,<I>&lt;vector b&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;vector a&gt; The first vector<LI>        <B>[MANDATORY]</B>  &lt;vector b&gt; The second vector</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the cross product of two vectors<BR></OL><P>
<HR><H1>void VectorDot(<I>&lt;vector a&gt;</I>,<I>&lt;vector b&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;vector a&gt; The first vector<LI>        <B>[MANDATORY]</B>  &lt;vector b&gt; The second vector</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the dot product of two vectors<BR></OL><P>
<HR><H1>void VectorFromLineToPoint(<I>&lt;SegmentA&gt;</I>,<I>&lt;SegmentB&gt;</I>,<I>&lt;P&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;SegmentA&gt; One point on the line<LI>        <B>[MANDATORY]</B>  &lt;SegmentB&gt; Another point on the line<LI>        <B>[MANDATORY]</B>  &lt;P&gt; The point</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Given a line and a point P, this returns a vector perpendicular to the line and pointing from the line to P.<BR><B>EXAMPLE:  </B>myvector = VectorFromLineToPoint( A, B, P )<BR></OL><P>
<HR><H1>void VectorLerp(<I>&lt;from&gt;</I>,<I>&lt;to&gt;</I>,<I>&lt;fraction&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;from&gt; The vector whose value is used when fraction is 0<LI>        <B>[MANDATORY]</B>  &lt;to&gt; The vector whose value is used when fraction is 1<LI>        <B>[MANDATORY]</B>  &lt;fraction&gt; The fraction of the way between vectors.  Values less than 0 or greater than 1 do linear extrapolation.</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Linear interpolates between two vectors.<BR><B>EXAMPLE:  </B>color = VectorLerp(oldColor, newColor, timeElapsed / timeTotal)<BR></OL><P>
<HR><H1>void VectorNormalize(<I>&lt;vector&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;vector&gt; The vector to normalize</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns a normalized copy of this vector<BR><B>EXAMPLE:  </B>difference = VectorNormalize(end - start)<BR></OL><P>
<HR><H1>void VectorProjection(<I>&lt;vector a&gt;</I>,<I>&lt;vector b&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;vector a&gt; The first vector<LI>        <B>[MANDATORY]</B>  &lt;vector b&gt; The second vector</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the vector projection of vector a onto vector b<BR></OL><P>
<HR><H1>void VectortoAngles(<I>&lt;vector&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;vector&gt; The vector to convert to angles</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns a set of angles corresponding to the given vector.<BR><B>EXAMPLE:  </B>angles = VectortoAngles(end - start)<BR></OL><P>
<HR><H1>void ViewAspect(<I>&lt;clientnum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;clientnum&gt; client number - needed for viewport selection.</UL><B>CATEGORY:  </B>Math<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>returns the horizontal screen aspect <BR><B>EXAMPLE:  </B>viewAspect = ViewAspect( localClientNum )<BR></OL><P>
<HR><H1>void &lt;player&gt; ActionButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the 'action' button. Use this for when the player might be in a scripted sequence but might still press the jump button.<BR><B>EXAMPLE:  </B>while( self ActionButtonPressed() )...<BR></OL><P>
<HR><H1>void &lt;player&gt; ActionSlotFourButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the action slot 4 button<BR><B>EXAMPLE:  </B>if ( self ActionSlotFourButtonPressed() ) ...<BR></OL><P>
<HR><H1>void &lt;player&gt; ActionSlotOneButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the action slot 1 button<BR><B>EXAMPLE:  </B>if ( self ActionSlotOneButtonPressed() ) ...<BR></OL><P>
<HR><H1>void &lt;player&gt; ActionSlotThreeButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the action slot 3 button<BR><B>EXAMPLE:  </B>if ( self ActionSlotThreeButtonPressed() ) ...<BR></OL><P>
<HR><H1>void &lt;player&gt; ActionSlotTwoButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the action slot 2 button<BR><B>EXAMPLE:  </B>if ( self ActionSlotTwoButtonPressed() ) ...<BR></OL><P>
<HR><H1>void &lt;client&gt; AddToDamageIndicator(<I>&lt;dmg&gt;</I>,<I>[direction]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;dmg&gt; The damage<LI>        <B>[OPTIONAL]</B>  [direction] The direction of hit</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Add damage to damage indicator<BR><B>EXAMPLE:  </B>self AddToDamageIndicator( int( armor_damage ), vDir)<BR></OL><P>
<HR><H1>void &lt;player&gt; AdsButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the 'ads' button.<BR><B>EXAMPLE:  </B>while( self AdsButtonPressed() )...<BR></OL><P>
<HR><H1>void &lt;player&gt; AllowAds(<I>&lt;player ads&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player ads&gt;: A boolean. true if the player can switch to ADS, and false otherwise.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether the player can switch to ADS<BR><B>EXAMPLE:  </B>player AllowAds( false )<BR></OL><P>
<HR><H1>void &lt;player&gt; AllowCrouch(<I>&lt;player crouch&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player crouch&gt;: A boolean. true if the player can crouch, and false otherwise</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether the player can crouch<BR><B>EXAMPLE:  </B>player AllowCrouch( false )<BR></OL><P>
<HR><H1>void &lt;player&gt; AllowDoubleJump(<I>&lt;on off&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;on off&gt;: A boolean. true if the player can double jump, and false otherwise</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether the player can double jump<BR><B>EXAMPLE:  </B>player AllowDoubleJump( false )<BR></OL><P>
<HR><H1>void &lt;player&gt; AllowJump(<I>&lt;player jump&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player jump&gt;: A boolean. True if the player can jump, and false otherwise</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether the player can jump<BR><B>EXAMPLE:  </B>player AllowJump(false)<BR></OL><P>
<HR><H1>void &lt;player&gt; AllowLean(<I>&lt;player lean&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player lean&gt;: A boolean. true if the player can lean, and false otherwise</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether the player can lean<BR><B>EXAMPLE:  </B>player AllowLean( false )<BR></OL><P>
<HR><H1>void &lt;player&gt; AllowMelee(<I>&lt;melee&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;melee&gt;: A boolean. True if the player can melee, and false otherwise</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether the player can melee<BR><B>EXAMPLE:  </B>player AllowMelee(false)<BR></OL><P>
<HR><H1>void &lt;player&gt; AllowMeleePowerLeft(<I>&lt;melee&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;melee&gt;: A boolean. True if the player can melee power left, and false otherwise</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether the player can melee power left<BR><B>EXAMPLE:  </B>player AllowMeleePowerLeft(false)<BR></OL><P>
<HR><H1>void &lt;player&gt; AllowProne(<I>&lt;player prone&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player prone&gt;: A boolean. true if the player can go prone, and false otherwise</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether the player can go prone<BR><B>EXAMPLE:  </B>player AllowProne( false )<BR></OL><P>
<HR><H1>void &lt;player&gt; AllowSlide(<I>&lt;on off&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;on off&gt;: A boolean. true if the player can slide, and false otherwise</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether the player can slide<BR><B>EXAMPLE:  </B>player AllowSlide( false )<BR></OL><P>
<HR><H1>void &lt;player&gt; AllowSpectateTeam(<I>&lt;team&gt;</I>,<I>&lt;spectate&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; A string description of the team. Valid teams are 'axis', 'allies', 'none' or 'freelook'<LI>        <B>[MANDATORY]</B>  &lt;spectate&gt; A boolean value describing whether this player can spectate on this team.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set whether the player can spectate the given team.<BR><B>EXAMPLE:  </B>self AllowSpectateTeam( "axis", true )<BR></OL><P>
<HR><H1>void &lt;player&gt; AllowSprint(<I>&lt;player sprint&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player sprint&gt;: A boolean. True if the player can sprint, and false otherwise</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether the player can sprint<BR><B>EXAMPLE:  </B>player AllowSprint(false)<BR></OL><P>
<HR><H1>void &lt;player&gt; AllowStand(<I>&lt;player stand&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player stand&gt;: A boolean. true if the player can stand, and false otherwise</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether the player can stand up<BR><B>EXAMPLE:  </B>player AllowStand( false )<BR></OL><P>
<HR><H1>void &lt;player&gt; AllowWallRun(<I>&lt;on off&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;on off&gt;: A boolean. true if the player can wallrun, and false otherwise</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether the player can wall run<BR><B>EXAMPLE:  </B>player AllowWallRun( false )<BR></OL><P>
<HR><H1>void &lt;player&gt; AnyAmmoForWeaponModes(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to check</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the weapon has any ammo left<BR><B>EXAMPLE:  </B>if ( !(self AnyAmmoForWeaponModes( weapon )) )<BR></OL><P>
<HR><H1>void &lt;player&gt; ApplyKnockBack(<I>&lt;amount&gt;</I>,<I>[dir]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;amount&gt; the amount of knockback to apply<LI>        <B>[OPTIONAL]</B>  [dir] the direction of knockback to apply</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Applies a knockback on a player.<BR><B>EXAMPLE:  </B>player ApplyKnockBack( 10, dir )<BR></OL><P>
<HR><H1>void &lt;player&gt; AreControlsFrozen()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the controls are frozen<BR><B>EXAMPLE:  </B>if( player AreControlsFrozen() )<BR></OL><P>
<HR><H1>void &lt;player&gt; AttackButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the fire button<BR><B>EXAMPLE:  </B>if ( self AttackButtonPressed() ) ...<BR></OL><P>
<HR><H1>void &lt;player&gt; BeginLocationAirstrikeSelection(<I>&lt;selection name&gt;</I>,<I>[radius]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;selection name&gt; The selection name<LI>        <B>[OPTIONAL]</B>  [radius] The radius of the selection</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Begin a location air strike selection<BR><B>EXAMPLE:  </B>self BeginLocationAirstrikeSelection( LOCATION_SELECTOR )<BR></OL><P>
<HR><H1>void &lt;player&gt; BeginLocationArtillerySelection(<I>&lt;selection name&gt;</I>,<I>[radius]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;selection name&gt; The selection name<LI>        <B>[OPTIONAL]</B>  [radius] The radius of the selection</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Begin a location artillery selection<BR><B>EXAMPLE:  </B>self BeginLocationArtillerySelection( LOCATION_SELECTOR )<BR></OL><P>
<HR><H1>void &lt;player&gt; BeginLocationComlinkSelection(<I>&lt;selection name&gt;</I>,<I>[radius]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;selection name&gt; The selection name<LI>        <B>[OPTIONAL]</B>  [radius] The radius of the selection</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Begin a location com link selection<BR><B>EXAMPLE:  </B>self BeginLocationComlinkSelection( LOCATION_SELECTOR, 1000 )<BR></OL><P>
<HR><H1>void &lt;player&gt; BeginLocationMortarSelection(<I>&lt;selection name&gt;</I>,<I>[radius]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;selection name&gt; The selection name<LI>        <B>[OPTIONAL]</B>  [radius] The radius of the selection</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Begin a location mortar selection<BR><B>EXAMPLE:  </B>self BeginLocationMortarSelection( LOCATION_SELECTOR, 1500 )<BR></OL><P>
<HR><H1>void &lt;player&gt; BeginLocationNapalmSelection(<I>&lt;selection name&gt;</I>,<I>[radius]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;selection name&gt; The selection name<LI>        <B>[OPTIONAL]</B>  [radius] The radius of the selection</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Begin a location napalm selection<BR><B>EXAMPLE:  </B>self BeginLocationNapalmSelection( LOCATION_SELECTOR )<BR></OL><P>
<HR><H1>void &lt;player&gt; BeginLocationSelection(<I>&lt;selection name&gt;</I>,<I>[radius]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;selection name&gt; The selection name<LI>        <B>[OPTIONAL]</B>  [radius] The radius of the selection</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Begin a location selection<BR><B>EXAMPLE:  </B>self BeginLocationSelection( LOCATION_SELECTOR )<BR></OL><P>
<HR><H1>void &lt;player&gt; BoostButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the change seat (Y) button<BR><B>EXAMPLE:  </B>if ( self BoostButtonPressed() ) ...<BR></OL><P>
<HR><H1>void &lt;bot&gt; BotSetRandomCharacterCustomization()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Equips this class number with the default class<BR><B>EXAMPLE:  </B>self BotSetRandomCharacterCustomization()<BR></OL><P>
<HR><H1>void &lt;player&gt; ButtonBitState(<I>&lt;button&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;button&gt;: name of button to check "BUTTON_BIT_ATTACK" for example, optionally can include as many button names as desired.  Returns true if all buttons indicated are true.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Return true if the button_bit(s) indicated are pressed (note:  there is no way to know exactly which buttons are pressed on the client, since everything is remapped into these bit values)<BR><B>EXAMPLE:  </B>if ( self ButtonBitState( "BUTTON_BIT_ATTACK") ) ...<BR><B>NOTES:  </B>You really shouldn't be using this, unless you KNOW that you should.  See buttonbits.h for button bit names.<BR></OL><P>
<HR><H1>void &lt;player&gt; ButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the host is pressing the button/key, "BUTTON_A", "BUTTON_B", "K", etc...<BR><B>EXAMPLE:  </B>while( self ButtonPressed( "BUTTON_A" ) ) ...<BR><B>NOTES:  </B>(it will only check the host player's buttons though)<BR></OL><P>
<HR><H1>void &lt;player&gt; CalcPlayerOptions(<I>&lt;custom class slot&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;custom class slot&gt; The custom class slot</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Calculate player options<BR><B>EXAMPLE:  </B>playerRenderOptions = self CalcPlayerOptions( class_num )<BR></OL><P>
<HR><H1>void &lt;player&gt; CalcWeaponOptions(<I>&lt;custom class slot&gt;</I>,<I>&lt;weapon slot&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;custom class slot&gt; The custom class slot<LI>        <B>[MANDATORY]</B>  &lt;weapon slot&gt; primary weapon=0 or secondary weapon=1 or knife weapon=2</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Calculates weapon options<BR><B>EXAMPLE:  </B>primaryWeaponOptions = self CalcWeaponOptions( class_num, 0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; CameraActivate(<I>&lt;active&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;active&gt; True to activate the camera, false to turn it off and return to 1st person view</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Turns the script camera on or off.<BR><B>EXAMPLE:  </B>get_players()[0] CameraActivate( true )<BR></OL><P>
<HR><H1>void &lt;player&gt; CameraSetAngles(<I>[position]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [position] Either an entity to focus the camera on or a vector defining the camera's focus point</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the focus point of the script camera.<BR><B>EXAMPLE:  </B>get_players()[0] CameraSetAngles( ( 1100, -23, 644 ) )get_players()[0] CameraSetAngles( my_entity )<BR></OL><P>
<HR><H1>void &lt;player&gt; CameraSetLookAt(<I>[position]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [position] Either an entity to focus the camera on or a vector defining the camera's focus point</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the focus point of the script camera.<BR><B>EXAMPLE:  </B>get_players()[0] CameraSetLookAt( ( 1100, -23, 644 ) )get_players()[0] CameraSetLookAt( my_entity )<BR></OL><P>
<HR><H1>void &lt;player&gt; CameraSetPosition(<I>&lt;position&gt;</I>,<I>[angles]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; Either an entity to link the camera to or a vector defining the world position<LI>        <B>[OPTIONAL]</B>  [angles] The angles to set for the camera</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the position of the script camera.<BR><B>EXAMPLE:  </B>get_players()[0] CameraSetPosition( ( 1100, -23, 644 ) )get_players()[0] CameraSetPosition( my_entity )<BR></OL><P>
<HR><H1>void &lt;player&gt; CanPlaceRiotshield()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Try to place riotshield where the player is standing.  return an array containing placement "result", "origin", and "angles<BR><B>EXAMPLE:  </B>placement = level.player CanPlaceRiotshield()<BR></OL><P>
<HR><H1>void &lt;player&gt; CanPlayerPlaceTurret()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Try to place a Turret where the player is looking.  It'll return an array containing the placement "result", "origin", and "angles".<BR><B>EXAMPLE:  </B>placement = level.player CanPlayerPlaceTurret()<BR></OL><P>
<HR><H1>void &lt;player&gt; CanPlayerPlaceVehicle(<I>&lt;radius&gt;</I>,<I>&lt;height&gt;</I>,<I>&lt;forward Distance&gt;</I>,<I>&lt;up Distance&gt;</I>,<I>&lt;sweep Distance&gt;</I>,<I>&lt;min normal&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;radius&gt; Radius of the bounds check<LI>        <B>[MANDATORY]</B>  &lt;height&gt; Height of the bounds check<LI>        <B>[MANDATORY]</B>  &lt;forward Distance&gt; Distance away from player origin.<LI>        <B>[MANDATORY]</B>  &lt;up Distance&gt; Distance up from player origin.<LI>        <B>[MANDATORY]</B>  &lt;sweep Distance&gt; Distance to sweep downwards.<LI>        <B>[MANDATORY]</B>  &lt;min normal&gt; Minimum hit normal needed to be pass.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Try to place a vehicle in front of the player.  It'll return an array containing the placement "result", "origin", and "angles".<BR><B>EXAMPLE:  </B>placement = level.player CanPlayerPlaceVehicle( 25, 45, 50, 40, 80, 0.7 )<BR></OL><P>
<HR><H1>entity &lt;player&gt; CantSeeEntities(<I>&lt;entArray&gt;</I>,<I>&lt;dotRange&gt;</I>,<I>&lt;trace&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entArray&gt; The entities to check against<LI>        <B>[MANDATORY]</B>  &lt;dotRange&gt; The cosine of the angle representing your fov<LI>        <B>[MANDATORY]</B>  &lt;trace&gt; Perform a trace for entities</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the set of entities that a player cannot see within a given angle, given a set of entities<BR><B>EXAMPLE:  </B>if( isplayer( self.enemy ) && self.enemy CantSeeEntities( entArray, 67 ) )<BR></OL><P>
<HR><H1>void &lt;player&gt; CarryTurret(<I>&lt;turret&gt;</I>,<I>&lt;offset&gt;</I>,<I>&lt;angleOffset&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;turret&gt; The turret entity<LI>        <B>[MANDATORY]</B>  &lt;offset&gt; the offset from the player to place the turret<LI>        <B>[MANDATORY]</B>  &lt;angleOffset&gt; the angle offset of the turret</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Links the auto turret to the player to carry around.<BR><B>EXAMPLE:  </B>player CarryTurret( turret, offset, angleOffset )<BR></OL><P>
<HR><H1>void &lt;player&gt; ChangeSeatButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the change seat (Y) button<BR><B>EXAMPLE:  </B>if ( self ChangeSeatButtonPressed() ) ...<BR></OL><P>
<HR><H1>void &lt;client&gt; ClearDamageIndicator()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clear damage indicator<BR><B>EXAMPLE:  </B>self ClearDamageIndicator()<BR></OL><P>
<HR><H1>void &lt;player&gt; ClearPerks()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>removes all perks for a player<BR><B>EXAMPLE:  </B>player ClearPerks()<BR></OL><P>
<HR><H1>entity &lt;client&gt; ClonePlayer(<I>&lt;deathAnimationDuration&gt;</I>,<I>&lt;killing weapon&gt;</I>,<I>&lt;attacker&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;deathAnimationDuration&gt; the duration of the death animation<LI>        <B>[MANDATORY]</B>  &lt;killing weapon&gt; weapon that killed the player<LI>        <B>[OPTIONAL]</B>  &lt;attacker&gt; attacker that killed the player</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>clone the player's model for death animations.<BR><B>EXAMPLE:  </B>body = self ClonePlayer(deathAnimDuration)<BR></OL><P>
<HR><H1>void &lt;client&gt; CloseInGameMenu()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>close the in game menu for this client.<BR><B>EXAMPLE:  </B>player CloseInGameMenu()<BR></OL><P>
<HR><H1>void &lt;player&gt; CloseLUIMenu(<I>&lt;lui menu handle&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;lui menu handle&gt; handle to the lui menu.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Closes the given lui menu and returns true if it finds the menu and succeeds in closing it, false otherwise.<BR><B>EXAMPLE:  </B>player CloseLUIMenu( menu )<BR></OL><P>
<HR><H1>void &lt;client&gt; CloseMenu(<I>&lt;menu index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;menu index&gt; The precached menu index of type "menu"</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>close the specified menu for this client.<BR><B>EXAMPLE:  </B>player CloseMenu( game[ "menu_changeclass" ] )<BR></OL><P>
<HR><H1>entity &lt;client&gt; CreateFlashbackClone()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>clone the player's model for temporary flashback model<BR><B>EXAMPLE:  </B>body = self CreateFlashbackClone()<BR></OL><P>
<HR><H1>void &lt;player&gt; DamageRiotShield()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Apply damage to a player riot shield or other weapon that supports damage states.<BR><B>EXAMPLE:  </B>newhealth = player DamageRiotShield( 100 ) )<BR></OL><P>
<HR><H1>void &lt;player&gt; DeathStreakActive()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if player's death streak is active<BR><B>EXAMPLE:  </B>if( player DeathStreakActive() )<BR></OL><P>
<HR><H1>void &lt;player&gt; DisableDeathStreak()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Disable player's death streak<BR><B>EXAMPLE:  </B>player DisableDeathStreak()<BR></OL><P>
<HR><H1>void &lt;player&gt; DisableInvulnerability()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Makes player vulnerable to damage.  This is default behavior<BR><B>EXAMPLE:  </B>player DisableInvulnerability()<BR></OL><P>
<HR><H1>void &lt;player&gt; DisableOffhandWeapons()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Disable the player's offhand weapons<BR><B>EXAMPLE:  </B>player DisableOffhandWeapons()<BR></OL><P>
<HR><H1>void &lt;player&gt; DisableRoundStartDelay()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enable players weapon after round start delay<BR><B>EXAMPLE:  </B>player DisableRoundStartDelay()<BR></OL><P>
<HR><H1>void &lt;player&gt; DisableUsability()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Disables usability for the player<BR><B>EXAMPLE:  </B>player DisableUsability()<BR></OL><P>
<HR><H1>void &lt;player&gt; DisableWeaponCycling()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Disable the player's weapon cycling<BR><B>EXAMPLE:  </B>player DisableWeaponCycling()<BR></OL><P>
<HR><H1>void &lt;player&gt; DisableWeaponFire()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Disable the player's weapon fire<BR><B>EXAMPLE:  </B>player DisableWeaponFire(()<BR></OL><P>
<HR><H1>void &lt;player&gt; DisableWeapons(<I>[quick]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [quick] Set the Disable weapons quick flag</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Disable the weapons of the player<BR><B>EXAMPLE:  </B>self DisableWeapons()<BR></OL><P>
<HR><H1>entity &lt;player&gt; DropItem(<I>&lt;item name&gt;</I>,<I>[dropTag]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;item name&gt; the name of the item to drop<LI>        <B>[OPTIONAL]</B>  [dropTag] If specified drop and snap the weapon to this tag</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Drop an item with the given item name<BR><B>EXAMPLE:  </B>self DropItem( current )<BR></OL><P>
<HR><H1>entity &lt;player&gt; DropScavengerItem(<I>&lt;item name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;item name&gt; the name of the item to drop</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Drop an item with the given item name. This item will be only available to those with the scavenger perk<BR><B>EXAMPLE:  </B>self DropScavengerItem( "scavenger_item_mp" )<BR></OL><P>
<HR><H1>void &lt;player&gt; EnableDeathStreak()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enable player's death streak<BR><B>EXAMPLE:  </B>player EnableDeathStreak()<BR></OL><P>
<HR><H1>void &lt;player&gt; EnableInvulnerability()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Makes player invulnerable to damage<BR><B>EXAMPLE:  </B>player EnableInvulnerability()<BR></OL><P>
<HR><H1>void &lt;player&gt; EnableOffhandWeapons()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enable the player's offhand weapons<BR><B>EXAMPLE:  </B>player EnableOffhandWeapons()<BR></OL><P>
<HR><H1>void &lt;player&gt; EnableRoundStartDelay()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Disable the players weapon during round start<BR><B>EXAMPLE:  </B>player EnableRoundStartDelay()<BR></OL><P>
<HR><H1>void &lt;player&gt; EnableUsability()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enables usability for the player<BR><B>EXAMPLE:  </B>player EnableUsability()<BR></OL><P>
<HR><H1>void &lt;player&gt; EnableWeaponCycling()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enable the player's weapon cycling<BR><B>EXAMPLE:  </B>player EnableWeaponCycling()<BR></OL><P>
<HR><H1>void &lt;player&gt; EnableWeaponFire()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enable the player's weapon fire<BR><B>EXAMPLE:  </B>player EnableWeaponFire()<BR></OL><P>
<HR><H1>void &lt;player&gt; EnableWeapons()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enables the weapons of the player<BR><B>EXAMPLE:  </B>self EnableWeapons()<BR></OL><P>
<HR><H1>void &lt;player&gt; EndLocationSelection()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Ends location selection<BR><B>EXAMPLE:  </B>self endLocationSelection()<BR></OL><P>
<HR><H1>void &lt;player&gt; FakeDamageFrom(<I>&lt;dir&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;dir&gt; The direction to take damage from</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Make the player take damage from the given direction<BR><B>EXAMPLE:  </B>self FakeDamageFrom(vDir)<BR></OL><P>
<HR><H1>void &lt;client&gt; finishMeleeHit(<I>&lt;Attacker&gt;</I>,<I>&lt;Weapon&gt;</I>,<I>&lt;Origin&gt;</I>,<I>&lt;Direction&gt;</I>,<I>&lt;bone index&gt;</I>,<I>&lt;shieldHit&gt;</I>,<I>&lt;hit&gt;</I>,<I>&lt;fromBehind&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;Attacker&gt; The entity that is attacking.<LI>        <B>[MANDATORY]</B>  &lt;Weapon&gt; The weapon number of the weapon used to inflict the damage<LI>        <B>[MANDATORY]</B>  &lt;Origin&gt; (vector) The origin of the damage<LI>        <B>[MANDATORY]</B>  &lt;Direction&gt; (vector) The direction of the damage<LI>        <B>[MANDATORY]</B>  &lt;bone index&gt; Which bone was the closest to the hit<LI>        <B>[MANDATORY]</B>  &lt;shieldHit&gt; Was the hit delivered against a shield<LI>        <B>[MANDATORY]</B>  &lt;hit&gt; Was the hit successful or a swipe<LI>        <B>[MANDATORY]</B>  &lt;fromBehind&gt; Was the hit from behind the victim</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Notifies the clients of the melee hit or miss<BR><B>EXAMPLE:  </B>self finishMeleeHit( eAttacker, sWeapon, vPoint, vDir, iBoneIndex, bHit )<BR></OL><P>
<HR><H1>void &lt;client&gt; FinishPlayerDamage(<I>&lt;Inflictor&gt;</I>,<I>&lt;Attacker&gt;</I>,<I>&lt;Damage&gt;</I>,<I>&lt;Damage Flags&gt;</I>,<I>&lt;Means Of Death&gt;</I>,<I>&lt;Weapon&gt;</I>,<I>&lt;Point&gt;</I>,<I>&lt;Direction&gt;</I>,<I>&lt;Hit Loc&gt;</I>,<I>&lt;Damage Origin&gt;</I>,<I>&lt;Offset Time&gt;</I>,<I>&lt;bone index&gt;</I>,<I>&lt;Surface Normal&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;Inflictor&gt; The entity that causes the damage.(e.g. a turret)<LI>        <B>[MANDATORY]</B>  &lt;Attacker&gt; The entity that is attacking.<LI>        <B>[MANDATORY]</B>  &lt;Damage&gt; Integer specifying the amount of damage done<LI>        <B>[MANDATORY]</B>  &lt;Damage Flags&gt; Integer specifying flags that are to be applied to the damage<LI>        <B>[MANDATORY]</B>  &lt;Means Of Death&gt; Integer specifying the method of death<LI>        <B>[MANDATORY]</B>  &lt;Weapon&gt; The weapon number of the weapon used to inflict the damage<LI>        <B>[MANDATORY]</B>  &lt;Point&gt; Damage point<LI>        <B>[MANDATORY]</B>  &lt;Direction&gt; (vector) The direction of the damage<LI>        <B>[MANDATORY]</B>  &lt;Hit Loc&gt; The location of the hit<LI>        <B>[MANDATORY]</B>  &lt;Damage Origin&gt; Where the damage originated from.<LI>        <B>[MANDATORY]</B>  &lt;Offset Time&gt; The time offset for the damage<LI>        <B>[MANDATORY]</B>  &lt;bone index&gt; Which bone was the closest to the hit<LI>        <B>[MANDATORY]</B>  &lt;Surface Normal&gt; The normal of the surface impacted.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Does damage to a player - usually as part of the damage callback<BR><B>EXAMPLE:  </B>self FinishPlayerDamage( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, sWeapon, vPoint, vDir, sHitLoc, iBone, vDamageOrigin, psOffsetTime, vSurfaceNormal )<BR></OL><P>
<HR><H1>void &lt;player&gt; ForceGrenadeThrow()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Forces the player to throw a held grenade<BR><B>EXAMPLE:  </B>player ForceGrenadeThrow()<BR></OL><P>
<HR><H1>void &lt;player&gt; ForceOffHandEnd()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Force the player to not use offhand weapon<BR><B>EXAMPLE:  </B>self forceoffhandend()<BR></OL><P>
<HR><H1>void &lt;player&gt; ForceSlick(<I>&lt;slick&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slick&gt;: A boolean. True if the player is on a slick surface, and false otherwise</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether the player is forced to be on a slick surface<BR><B>EXAMPLE:  </B>player ForceSlick(true)<BR></OL><P>
<HR><H1>void &lt;player&gt; FragButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the frag button<BR><B>EXAMPLE:  </B>if ( self FragButtonPressed() ) ...<BR></OL><P>
<HR><H1>void &lt;player&gt; FreezeControls(<I>&lt;freeze state&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;freeze state&gt;: true if the player's controls are frozen, false otherwise.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Blocks or unblocks control input from this player<BR><B>EXAMPLE:  </B>player FreezeControls( true )<BR></OL><P>
<HR><H1>void &lt;player&gt; FreezeControlsAllowLook(<I>&lt;freeze state&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;freeze state&gt;: true if the player's controls are frozen, false otherwise.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Blocks or unblocks control input from this player, but allows the player to look around<BR><B>EXAMPLE:  </B>level.player FreezeControlsAllowLook( true )<BR></OL><P>
<HR><H1>void &lt;player&gt; GamepadUsedLast()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is playing with a gamepad.<BR><B>EXAMPLE:  </B>if( player GamepadUsedLast() )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetCharacterBodyModel(<I>&lt;modelType&gt;</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  &lt;modelType&gt; The index of the model type, defaults to CCBODY_MODEL_THIRDPERSON</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the body model for this player as selected in character customization<BR><B>EXAMPLE:  </B>self GetCharacterBodyModel()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetCharacterBodyRenderOptions()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the body render options for this player<BR><B>EXAMPLE:  </B>self GetCharacterBodyRenderOptions()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetCharacterBodyType()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the character body type for the player.<BR><B>EXAMPLE:  </B>bodyIndex = self GetCharacterBodyType( )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetCharacterHeadModel()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the head model for this player<BR><B>EXAMPLE:  </B>self GetCharacterHelmetModel()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetCharacterHelmetModel(<I>&lt;modelType&gt;</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  &lt;modelType&gt; The index of the model type, defaults to CCBODY_MODEL_THIRDPERSON</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the helmet model for this player as selected in character customization<BR><B>EXAMPLE:  </B>self GetCharacterHelmetModel()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetControllerUIModelValue(<I>&lt;ui model data path from controller&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;ui model data path from controller&gt; precached name string for the data which we're trying to get.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets a data value for a given lui menu, the data name has to be precached and the value as well, if its a string.<BR><B>EXAMPLE:  </B>player GetControllerUIModelValue( "hudItems.regenDelayProgress")<BR></OL><P>
<HR><H1>void &lt;player&gt; GetCurrentOffHand()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the current offhand weapon<BR><B>EXAMPLE:  </B>weapon = self GetCurrentOffhand()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetCurrentWeapon()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the current player weapon<BR><B>EXAMPLE:  </B>currentweapon = player GetCurrentWeapon()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetCurrentWeaponAltWeapon()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the alt weapon for the players current weapon.  Returns "none<BR><B>EXAMPLE:  </B>currentweapon = player GetCurrentWeaponAltWeapon()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetCurrentWeaponSpinLerp()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the current weapon spin <BR><B>EXAMPLE:  </B>weapon_spin_lerp = self GetCurrentWeaponSpinLerp()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetEnemyDogTagModel()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the enemy of the dog tag model currently associated character body<BR><B>EXAMPLE:  </B>friendly_model = player GetEnemyDogTagModel( )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetFractionMaxAmmo(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to give max ammo to</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get fraction of the max ammo<BR><B>EXAMPLE:  </B>frac = players[i] GetFractionMaxAmmo( lethal_grenade )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetFractionStartAmmo(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to give ammo to</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Give fraction of start ammo to the player for the weapon<BR><B>EXAMPLE:  </B>start = player GetFractionStartAmmo( weapon )<BR></OL><P>
<HR><H1>entity &lt;player&gt; GetFriendlies(<I>[bool]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [bool] true, return only players that are alive, false return all players</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of friendly players. The player called on is not included in the array.<BR><B>EXAMPLE:  </B>friends = self GetFriendlies()<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetFriendlyDogTagModel()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the friendly of the dog tag model currently associated character body<BR><B>EXAMPLE:  </B>friendly_model = player GetFriendlyDogTagModel( )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetGunAngles()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the player's gun angles<BR><B>EXAMPLE:  </B>angles = player GetGunAngles()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetHeroAbilityName()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the name of the weapon assigned to the currently selected body<BR><B>EXAMPLE:  </B>weaponName = self GetHeroAbilityName()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetHeroWeaponName()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the name of the weapon assigned to the currently selected body<BR><B>EXAMPLE:  </B>weaponName = self GetHeroWeaponName()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetInventoryHeldWeapon()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the player's inventory held weapon<BR><B>EXAMPLE:  </B>inventoryWeapon = player GetInventoryHeldWeapon()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetInventoryWeapon()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the inventory weapon<BR><B>EXAMPLE:  </B>inventoryWeapon = self GetInventoryWeapon()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetIpAddress()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the ip address of the player<BR><B>EXAMPLE:  </B>ipAddress = self GetIpAddress()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetLeagueTeamID()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the league team ID<BR><B>EXAMPLE:  </B>id = player GetLeagueTeamID()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetLightingState()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the current lighting state for the player<BR><B>EXAMPLE:  </B>ls = player GetLightingState()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetLockOnLossRadius()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the lock on loss radius for the currently equipped heatseeking launcher.<BR><B>EXAMPLE:  </B>radius = player GetLockOnRadius()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetLockOnOrigin(<I>&lt;bool&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;bool&gt;: true or false.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>gets the origin to use for the replay gun lockon on the entity<BR><B>EXAMPLE:  </B>player GetLockOnOrigin( entity )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetLockOnRadius()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the lock on radius for the currently equipped heatseeking launcher.<BR><B>EXAMPLE:  </B>radius = player GetLockOnRadius()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetLockOnSpeed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the lock on speed in miliseconds for the currently equipped heatseeking launcher.<BR><B>EXAMPLE:  </B>speed = player GetLockOnSpeed()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetLUIMenu(<I>&lt;lui menu name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;lui menu name&gt; name of the menu.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns a handle to a lui menu.<BR><B>EXAMPLE:  </B>player GetLUIMenu( "myMenu" )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetLUIMenuData(<I>&lt;lui menu handle&gt;</I>,<I>&lt;lui menu data name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;lui menu handle&gt; handle for the lui menu.<LI>        <B>[MANDATORY]</B>  &lt;lui menu data name&gt; name of the data which had been set on the menu.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the current value for the given data name.<BR><B>EXAMPLE:  </B>player GetLUIMenuData( menu, "title" )<BR></OL><P>
<HR><H1>void &lt;entity&gt; GetMpDialogName()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the name of the mpdialog bundle of the currently associated character body<BR><B>EXAMPLE:  </B>mpDialogBundleName = player GetMpDialogName( )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetNormalizedCameraMovement()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the player's camera movement normalized<BR><B>EXAMPLE:  </B>v_stick = player GetNormalizedCameraMovement()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetNormalizedMovement()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the player's movement normalized<BR><B>EXAMPLE:  </B>norm_move = self GetNormalizedMovement()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetOffHandSecondaryClass()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get whether the player is using a flash or smoke<BR><B>EXAMPLE:  </B>offhand_secondary = self GetOffHandSecondaryClass()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetPerks()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns an array of all player perks. The array is size 0 if the player has no perks.<BR><B>EXAMPLE:  </B>perks = player GetPerks()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetPlayerAngles()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the player view angles<BR><B>EXAMPLE:  </B>angles = player GetPlayerAngles()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetPlayerAttachmentCosmeticVariantIndexes(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to get acvi from</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the player's held weapon acvi <BR><B>EXAMPLE:  </B>acvi = self GetPlayerAttachmentCosmeticVariantIndexes( weapon )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetPlayerCameraPos()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the player's camera position<BR><B>EXAMPLE:  </B>vieworg = player GetPlayerCameraPos()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetPlayerGenderType(<I>&lt;mode&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;mode&gt; SessionMode</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the gender string of the player<BR><B>EXAMPLE:  </B>if ( self GetPlayerGenderType() == "male" )<BR></OL><P>
<HR><H1>void GetPlayerMovementState()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the player movement state for the match record.  <BR></OL><P>
<HR><H1>void &lt;player&gt; GetPlayerSelectedGesture(<I>&lt;gestureType&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;gestureType&gt; The type of gesture to get</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the equipped gesture <BR><B>EXAMPLE:  </B>gesture = player GetPlayerSelectedGesture( 0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetPlayerSelectedTaunt(<I>&lt;tauntType&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;tauntType&gt; The type of taunt to get</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the equipped taunt <BR><B>EXAMPLE:  </B>taunt = player GetPlayerSelectedTaunt( 0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetPlayerShowcaseWeapon()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the showcase weapon of the given player<BR><B>EXAMPLE:  </B>showcaseWeapon = player GetPlayerShowcaseWeapon()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetPlayerViewHeight()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the player's view height<BR><B>EXAMPLE:  </B>height = player GetPlayerViewHeight()<BR></OL><P>
<HR><H1>void &lt;player&gt; getreplaygunlockonorigin(<I>&lt;bool&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;bool&gt;: true or false.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>gets the origin to use for the replay gun lockon on the entity<BR><B>EXAMPLE:  </B>player GetLockOnOrigin( entity )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetSnapshotAckIndex()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the snapshot acknowledgment index<BR><B>EXAMPLE:  </B>num = self getsnapshotackindex()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetSunShadowSplitDistance()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the current sun shadow split difference for the player<BR><B>EXAMPLE:  </B>distance = player GetSunShadowSplitDistance()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetTargetScreenAngles(<I>&lt;targetpos&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;targetpos&gt; The position to get angles for.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get target screen view angles<BR><B>EXAMPLE:  </B>angles = self GetTargetScreenAngles( targetpos )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetVehicleBoostTime()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the vehicle's max boost time<BR><B>EXAMPLE:  </B>boostTime = player GetVehicleBoostTime()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetVehicleBoostTimeLeft()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the vehicle's remaining boost time<BR><B>EXAMPLE:  </B>boostTimeLeft = player GetVehicleBoostTimeLeft()<BR></OL><P>
<HR><H1>entity &lt;player&gt; GetVehicleFocusEntity()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the current vehicle focus entity for the player<BR><B>EXAMPLE:  </B>focusEnt = player GetVehicleFocusEntity()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetVehicleMinBoostTime()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the vehicle's min boost time needed in order to boost<BR><B>EXAMPLE:  </B>minBoostTime = player GetVehicleMinBoostTime()<BR></OL><P>
<HR><H1>entity &lt;player&gt; GetVehicleOccupied()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the vehicle entity that the player occupies.  If player isn't in a vehicle then this causes an error.<BR><B>EXAMPLE:  </B>self GetVehicleOccupied()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetWeaponAcvi(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets weapon options from held weapon<BR><B>EXAMPLE:  </B>primaryWeaponAcvi = self GetWeaponAcvi( weapon )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetWeaponAmmoClip(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to get ammo count from</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the weapon's ammo count in clip<BR><B>EXAMPLE:  </B>ammo = self GetWeaponAmmoClip( weapon )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetWeaponAmmoFuel(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to get fuel count from</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the weapon's fuel count <BR><B>EXAMPLE:  </B>fuel = self GetWeaponAmmoFuel( weapon )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetWeaponAmmoStock(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to get ammo count from</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the weapon's total ammo count <BR><B>EXAMPLE:  </B>ammo = self GetWeaponAmmoStock( weapon )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetWeaponForWeaponRoot(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to check</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns a weapon that the player is holding that has the same weapon root.  Returns undefined if the player is not holding the weapon.<BR><B>EXAMPLE:  </B>weapon_with_attachments = player GetWeaponForWeaponRoot( &lt;weapon&gt; )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetWeaponOptions(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to get options from</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the weapon's render options <BR><B>EXAMPLE:  </B>weaponOptions = self GetWeaponOptions( weapon )<BR></OL><P>
<HR><H1>void &lt;player&gt; GetWeaponsList(<I>[include_alt_modes]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [include_alt_modes] 1/True to include alt-mode weapons</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets an array of all weapons that the player has.  Alt-mode weapons by default are not included<BR><B>EXAMPLE:  </B>weapList = player GetWeaponsList()<BR></OL><P>
<HR><H1>void &lt;player&gt; GetWeaponsListPrimaries()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR></OL><P>
<HR><H1>void &lt;entity&gt; GiveDedicatedShadow(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The entity to enable the dedicated shadow on</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the model lod bias<BR><B>EXAMPLE:  </B>player GiveDedicatedShadow( 8 )<BR></OL><P>
<HR><H1>void &lt;player&gt; GiveMaxAmmo(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to give ammo to</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Give the weapon max ammo<BR><B>EXAMPLE:  </B>self GiveMaxAmmo( primary )<BR></OL><P>
<HR><H1>void &lt;player&gt; GiveNextBaseWeapon()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Give the player the next base weapon<BR><B>EXAMPLE:  </B>self GiveNextBaseWeapon()<BR></OL><P>
<HR><H1>void &lt;player&gt; GiveStartAmmo(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to give ammo to</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Give the weapon initial ammo<BR><B>EXAMPLE:  </B>self GiveStartAmmo( primary )<BR></OL><P>
<HR><H1>void &lt;player&gt; GiveWeapon(<I>&lt;weapon&gt;</I>,<I>[options]</I>,<I>[acvi]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to give<LI>        <B>[OPTIONAL]</B>  [options] The weapon options<LI>        <B>[OPTIONAL]</B>  [acvi] The attachment cosmetic variant index</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Give a weapon to the player<BR><B>EXAMPLE:  </B>e_player GiveWeapon( w_spike_launcher )<BR></OL><P>
<HR><H1>void &lt;player&gt; GiveWeaponNextAttachment(<I>&lt;attachment point&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;attachment point&gt; The attachment point name</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Give the weapon the next attachment<BR><B>EXAMPLE:  </B>self giveweaponnextattachment( "muzzle" )<BR></OL><P>
<HR><H1>void &lt;player&gt; HasAGrenadePulledBack()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>check is a client has a grenade (any type including special) currently pulled back<BR><B>EXAMPLE:  </B>self HasAGrenadePulledBack( )<BR></OL><P>
<HR><H1>void &lt;player&gt; HasMaxPrimaryWeapons()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player has maximum primary weapons<BR><B>EXAMPLE:  </B>if( self HasMaxPrimaryWeapons() )<BR></OL><P>
<HR><H1>void &lt;player&gt; HasPerk(<I>&lt;perk name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;perk name&gt; the perk to check</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>test if player has a perk<BR><B>EXAMPLE:  </B>player HasPerk( "specialty_gpsjammer" )<BR></OL><P>
<HR><H1>void &lt;player&gt; HasRiotShield()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Return true if player has a riot shield in their inventory.<BR><B>EXAMPLE:  </B>if ( player HasRiotShield() )<BR></OL><P>
<HR><H1>void &lt;player&gt; HasWeapon(<I>&lt;weapon&gt;</I>,<I>&lt;ignore_attachments&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to check<LI>        <B>[OPTIONAL]</B>  &lt;ignore_attachments&gt; Only check the root weapon, ignore all the attachments.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player has the given weapon<BR><B>EXAMPLE:  </B>if( e_player HasWeapon( w_spike_launcher, true ) )<BR></OL><P>
<HR><H1>void &lt;player&gt; HideViewModel()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Hide the player's current view model.<BR><B>EXAMPLE:  </B>player HideViewModel()<BR></OL><P>
<HR><H1>void &lt;player&gt; InitialWeaponRaise(<I>&lt;weapon name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon name&gt; The weapon to try first raise anim with</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Setup weaponstate to force first raise animation<BR><B>EXAMPLE:  </B>self InitialWeaponRaise( "ak47" )<BR></OL><P>
<HR><H1>void &lt;player&gt; InventoryButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the inventory button<BR><B>EXAMPLE:  </B>if ( self InventoryButtonPressed() ) ...<BR></OL><P>
<HR><H1>void &lt;player&gt; IsCarryingTurret()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if player is carrying turret or not.<BR><B>EXAMPLE:  </B>player IsCarryingTurret()<BR></OL><P>
<HR><H1>void &lt;player&gt; IsChargeShotPending()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if player has a charge shot pending with a charge shot weapon<BR><B>EXAMPLE:  </B>if( self IsChargeShotPending() )<BR></OL><P>
<HR><H1>void &lt;player&gt; IsDroppingWeapon()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player is currently dropping their weapon<BR><B>EXAMPLE:  </B>player IsDroppingWeapon()<BR></OL><P>
<HR><H1>void &lt;player&gt; IsFiring()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player is currently meleeing<BR><B>EXAMPLE:  </B>player IsFiring()<BR></OL><P>
<HR><H1>void &lt;player&gt; IsGrappling()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player is currently grappling<BR><B>EXAMPLE:  </B>player IsGrappling()<BR></OL><P>
<HR><H1>void &lt;player&gt; IsHost()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player is the host<BR><B>EXAMPLE:  </B>player IsHost()<BR></OL><P>
<HR><H1>void &lt;player&gt; IsHostForBots()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the passed in entity is the host for bots<BR><B>EXAMPLE:  </B>player IsHostForBots()<BR></OL><P>
<HR><H1>void &lt;player&gt; IsInMoveMode(<I>&lt;move_mode_1&gt;</I>,<I>[move_mode_2]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;move_mode_1&gt; The move mode to check<LI>        <B>[OPTIONAL]</B>  [move_mode_2] The move mode to check</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player is in either of the given move modes<BR><B>EXAMPLE:  </B>if ( player IsInMoveMode( "ufo", "noclip" ) )<BR></OL><P>
<HR><H1>void &lt;player&gt; IsInVehicle()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns whether or not this player is currently occupying a vehicle.<BR><B>EXAMPLE:  </B>self IsInVehicle()<BR></OL><P>
<HR><H1>void &lt;player&gt; IsLocalToHost()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player is on the same physical machine as the host<BR><B>EXAMPLE:  </B>player IsLocalToHost()<BR></OL><P>
<HR><H1>void &lt;player&gt; IsLookingAt(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The entity to check</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player is looking at entity<BR><B>EXAMPLE:  </B>if( isplayer( self.enemy ) && self.enemy islookingat( self ) )<BR></OL><P>
<HR><H1>void &lt;player&gt; IsMeleeing()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player is currently meleeing<BR><B>EXAMPLE:  </B>player IsMeleeing()<BR></OL><P>
<HR><H1>void &lt;player&gt; IsPlayerOnSameMachine(<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player to test against</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns whether or not this player is on the same machine as the other player.<BR><B>EXAMPLE:  </B>if ( self IsPlayerOnSameMachine( player ) )<BR></OL><P>
<HR><H1>void &lt;player&gt; IsReloading()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player is currently reloading<BR><B>EXAMPLE:  </B>player IsReloading()<BR></OL><P>
<HR><H1>void &lt;player&gt; IsRemoteControlling()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns whether or not this player is currently occupying a remote controlled entity.<BR><B>EXAMPLE:  </B>self IsRemoteControlling()<BR></OL><P>
<HR><H1>void &lt;player&gt; IsSwitchingWeapons()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player is currently switching weapons<BR><B>EXAMPLE:  </B>player IsSwitchingWeapons()<BR></OL><P>
<HR><H1>void &lt;player&gt; IsTalking()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player is talking via voice chat<BR><B>EXAMPLE:  </B>if( player IsTalking() )<BR></OL><P>
<HR><H1>void &lt;player&gt; IsThrowingGrenade()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the player is currently throwing a grenade<BR><B>EXAMPLE:  </B>player IsThrowingGrenade()<BR></OL><P>
<HR><H1>void &lt;player&gt; IsUsingOffHand()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if player is using offhand weapon<BR><B>EXAMPLE:  </B>if( self IsUsingOffHand() )<BR></OL><P>
<HR><H1>void &lt;player&gt; IsWeaponOverheating(<I>[get heatval]</I>,<I>[weapon]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [get heatval] If positive pass back the heatval of the weapon (0 to 100).<LI>        <B>[OPTIONAL]</B>  [weapon] If present check this specific weapon otherwise check the player's current weapon.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Is the players Weapon Overheating?<BR><B>EXAMPLE:  </B>self IsWeaponOverheating()<BR></OL><P>
<HR><H1>void &lt;player&gt; IsWeaponViewOnlyLinked()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns whether or not this player is linked to an enity with weapon view only linking.<BR><B>EXAMPLE:  </B>self IsWeaponViewOnlyLinked()<BR></OL><P>
<HR><H1>void &lt;player&gt; JumpButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the 'jump' button.<BR><B>EXAMPLE:  </B>while( self JumpButtonPressed() )...<BR></OL><P>
<HR><H1>void &lt;player&gt; LinkGuidedMissileCamera()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>set player eflags for the guided missile<BR><B>EXAMPLE:  </B>player LinkGuidedMissileCamera()<BR></OL><P>
<HR><H1>void &lt;player&gt; LinkToMissile(<I>missile entity to link the player to</I>,<I>[boost_enabled]</I>,<I>[brake_enabled]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  missile entity to link the player to<LI>        <B>[OPTIONAL]</B>  [boost_enabled]: If true, the player can trigger missile boost<LI>        <B>[OPTIONAL]</B>  [brake_enabled]: If true, the player can trigger missile brake</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Links a player camera and controls to a missile<BR><B>EXAMPLE:  </B>player LinkToMissile( rocket, true )<BR></OL><P>
<HR><H1>void &lt;player&gt; MeleeButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the melee button<BR><B>EXAMPLE:  </B>if ( self MeleeButtonPressed() ) ...<BR></OL><P>
<HR><H1>void &lt;player&gt; MurderLine(<I>&lt;from&gt;</I>,<I>&lt;to&gt;</I>,<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;from&gt; The from position<LI>        <B>[MANDATORY]</B>  &lt;to&gt; The to position<LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon used</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get all the enemy players on the line between given points and murder them to death<BR><B>EXAMPLE:  </B>player MurderLine( origin, endpos, "kniferang_mp" )<BR></OL><P>
<HR><H1>void &lt;player&gt; NextPlayerRenderOption(<I>&lt;optionName&gt;</I>,<I>&lt;forward&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;optionName&gt; The tag of the next option<LI>        <B>[MANDATORY]</B>  &lt;forward&gt; The delta</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the next player render option<BR><B>EXAMPLE:  </B>level.dev_cac_player NextPlayerRenderOption( tag, forward )<BR></OL><P>
<HR><H1>void &lt;player&gt; OffhandSpecialButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the gadget button<BR><B>EXAMPLE:  </B>if ( self OffhandSpecialButtonPressed() ) ...<BR></OL><P>
<HR><H1>void &lt;player&gt; OpenLUIMenu(<I>&lt;lui menu name&gt;</I>,<I>[persistent]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;lui menu name&gt; name of the menu.<LI>        <B>[OPTIONAL]</B>  [persistent] the menu will remain open even if the player dies.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Opens a lui menu( has to be precahced ) and returns a handle to it.<BR><B>EXAMPLE:  </B>player OpenLUIMenu( "myMenu", true )<BR></OL><P>
<HR><H1>void &lt;player&gt; OpenMenu(<I>&lt;menu index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;menu index&gt; The menu index</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Open the menu with the given menu index<BR><B>EXAMPLE:  </B>self openMenu( game[ "menu_changeclass" ] )<BR></OL><P>
<HR><H1>void &lt;player&gt; OpenMenuNoMouse(<I>&lt;menu index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;menu index&gt; The menu index</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Open the menu with the given menu index<BR><B>EXAMPLE:  </B>self OpenMenuNoMouse( game[ "menu_changeclass" ] )<BR></OL><P>
<HR><H1>void &lt;player&gt; PickupAmmoEvent(<I>[weapon]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [weapon]: Weapon to use for the event</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Lets the client know a weapon was picked up<BR><B>EXAMPLE:  </B>self PickupAmmoEvent( weapon )<BR></OL><P>
<HR><H1>void &lt;player&gt; PickupWeaponEvent(<I>[weapon]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  [weapon]: Weapon to use for the event</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Lets the client know a weapon was picked up<BR><B>EXAMPLE:  </B>self PickupWeaponEvent( weapon )<BR></OL><P>
<HR><H1>void &lt;player&gt; PingPlayer()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Flashes a player on their teammate's compasses<BR><B>EXAMPLE:  </B>self PingPlayer()<BR></OL><P>
<HR><H1>void &lt;player&gt; PlayBombDefuse()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Play the players bomb defuse animation<BR><B>EXAMPLE:  </B>self PlayBombDefuse()<BR></OL><P>
<HR><H1>void &lt;player&gt; PlayBombPlant()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Play the players bomb plant animation<BR><B>EXAMPLE:  </B>self PlayBombPlant()<BR></OL><P>
<HR><H1>void PlayClientAirstrike(<I>&lt;position&gt;</I>,<I>&lt;yaw&gt;</I>,<I>&lt;teamFaction&gt;</I>,<I>&lt;team&gt;</I>,<I>&lt;owner&gt;</I>,<I>&lt;exittype&gt;</I>,<I>&lt;height&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; The position of airstrike<LI>        <B>[MANDATORY]</B>  &lt;yaw&gt; The yaw<LI>        <B>[MANDATORY]</B>  &lt;teamFaction&gt; The team faction<LI>        <B>[MANDATORY]</B>  &lt;team&gt; The team<LI>        <B>[MANDATORY]</B>  &lt;owner&gt; The owner of airstike<LI>        <B>[MANDATORY]</B>  &lt;exittype&gt; The exit type<LI>        <B>[MANDATORY]</B>  &lt;height&gt; The height </UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Plays the client sided part of the airstrike/bombrun<BR><B>EXAMPLE:  </B>PlayClientAirstrike( pos, yaw, "marines", "axis", owner, "left", height )<BR></OL><P>
<HR><H1>void PlayClientNapalm(<I>&lt;position&gt;</I>,<I>&lt;yaw&gt;</I>,<I>&lt;teamFaction&gt;</I>,<I>&lt;team&gt;</I>,<I>&lt;owner&gt;</I>,<I>&lt;exittype&gt;</I>,<I>&lt;height&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;position&gt; The position of Napalm<LI>        <B>[MANDATORY]</B>  &lt;yaw&gt; The yaw<LI>        <B>[MANDATORY]</B>  &lt;teamFaction&gt; The team faction<LI>        <B>[MANDATORY]</B>  &lt;team&gt; The team<LI>        <B>[MANDATORY]</B>  &lt;owner&gt; The owner of Napalm<LI>        <B>[MANDATORY]</B>  &lt;exittype&gt; The exit type<LI>        <B>[MANDATORY]</B>  &lt;height&gt; The height </UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Plays the client sided part of the Napalm<BR><B>EXAMPLE:  </B>PlayClientNapalm( startPos, plane.yaw, "vietcong", "axis", plane.owner, "left", height )<BR></OL><P>
<HR><H1>void &lt;player&gt; PlayerADS()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the player weapon position fraction<BR><B>EXAMPLE:  </B>if ( self PlayerADS() &gt; 0.3 )<BR></OL><P>
<HR><H1>void &lt;actor&gt; PlayerKnockback(<I>&lt;true/false&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;true/false&gt; if true, client affected by knockback</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Turn knockback on and off for a player<BR><B>EXAMPLE:  </B>self PlayerKnockback( true )<BR></OL><P>
<HR><H1>void &lt;player&gt; PlayHitMarker(<I>&lt;sound name&gt;</I>,<I>&lt;damage state&gt;</I>,<I>&lt;perk feedback&gt;</I>,<I>&lt;is dead&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;sound name&gt; The name of the sound or hash<LI>        <B>[OPTIONAL]</B>  &lt;damage state&gt; How damaged the victim is<LI>        <B>[OPTIONAL]</B>  &lt;perk feedback&gt; If the victim had any perks active that modified the hit marker<LI>        <B>[OPTIONAL]</B>  &lt;is dead&gt; If the victim has died from this hit marker and needs a red flash</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Plays a hit marker event<BR><B>EXAMPLE:  </B>self PlayHitMarker( "evt_squad_activate", 3, "flakjacket" )<BR></OL><P>
<HR><H1>void &lt;player&gt; PlayLocalSound(<I>&lt;sound name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;sound name&gt; The name of the sound or hash</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Plays a sound locally<BR><B>EXAMPLE:  </B>self playlocalsound( "evt_squad_activate" )<BR></OL><P>
<HR><H1>void &lt;player&gt; PrimaryButtonPressedLocal()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the local player is pressing the primary button (BUTTON_A)<BR><B>EXAMPLE:  </B>if ( self PrimaryButtonPressedLocal() ) ...<BR></OL><P>
<HR><H1>void &lt;player&gt; PrimeMovie(<I>&lt;moviename&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;moviename&gt; movie name</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Starts priming the cinematic movie to be played.<BR><B>EXAMPLE:  </B>self PrimeMovie( "mymovie" )<BR></OL><P>
<HR><H1>void &lt;player&gt; ReloadButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the 'usereload' button.<BR><B>EXAMPLE:  </B>while( self reloadButtonPressed() )...<BR></OL><P>
<HR><H1>void &lt;player&gt; ReloadWeaponAmmo(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to be reloaded</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the weapon's ammoclip from the ammo<BR><B>EXAMPLE:  </B>self ReloadWeaponAmmo( &lt;weapon&gt; )<BR></OL><P>
<HR><H1>void &lt;player&gt; RemoteControlTurret(<I>&lt;turret&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;turret&gt; the remote controlled turret.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Remote control into a turret<BR><B>EXAMPLE:  </B>player RemoteControlTurret( turret )<BR></OL><P>
<HR><H1>void &lt;player&gt; RemoteControlTurretOff(<I>&lt;turret&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;turret&gt; the remote controlled turret.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stops remote controlling a turret<BR><B>EXAMPLE:  </B>player RemoteControlTurretOff( turret )<BR></OL><P>
<HR><H1>void &lt;player&gt; ResetAnimations()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Reset player animations after a body type change<BR><B>EXAMPLE:  </B>self ResetAnimations())<BR></OL><P>
<HR><H1>void &lt;player&gt; ResetCharacterCustomization()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Resets all of the character customization to what is in the player stats<BR><B>EXAMPLE:  </B>self ResetCharacterCustomization()<BR></OL><P>
<HR><H1>void &lt;player&gt; ResetFlashBack()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Resets the players flashback history<BR><B>EXAMPLE:  </B>self resetflashback()<BR></OL><P>
<HR><H1>void &lt;player&gt; ResetSpreadOverride()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Reset the player's aim spread to 255<BR><B>EXAMPLE:  </B>self ResetSpreadOverride()<BR></OL><P>
<HR><H1>void &lt;player&gt; Revive()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Revive the player<BR><B>EXAMPLE:  </B>self Revive())<BR></OL><P>
<HR><H1>void &lt;client&gt; RevivePlayer()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Callback from script to get player out of last stand, increases health, removes damage timer, should clear screen of damageFX<BR><B>EXAMPLE:  </B>self RevivePlayer()<BR></OL><P>
<HR><H1>void &lt;player&gt; SayAll(<I>&lt;message&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;message&gt; A localizable message to send to all players</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Write a client chat message from this client to everybody<BR><B>EXAMPLE:  </B>self SayAll( saytext )<BR></OL><P>
<HR><H1>void &lt;player&gt; SayTeam(<I>&lt;message&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;message&gt; A localizable message to send to all players on the player's team.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Write a client chat message from this client to everybody on their team<BR><B>EXAMPLE:  </B>self SayTeam( sayText )<BR></OL><P>
<HR><H1>void &lt;player&gt; SecondaryButtonPressedLocal()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the local player is pressing the secondary button (BUTTON_B)<BR><B>EXAMPLE:  </B>if ( self SecondaryButtonPressedLocal() ) ...<BR></OL><P>
<HR><H1>void &lt;player&gt; SecondaryOffhandButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the secondary offhand button<BR><B>EXAMPLE:  </B>if ( self SecondaryOffhandButtonPressed() ) ...<BR></OL><P>
<HR><H1>void &lt;player&gt; SetActionSlot(<I>&lt;slot&gt;</I>,<I>&lt;action slot type&gt;</I>,<I>[weapon]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slot&gt; The action slot<LI>        <B>[MANDATORY]</B>  &lt;action slot type&gt; The type of slot. can be "weapon"/"altMode"/""<LI>        <B>[OPTIONAL]</B>  [weapon] The weapon to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets action slot for the player<BR><B>EXAMPLE:  </B>self SetActionSlot( 4, "weapon", level.DEAD_CONTROL_WEAPON )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetArenaPoints(<I>&lt;point&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;point&gt; points</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the player's arena points<BR><B>EXAMPLE:  </B>player SetArenaPoints( 19 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetBlockWeaponPickup(<I>&lt;weapon&gt;</I>,<I>&lt;enabled&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to set block for<LI>        <B>[MANDATORY]</B>  &lt;enabled&gt; True if weapon pickup should be blocked</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Blocks the player from picking up other weapons while using this weapon<BR><B>EXAMPLE:  </B>self setBlockWeaponPickup( killstreakWeapon, true )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetCarryingObject(<I>&lt;onoff&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;onoff&gt; True to enable, false otherwise</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enable or disable the player carrying object flag. Disables doublejump and juke<BR><B>EXAMPLE:  </B>self SetCarryingObject( true );  // disables doublejump and juke<BR></OL><P>
<HR><H1>void &lt;player&gt; SetCharacterBodyStyle(<I>&lt;character body type index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;character body type index&gt; The index of the character body type</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the character body style for the current body type.  Resets all colors for the body style to default.<BR><B>EXAMPLE:  </B>self SetCharacterBodyStyle( 0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetCharacterBodyType(<I>&lt;character body type index&gt;</I>,<I>&lt;character head type index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;character body type index&gt; The index of the character body type<LI>        <B>[OPTIONAL]</B>  &lt;character head type index&gt; The index of the character head type</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the character body type for the player.  Resets all other customization to default for the new body type.<BR><B>EXAMPLE:  </B>self SetCharacterBodyType( 1 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetCharacterHelmetStyle(<I>&lt;character body type index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;character body type index&gt; The index of the character body type</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the character body style for the current helmet type.  Resets all colors for the helmet style to default.<BR><B>EXAMPLE:  </B>self SetCharacterHelmetStyle( 0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetClientCGObjectiveText(<I>&lt;text&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;text&gt; The text to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the objective text only on this client<BR><B>EXAMPLE:  </B>self SetClientCGObjectiveText( util::getObjectiveScoreText( self.pers["team"] ) )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetClientCompass(<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;value&gt; The value to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets compass dvar only on this client<BR><B>EXAMPLE:  </B>self SetClientCompass( 0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetClientDrawTalk(<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;value&gt; The value to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets cg_drawTalk dvar only on this client<BR><B>EXAMPLE:  </B>self SetClientDrawTalk( 3 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetClientFocalLength(<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;value&gt; The focal length value to set (float)</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets cg_focalLength dvar only on this client<BR><B>EXAMPLE:  </B>self SetClientFocalLength( 23.3622 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetClientHUDHardcore(<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;value&gt; The value to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets ui_hud_hardcore dvar only on this client<BR><B>EXAMPLE:  </B>self SetClientHUDHardcore( 0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetClientMiniScoreboardHide(<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;enable&gt; True/1 to hide, false/0 otherwise</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets miniscoreboardhide dvar only on this client<BR><B>EXAMPLE:  </B>players[i] SetClientMiniScoreboardHide( true )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetClientNumLives(<I>&lt;numLives&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;numLives&gt; The numlives to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets scr_numLives dvar only on this client<BR><B>EXAMPLE:  </B>self SetClientNumLives( level.numLives )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetClientPlayerPushAmount(<I>&lt;amount&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;amount&gt; The push amount</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets playerPushAmount dvar only on this client<BR><B>EXAMPLE:  </B>self SetClientPlayerPushAmount( 1 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetClientPlayerSprintTime(<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; The spring time</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets player_sprintTime dvar only on this client<BR><B>EXAMPLE:  </B>self SetClientPlayerSprintTime( level.playerSprintTime )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetClientScriptMainMenu(<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;value&gt; The value to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets g_scriptMainMenu dvar only on this client<BR><B>EXAMPLE:  </B>self SetClientScriptMainMenu( game["menu_class"] )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetClientThirdPerson(<I>&lt;onoff&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;onoff&gt; 1 to set, 0 otherwise</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the client to be third person<BR><B>EXAMPLE:  </B>self SetClientThirdPerson( 1 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetClientThirdPersonAngle(<I>&lt;angle&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;angle&gt; The angle to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets cg_thirdPerson dvar only on this client<BR><B>EXAMPLE:  </B>self SetClientThirdPersonAngle( 354 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetClientUIVisibilityFlag(<I>&lt;flagName&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flagName&gt; The name of the flag<LI>        <B>[MANDATORY]</B>  &lt;value&gt; The value to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets a HUD visibility flag only on this client<BR><B>EXAMPLE:  </B>e_player SetClientUIVisibilityFlag( "hud_visible", 1 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetControllerUIModelValue(<I>&lt;ui model data path from controller&gt;</I>,<I>&lt;ui model value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;ui model data path from controller&gt; precached name string for the data which we're trying to set.<LI>        <B>[MANDATORY]</B>  &lt;ui model value&gt; value for the data which we're trying to set on the controller.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets a data value for a given lui menu, the data name has to be precached and the value as well, if its a string.<BR><B>EXAMPLE:  </B>player SetControllerUIModelValue( "hudItems.regenDelayProgress", 0.2 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetCurrentSpectatorClient(<I>&lt;client&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;client&gt; The client to set spectator</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the given client as a spectator<BR><B>EXAMPLE:  </B>self SetCurrentSpectatorClient( player )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetCurrentWeaponSpinLerp(<I>&lt;spin&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;spin&gt; The spin value</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the current weapon's spin <BR><B>EXAMPLE:  </B>self SetCurrentWeaponSpinLerp( 0.0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetDisabledTargetHint(<I>[weapon]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [weapon]: Weapon to use for the event</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set target not selected hint<BR><B>EXAMPLE:  </B>self SetDisabledTargetHint()<BR></OL><P>
<HR><H1>void &lt;player&gt; SetElectrifiedState(<I>&lt;electrified&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;electrified&gt;: bool whether the player should be in this state.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the player into the electrified state for 3rd person anim purposes. Different from SetElectrified() which plays the postfx<BR></OL><P>
<HR><H1>void &lt;player&gt; SetEnterTime(<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; The time to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the player's session enter time<BR><B>EXAMPLE:  </B>self setEnterTime( getTime() )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetEverHadWeaponAll(<I>&lt;flag&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;flag&gt; True to set the flag</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the EverHadAllPlayerHeldWeapons flag of the player<BR><B>EXAMPLE:  </B>self SetEverHadWeaponAll( true )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetHighlighted(<I>&lt;onoff&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;onoff&gt; True to highlight, false otherwise</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Highlight the player<BR><B>EXAMPLE:  </B>self SetHighlighted( true )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetInventoryHeldWeapon(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The held weapon to be set as inventoryHeldWeapon. Use undefined to clear the inventoryHeldWeapon.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the player's inventoryHeldWeapon.<BR><B>EXAMPLE:  </B>player SetInventoryHeldWeapon( weapon )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetInventoryWeapon(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the inventory weapon<BR><B>EXAMPLE:  </B>self SetInventoryWeapon( weapon )<BR></OL><P>
<HR><H1>void SetLowReady(<I>&lt;enable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;enable&gt; true to set this state</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>set the player into low ready weapon state. <BR><B>EXAMPLE:  </B>self SetLowReady(true)<BR></OL><P>
<HR><H1>void &lt;player&gt; SetLUIMenuData(<I>&lt;lui menu handle&gt;</I>,<I>&lt;lui menu data name&gt;</I>,<I>&lt;lui menu data value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;lui menu handle&gt; handle to the lui menu opened.<LI>        <B>[MANDATORY]</B>  &lt;lui menu data name&gt; precached name string for the data which we're trying to set.<LI>        <B>[MANDATORY]</B>  &lt;lui menu data value&gt; value for the data which we're trying to set on the menu.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets a data value for a given lui menu, the data name has to be precached and the value as well, if its a string.<BR><B>EXAMPLE:  </B>player SetLUIMenuData( menu, "title", "Some Title" )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetModelLodBias(<I>&lt;bias&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;bias&gt; bias. Setting of 0 reverts to the model lod bias.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the model lod bias<BR><B>EXAMPLE:  </B>player SetModelLodBias( 8 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetNoLOSOnTargetsHint(<I>[weapon]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [weapon]: Weapon to use for the event</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set target not selected hint<BR><B>EXAMPLE:  </B>self SetNoLOSOnTargetsHint()<BR></OL><P>
<HR><H1>void &lt;player&gt; SetNoTargetsHint(<I>[weapon]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [weapon]: Weapon to use for the event</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set target not selected hint<BR><B>EXAMPLE:  </B>self SetNoTargetsHint()<BR></OL><P>
<HR><H1>void &lt;player&gt; setOffhandPrimaryClass(<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; the weapon name</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set whether the player is using a grenade or gear.<BR><B>EXAMPLE:  </B>player setOffhandPrimaryClass( "claymore_mp" )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetOffhandSecondaryClass(<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; the weapon name</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set whether the player is using a flash or smoke grenade.<BR><B>EXAMPLE:  </B>player SetOffhandSecondaryClass( "concussion_grenade_mp" )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetOffhandVisible(<I>&lt;onoff&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;onoff&gt; True/1 to enable, false otherwise</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enable or disable visibility of the offhand weapon<BR><B>EXAMPLE:  </B>self SetOffhandVisible( true )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetOrigin(<I>&lt;origin&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The origin to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the player's origin<BR><B>EXAMPLE:  </B>player SetOrigin( v_origin )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetParagonIconId(<I>&lt;paragon icon id&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;paragon icon id&gt; the paragon rank id</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the player's paragon icon id<BR><B>EXAMPLE:  </B>player SetParagonIconId( 1, 1 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetParagonRank(<I>&lt;paragon rank id&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;paragon rank id&gt; the paragon rank id</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the player's paragon rank<BR><B>EXAMPLE:  </B>player SetParagonRank( 1, 1 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetPerk(<I>&lt;perk name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;perk name&gt; the perk to give</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>give the specified perk<BR><B>EXAMPLE:  </B>player SetPerk( "specialty_gpsjammer" )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetPlacementHint(<I>&lt;onoff&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;onoff&gt; true if the hint should say that the weapon can be placed, false if not</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the placement hint string that will be displayed for this player.<BR><B>EXAMPLE:  </B>player SetPlacementHint( turret.canBePlaced )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetPlayerAngles(<I>&lt;angles&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;angles&gt; The view angles to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the player's view angles<BR><B>EXAMPLE:  </B>player SetPlayerAngles( v_angles )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetPlayerRenderOptions(<I>&lt;options&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;options&gt; The player render options</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the player render options<BR><B>EXAMPLE:  </B>self SetPlayerRenderOptions( playerRenderOptions );	<BR></OL><P>
<HR><H1>void &lt;player&gt; SetRank(<I>&lt;rank id&gt;</I>,<I>[prestige level]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;rank id&gt; the rank id<LI>        <B>[OPTIONAL]</B>  [prestige level] The prestige level</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the player's rank and prestige level<BR><B>EXAMPLE:  </B>player SetRank( 1, 2 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetRiotshieldFailHint(<I>[weapon]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [weapon]: Weapon to use for the event</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set riot shield fail hint<BR><B>EXAMPLE:  </B>self SetRiotshieldFailHint()<BR></OL><P>
<HR><H1>void &lt;player&gt; SetSpawnWeapon(<I>&lt;weapon name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon name&gt; The name of the weapon to spawn with</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the weapon that this player will spawn with<BR><B>EXAMPLE:  </B>self SetSpawnWeapon( "ak47" )during prematch period or grace period in mp)<BR></OL><P>
<HR><H1>void &lt;player&gt; SetSpreadOverride(<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;value&gt; The value to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the player's aim spread <BR><B>EXAMPLE:  </B>self SetSpreadOverride( 0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetSprintCooldown(<I>&lt;duration&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;duration&gt; The duration to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the player's sprint cooldown duration<BR><B>EXAMPLE:  </B>self SetSprintCooldown( 4 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetSprintDuration(<I>&lt;duration&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;duration&gt; The duration to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the player's sprint duration<BR><B>EXAMPLE:  </B>self SetSprintDuration( 4 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetSunShadowSplitDistance(<I>&lt;distance&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;distance&gt; split distance. Setting of 0 reverts to the default split distance.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the sun shadow split distance for the player<BR><B>EXAMPLE:  </B>player SetSunShadowSplitDistance( 200 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetTacticalWheel(<I>&lt;enabled&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;enabled&gt; turn on or off</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets whether this player will be able to use the cybercom tactical wheel or not<BR><B>EXAMPLE:  </B>player SetTacticalWheel( true )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetTargetAlreadyInUseHint(<I>[weapon]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [weapon]: Weapon to use for the event</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set  target already in use failure hint<BR><B>EXAMPLE:  </B>self SetTargetAlreadyInUseHint()<BR></OL><P>
<HR><H1>void &lt;player&gt; SetTargetAlreadyTargetedHint(<I>[weapon]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [weapon]: Weapon to use for the event</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set target already being targeted hint<BR><B>EXAMPLE:  </B>self SetTargetAlreadyTargetedHint()<BR></OL><P>
<HR><H1>void &lt;player&gt; SetTargetedEntityEndTime(<I>&lt;weapon&gt;</I>,<I>&lt;endtime&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon (player should have this weapon)<LI>        <B>[MANDATORY]</B>  &lt;endtime&gt; The end time of the targeted entity</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set targeted entity end time, for use on the client side in the UI. <BR><B>EXAMPLE:  </B>self SetTargetedEntityEndTime( weapon, 0.0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetTargetedMissilesRemaining(<I>&lt;weapon&gt;</I>,<I>&lt;missilesRemaining&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon (player should have this weapon)<LI>        <B>[MANDATORY]</B>  &lt;missilesRemaining&gt; The amount of missiles remaining to destroy the target</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set targeted entity missiles remaining, for use on the client side in the UI. <BR><B>EXAMPLE:  </B>self SetTargetedMissilesRemaining( weapon, 0.0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetTargetingAbortedHint(<I>[weapon]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [weapon]: Weapon to use for the event</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set targeting aborted hint<BR><B>EXAMPLE:  </B>self SetDisabledTargetHint()<BR></OL><P>
<HR><H1>void &lt;player&gt; SetTargetOORHint(<I>[weapon]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [weapon]: Weapon to use for the event</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set out of range failure hint<BR><B>EXAMPLE:  </B>self SetTargetOORHint()<BR></OL><P>
<HR><H1>void &lt;player&gt; SetTargetWrongTypeHint(<I>[weapon]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [weapon]: Weapon to use for the event</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set target validity failure hint<BR><B>EXAMPLE:  </B>self SetTargetWrongTypeHint()<BR></OL><P>
<HR><H1>void &lt;player&gt; SetVehicleDamageMeter(<I>&lt;damage&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;damage&gt; the amount of damage normalized 0..1</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the vehicle damage meter<BR><B>EXAMPLE:  </B>player SetRefEndTime( killstreaEndTime )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetVehicleDrivableDuration(<I>&lt;duration&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;duration&gt; the drivable duration in milliseconds</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the drivable duration for the players vehicle (intended for use with client side display purposes)<BR><B>EXAMPLE:  </B>player SetVehicleDrivableDuration( killstreakDuration )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetVehicleDrivableEndTime(<I>&lt;end time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;end time&gt; the drivable end time in milliseconds</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the vehicle drivable end time.<BR><B>EXAMPLE:  </B>player SetVehicleDrivableEndTime( killstreakEndTime )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetVehicleFocusEntity(<I>&lt;focus entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;focus entity&gt; The entity to focus on</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the focus entity for a player driven vehicle (currently only supported by helicopters).  This will attempt to make the vehicle orient towards the focus target.<BR><B>EXAMPLE:  </B>player SetVehicleFocusEntity( focusEntity )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetVehicleLockedOnByEnt(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; an entity that acquired a missile lock on the player's vehicle</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the vehicle locked on by entity<BR><B>EXAMPLE:  </B>player SetVehicleLockedOnByEnt( mostDangerousEnemyWithLockOn )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetVehicleWeaponWaitDuration(<I>&lt;duration&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;duration&gt; the weapon reload (or recharge) duration in milliseconds</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the weapon wait duration for the players vehicle (intended for use with client side display purposes)<BR><B>EXAMPLE:  </B>player SetVehicleWeaponWaitDuration( reloadDuration )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetVehicleWeaponWaitEndTime(<I>&lt;end time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;end time&gt; the weapon wait end time in milliseconds</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the vehicle weapon wait end time.<BR><B>EXAMPLE:  </B>player SetVehicleWeaponWaitEndTime( weaponReloadEndTime )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetVelocity(<I>&lt;velocity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;velocity&gt; The velocity to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the velocity of the player<BR><B>EXAMPLE:  </B>self setvelocity(force)<BR></OL><P>
<HR><H1>void &lt;player&gt; SetViewClamp()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the view clamp for the player, only works during animscripted for now.  Ranges are relative to tag_camera.  Left, Right, Top, Bottom<BR><B>EXAMPLE:  </B>player SetViewClamp( 50, 50, 30, 30 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetWeaponAmmoClip(<I>&lt;weapon&gt;</I>,<I>&lt;ammo&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon<LI>        <B>[MANDATORY]</B>  &lt;ammo&gt; The ammo count</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the weapon's ammo<BR><B>EXAMPLE:  </B>self SetWeaponAmmoClip( weapon, weapon.clipSize )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetWeaponAmmoFuel(<I>&lt;weapon&gt;</I>,<I>&lt;fuel&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon<LI>        <B>[MANDATORY]</B>  &lt;fuel&gt; The ammo fuel amount</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the weapon ammo fuel<BR><B>EXAMPLE:  </B>self SetWeaponAmmoFuel( weapon, weapondata["fuel"] )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetWeaponAmmoStock(<I>&lt;weapon&gt;</I>,<I>&lt;ammo&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon<LI>        <B>[MANDATORY]</B>  &lt;ammo&gt; The new ammo count</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the weapon's ammo<BR><B>EXAMPLE:  </B>reviver SetWeaponAmmoStock( level.weaponReviveTool, 1 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetWeaponFriendlyHacking(<I>&lt;weapon&gt;</I>,<I>&lt;isFriendlyHacking&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon (player should have this weapon)<LI>        <B>[MANDATORY]</B>  &lt;isFriendlyHacking&gt; Set to true if a friendly is hacking the target</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the weapon lockon completion percentage<BR><B>EXAMPLE:  </B>self SetWeaponFriendlyTargetLocked( weapon, 0.0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetWeaponFriendlyTargeting(<I>&lt;weapon&gt;</I>,<I>&lt;isFriendlyTargeting&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon (player should have this weapon)<LI>        <B>[MANDATORY]</B>  &lt;isFriendlyTargeting&gt; Set to true if a friendly is targetting</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the weapon lockon completion percentage<BR><B>EXAMPLE:  </B>self SetWeaponFriendlyTargeting( weapon, 0.0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetWeaponFriendlyTargetLocked(<I>&lt;weapon&gt;</I>,<I>&lt;isFriendlyTargetLocked&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon (player should have this weapon)<LI>        <B>[MANDATORY]</B>  &lt;isFriendlyTargetLocked&gt; Set to true if a friendly is target locked</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the weapon lockon completion percentage<BR><B>EXAMPLE:  </B>self SetWeaponFriendlyTargetLocked( weapon, 0.0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetWeaponHackPercent(<I>&lt;weapon&gt;</I>,<I>&lt;heat&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon (player should have this weapon)<LI>        <B>[MANDATORY]</B>  &lt;heat&gt; The heat percent to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the weapon hack completion percentage<BR><B>EXAMPLE:  </B>self SetWeaponHackPercent( weapon, 0.0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetWeaponHeatPercent(<I>&lt;weapon&gt;</I>,<I>&lt;heat&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon (player should have this weapon)<LI>        <B>[MANDATORY]</B>  &lt;heat&gt; The heat percent to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the weapon heat percentage<BR><B>EXAMPLE:  </B>self SetWeaponHeatPercent( weapon, 0.0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetWeaponLockOnPercent(<I>&lt;weapon&gt;</I>,<I>&lt;heat&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon (player should have this weapon)<LI>        <B>[MANDATORY]</B>  &lt;heat&gt; The heat percent to set</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the weapon lockon completion percentage<BR><B>EXAMPLE:  </B>self SetWeaponLockOnPercent( weapon, 0.0 )<BR></OL><P>
<HR><H1>void &lt;player&gt; SetWeaponOverheating(<I>&lt;overheat&gt;</I>,<I>&lt;heatval&gt;</I>,<I>[weapon]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;overheat&gt; Whether the weapon is overheating.<LI>        <B>[MANDATORY]</B>  &lt;heatval&gt; The new heatval of the weapon (0 to 100).<LI>        <B>[OPTIONAL]</B>  [weapon] If present set this specific weapon otherwise set the player's current weapon.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the players Weapon Overheating value<BR><B>EXAMPLE:  </B>self SetWeaponOverheating( weapondata["overheat"], weapondata["heat"], weapon )<BR></OL><P>
<HR><H1>void &lt;player&gt; ShowViewModel()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Show the player's current view model.<BR><B>EXAMPLE:  </B>player ShowViewModel()<BR></OL><P>
<HR><H1>void &lt;player&gt; SortHeldWeapons()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sort the playerState heldWeapons to remove empty spaces<BR><B>EXAMPLE:  </B>e_player SortHeldWeapon()<BR></OL><P>
<HR><H1>void &lt;player&gt; SpawnSpectator(<I>&lt;origin&gt;</I>,<I>&lt;angles&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; origin to spawn<LI>        <B>[MANDATORY]</B>  &lt;angles&gt; angles to spawn</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Spawns the player, does not send any notifies<BR></OL><P>
<HR><H1>void &lt;player&gt; SprintButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the 'sprint' button.<BR><B>EXAMPLE:  </B>while( self SprintButtonPressed() )...<BR></OL><P>
<HR><H1>void &lt;player&gt; SprintUpRequired()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Force the player to release the sprint button before sprinting.<BR><B>EXAMPLE:  </B>self SprintUpRequired()<BR></OL><P>
<HR><H1>void &lt;player&gt; StanceButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the 'stance' button.<BR><B>EXAMPLE:  </B>while( self StanceButtonPressed() )...<BR></OL><P>
<HR><H1>void StartCameraTween(<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; How long to do the blend."</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Start a camera tween, call this right before a camera pop to do a blend.<BR><B>EXAMPLE:  </B>player StartCameraTween( 0.5 );<BR></OL><P>
<HR><H1>void &lt;player&gt; StartRevive(<I>&lt;reviver&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;reviver&gt; the player reviving the player this is called on</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Starts the revive sequence on a player. &lt;reviver&gt; is the one administering aid to the player this is called on.<BR><B>EXAMPLE:  </B>playerInLastStand StartRevive( rescuer )<BR></OL><P>
<HR><H1>void &lt;player&gt; StopCarryTurret(<I>&lt;turret&gt;</I>,<I>[origin]</I>,<I>[angles]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;turret&gt; turret entity<LI>        <B>[OPTIONAL]</B>  [origin] The new origin of turret<LI>        <B>[OPTIONAL]</B>  [angles] The new angles of turret</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>UnLinks the auto turret from the player and sets it on the ground.<BR><B>EXAMPLE:  </B>player StopCarryTurret( turret, origin, angles )<BR></OL><P>
<HR><H1>void &lt;player&gt; StopLocalSound(<I>&lt;sound name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;sound name&gt; The name of the sound</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stops the local sound<BR><B>EXAMPLE:  </B>targetent StopLocalSound( level.missileDroneSoundStart )<BR></OL><P>
<HR><H1>void &lt;player&gt; StopRevive(<I>&lt;reviver&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;reviver&gt; the player reviving the player this is called on</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stops the revive behavior on a player when the revive did not complete. &lt;reviver&gt; is the one administering aid to the player this is called on.<BR><B>EXAMPLE:  </B>playerInLastStand StopRevive( rescuer )<BR></OL><P>
<HR><H1>void &lt;player&gt; Suicide()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Kills the player immediately as a suicide<BR><B>EXAMPLE:  </B>self suicide()<BR></OL><P>
<HR><H1>void &lt;player&gt; SwitchToOffHand(<I>&lt;weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; Weapon to switch to</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Switch to the offhand weapon<BR><B>EXAMPLE:  </B>self SwitchToOffhand( primaryOffhand )<BR></OL><P>
<HR><H1>void &lt;player&gt; SwitchToWeapon(<I>[weapon object]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [weapon object] The weapon to switch to</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Switch to a different weapon or cycle weapons if no weapon is given<BR><B>EXAMPLE:  </B>level.player SwitchToWeapon( weapon )<BR></OL><P>
<HR><H1>void &lt;player&gt; SwitchToWeaponImmediate(<I>[weapon object]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [weapon object] The weapon to switch to</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Switch to a different weapon or cycle weapons if no weapon is given without playing the dropping animation for current weapon<BR><B>EXAMPLE:  </B>level.player SwitchToWeaponImmediate( weapon )<BR></OL><P>
<HR><H1>void &lt;player&gt; TakeAllWeapons()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Makes the player take all weapons<BR><B>EXAMPLE:  </B>player TakeAllWeapons()<BR></OL><P>
<HR><H1>void &lt;player&gt; TakeWeapon(<I>&lt;weapon&gt;</I>,<I>&lt;ignore_attachments&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon&gt; The weapon to take<LI>        <B>[OPTIONAL]</B>  &lt;ignore_attachments&gt; Only check the root weapon, ignore all the attachments.</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Take the weapon<BR><B>EXAMPLE:  </B>e_player TakeWeapon( w_spike_launcher )<BR></OL><P>
<HR><H1>void &lt;player&gt; ThrowButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the 'throw' button.<BR><B>EXAMPLE:  </B>while( self ThrowButtonPressed() )...<BR></OL><P>
<HR><H1>void &lt;client&gt; TurnedHuman()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Called when client is turned back to human<BR><B>EXAMPLE:  </B>self TurnedHuman()<BR></OL><P>
<HR><H1>void &lt;client&gt; UndoLastStand()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Undo the last stand for the client<BR><B>EXAMPLE:  </B>self UndoLastStand()<BR></OL><P>
<HR><H1>void &lt;player&gt; UnlinkFromMissile()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Unlinks a player camera from a missile<BR><B>EXAMPLE:  </B>player UnlinkFromMissile()<BR></OL><P>
<HR><H1>void &lt;player&gt; UnlinkGuidedMissileCamera()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>clear player eflags for the guided missile<BR><B>EXAMPLE:  </B>player UnlinkGuidedMissileCamera()<BR></OL><P>
<HR><H1>void &lt;player&gt; UnSetPerk(<I>&lt;perk name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;perk name&gt; the perk to unset</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>takes the specified perk from the player<BR><B>EXAMPLE:  </B>player UnSetPerk( "specialty_gpsjammer" )<BR></OL><P>
<HR><H1>void &lt;player&gt; UpdateWeaponOptions(<I>&lt;weapon name&gt;</I>,<I>[weapon options]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon name&gt; The weapon name to give to the player<LI>        <B>[OPTIONAL]</B>  [weapon options] options value computed using calcweaponoptions call</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Update weapon options for a weapon that the player has<BR><B>EXAMPLE:  </B>player UpdateWeaponOptions( "m1garand", player calcWeaponOptions() )<BR></OL><P>
<HR><H1>void &lt;player&gt; UseButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the use button<BR><B>EXAMPLE:  </B>if ( self UseButtonPressed() ) ...<BR></OL><P>
<HR><H1>void &lt;player&gt; VehicleMoveUpButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the 'stance' button.<BR><B>EXAMPLE:  </B>while( self StanceButtonPressed() )...<BR></OL><P>
<HR><H1>void &lt;player&gt; WeaponLockCount()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>returns the number of active lock objects (i.e. those with at least lock started or lock set active)<BR><B>EXAMPLE:  </B>player WeaponLockCount()<BR></OL><P>
<HR><H1>void &lt;player&gt; WeaponLockDetect(<I>&lt;entity&gt;</I>,<I>[slot]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt;: An entity.<LI>        <B>[OPTIONAL]</B>  [slot]:  The slot to operate on (up to MAX_SIMULTANEOUS_LOCKONS)</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the tartget as detected.  Will clear any existing hard lock.  Use WeaponLockStart() to start lock.<BR><B>EXAMPLE:  </B>player WeaponLockDetect( enemyGuy )<BR></OL><P>
<HR><H1>void &lt;player&gt; WeaponLockFinalize(<I>&lt;entity&gt;</I>,<I>[slot]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt;: An entity.<LI>        <B>[OPTIONAL]</B>  [slot]:  The slot to operate on (up to MAX_SIMULTANEOUS_LOCKONS)</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Locks player's weapon onto an entity.  Implies WeaponLockStart(), so this may be called to jump to a hard lock.<BR><B>EXAMPLE:  </B>player WeaponLockFinalize( enemyGuy )<BR></OL><P>
<HR><H1>void &lt;player&gt; WeaponLockFree(<I>[slot]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [slot] The weapon slot. Default is 0</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears player's weapon lock.<BR><B>EXAMPLE:  </B>player WeaponLockClear()<BR></OL><P>
<HR><H1>void &lt;player&gt; WeaponLockNoClearance(<I>&lt;bool&gt;</I>,<I>[slot]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;bool&gt;: true or false.<LI>        <B>[OPTIONAL]</B>  [slot] The weapon slot. Default is 0</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>When set true, the player will be unable to fire their lockon weapon, and will recieve a hint print telling them that there is an obstruction.<BR><B>EXAMPLE:  </B>player WeaponLockNoClearance( true )<BR></OL><P>
<HR><H1>void &lt;player&gt; WeaponLockRemoveSlot(<I>&lt;slot&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;slot&gt; The weapon slot. Default is 0</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>removes the given slot values and compresses the remaining slots  (i.e. 1,2,3 with 2 removed becomes 1,3,blank)<BR><B>EXAMPLE:  </B>player WeaponLockGetFlags()<BR></OL><P>
<HR><H1>void &lt;player&gt; WeaponLockStart(<I>&lt;entity&gt;</I>,<I>[slot]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt;: An entity.<LI>        <B>[OPTIONAL]</B>  [slot]:  The slot to operate on (up to MAX_SIMULTANEOUS_LOCKONS)</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Begins player's weapon lockon sequence (hud effects, etc).  Will clear any existing hard lock.  Use WeaponLockFinalize() to complete lock.<BR><B>EXAMPLE:  </B>player WeaponLockStart( enemyGuy )<BR></OL><P>
<HR><H1>void &lt;player&gt; WeaponLockTargetTooClose(<I>&lt;bool&gt;</I>,<I>[slot]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;bool&gt;: true or false.<LI>        <B>[OPTIONAL]</B>  [slot] The weapon slot. Default is 0</UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>When set true, the player will be unable to fire their lockon weapon, and will recieve a hint print telling them that they are too close.<BR><B>EXAMPLE:  </B>player WeaponLockTargetTooClose( true )<BR></OL><P>
<HR><H1>void &lt;player&gt; WeaponPlayEjectBrass()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Play the eject brass FX for a weapon.<BR><B>EXAMPLE:  </B>player WeaponPlayEjectBrass()<BR></OL><P>
<HR><H1>void &lt;player&gt; WeaponSwitchButtonPressed()</H1><OL><UL></UL><B>CATEGORY:  </B>Player<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Check if the player is pressing the weapon switch button<BR><B>EXAMPLE:  </B>if ( self WeaponSwitchButtonPressed() ) ...<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; ChangeFontScaleOverTime(<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; The time to scale the element font in seconds</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set a hud element to transition in fontScale over time.  Normally setting the fontScale of an element causes an immediate visual change. However, if the fontScale gets set within &lt;time&gt; after calling ChangeFontScaleOverTime, then the hud element will transition to the new fontScale over the remaining &lt;time&gt;.<BR><B>EXAMPLE:  </B>level.introstring1 ChangeFontScaleOverTime( 1.2 );  level.introstring1.fontScale = 0.3;  // This will transition the fontScale from whatever it was before to the new value of 0.3 over 1.2 seconds.<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; ClearTargetEnt()</H1><OL><UL></UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clear this waypoint from targetting an entity.<BR><B>EXAMPLE:  </B>waypoint ClearTargetEnt()<BR></OL><P>
<HR><H1>void CloseLUIMenu(<I>&lt;localClientNum&gt;</I>,<I>&lt;menuIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Number of the local client on the machine.<LI>        <B>[MANDATORY]</B>  &lt;menuIndex&gt; Menu ID received from CreateLUIMenu.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Close the LUI menu specified.<BR><B>EXAMPLE:  </B>CloseLUIMenu( localClientNum, menuIndex )<BR></OL><P>
<HR><H1>void CreateLUIMenu(<I>&lt;localClientNum&gt;</I>,<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Number of the local client on the machine.<LI>        <B>[MANDATORY]</B>  &lt;name&gt; Name of the menu to create.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Creates a LUI menu to be opened later with OpenLUIMenu.<BR><B>EXAMPLE:  </B>CreateLUIMenu( localClientNum, "ScriptDebugMenu")<BR></OL><P>
<HR><H1>void CreateUIModel(<I>&lt;parentModel&gt;</I>,<I>&lt;newPathName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;parentModel&gt; The parent model of the model to retrieve.<LI>        <B>[MANDATORY]</B>  &lt;newPathName&gt; The name/path of the new model to create.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Creates and returns a UIModel from a parent model.<BR><B>EXAMPLE:  </B>CreateUIModel( gameScoreModel, "enZemeyScore" )<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; Destroy()</H1><OL><UL></UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Remove this Hud element altogether.<BR><B>EXAMPLE:  </B>self.bombstopwatch Destroy()<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; FadeOverTime(<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; The time to fade the element in seconds</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set a hud element to transition in color (or alpha) over time.  Normally setting the color (or alpha) of an element causes an immediate visual change. However, if the color (or alpha) gets set within &lt;time&gt; after calling fadeOverTime, then the hud element will transition to the new color over the remaining &lt;time&gt;.<BR><B>EXAMPLE:  </B>level.introstring1 FadeOverTime( 1.2 );  level.introstring1.alpha = 0.3;  // This will transition the alpha from whatever it was before to the new value of 0.3 over 1.2 seconds.<BR></OL><P>
<HR><H1>void FreeUIModel(<I>&lt;modelToFree&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;modelToFree&gt; The model to free.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Frees a UIModel.<BR><B>EXAMPLE:  </B>FreeUIModel( gameScoreModel )<BR></OL><P>
<HR><H1>void GetGlobalUIModel()</H1><OL><UL></UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the gloabl UIModel.<BR><B>EXAMPLE:  </B>GetGlobalModel()<BR></OL><P>
<HR><H1>void GetLUIMenu(<I>&lt;localClientNum&gt;</I>,<I>&lt;menuName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Number of the local client on the machine.<LI>        <B>[MANDATORY]</B>  &lt;menuName&gt; Menu name</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Gets the first instance found of a given menu name active for the given client (undefined if not found)<BR><B>EXAMPLE:  </B>menuIndex = GetLUIMenu( localClientNum, "HudElementImage" )<BR></OL><P>
<HR><H1>void GetLUIMenuData(<I>&lt;localClientNum&gt;</I>,<I>&lt;menuIndex&gt;</I>,<I>&lt;menuDataName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Number of the local client on the machine.<LI>        <B>[MANDATORY]</B>  &lt;menuIndex&gt; Menu ID received from CreateLUIMenu.<LI>        <B>[MANDATORY]</B>  &lt;menuDataName&gt; Menu Data Name linked to the UIModel.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Gets data from a LUI menu.<BR><B>EXAMPLE:  </B>modelValue = GetLUIMenuData( localClientNum, menuIndex, "title" )<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; GetTextWidth()</H1><OL><UL></UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returned the width of the text in the hudelem.<BR><B>EXAMPLE:  </B>width = elem GetTextWidth()<BR></OL><P>
<HR><H1>void GetUIModel(<I>&lt;parentModel&gt;</I>,<I>&lt;lookupModelName&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;parentModel&gt; The parent model of the model to retrieve.<LI>        <B>[MANDATORY]</B>  &lt;lookupModelName&gt; The name of the model to retrieve.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns a UIModel from the parent model passed in and the name of the model to retrieve.<BR><B>EXAMPLE:  </B>GetUIModel( gameScoreModel, "enemeyScore" )<BR></OL><P>
<HR><H1>void GetUIModelForController(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Number of the local client on the machine.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the UIModel from the controller root.<BR><B>EXAMPLE:  </B>GetUIModelForController( localClientNum )<BR></OL><P>
<HR><H1>void GetUIModelValue(<I>&lt;model&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;model&gt; Model of the value to retrieve.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the value of the UIModel passed in.<BR><B>EXAMPLE:  </B>GetUIModelValue( gameScoreModel )<BR></OL><P>
<HR><H1>void IsLuiEnabled()</H1><OL><UL></UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>true if lui system has the input focus<BR><B>EXAMPLE:  </B>if( IsLuiEnabled() )<BR></OL><P>
<HR><H1>void LuiDisable(<I>&lt;localclientnum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localclientnum&gt; The local client</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>user input is removed from lui system<BR><B>EXAMPLE:  </B>LuiDisable( 0 )<BR></OL><P>
<HR><H1>void LuiEnable(<I>&lt;localclientnum&gt;</I>,<I>&lt;menuname&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localclientnum&gt; The local client<LI>        <B>[MANDATORY]</B>  &lt;menuname&gt; The name of the menu to enable</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>user input is handed to lui system until returned<BR><B>EXAMPLE:  </B>LuiEnable("overlay")<BR></OL><P>
<HR><H1>void LuiLoad()</H1><OL><UL></UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Loads a lui file, making the menus available for addition<BR><B>EXAMPLE:  </B>LuiLoad("overlay")<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; MoveOverTime(<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; The time to move the element in seconds</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set a hud element to move over time.<BR><B>EXAMPLE:  </B>newStr MoveOverTime( timer )<BR></OL><P>
<HR><H1>hudelem NewClientHudElem(<I>&lt;client&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;client&gt; The client for whom the hud element is created.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Create a new hud element for a particular client<BR><B>EXAMPLE:  </B>self.kc_topbar = NewClientHudElem(self)<BR></OL><P>
<HR><H1>hudelem NewDamageIndicatorHudElem(<I>&lt;client&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;client&gt; The client for whom the hud element is created.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Create a new hud element for a particular client<BR><B>EXAMPLE:  </B>self.kc_topbar = NewClientHudElem(self)<BR></OL><P>
<HR><H1>hudelem NewDebugHudElem()</H1><OL><UL></UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR></OL><P>
<HR><H1>hudelem NewHudElem()</H1><OL><UL></UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Create a new hud element<BR><B>EXAMPLE:  </B>overlay = NewHudElem()<BR></OL><P>
<HR><H1>hudelem NewScoreHudElem(<I>&lt;client&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;client&gt; The client for whom the hud element is created.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Create a new score hud element for a particular client<BR><B>EXAMPLE:  </B>self.hud_rankscroreupdate = NewScoreHudElem(self)<BR></OL><P>
<HR><H1>hudelem NewTeamHudElem(<I>&lt;team&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;team&gt; The team for whom the hud element is created. Must be 'axis', 'allies' or 'spectator'</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Create a new hud element for a particular team<BR><B>EXAMPLE:  </B>level.progressbar_allies_neutralize = NewTeamHudElem( "axis" )<BR></OL><P>
<HR><H1>void OpenLUIMenu(<I>&lt;localClientNum&gt;</I>,<I>&lt;menuIndex&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Number of the local client on the machine.<LI>        <B>[MANDATORY]</B>  &lt;menuIndex&gt; Menu ID received from CreateLUIMenu.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Opens a loaded LUI menu.<BR><B>EXAMPLE:  </B>OpenLUIMenu( localClientNum, menuIndex )<BR></OL><P>
<HR><H1>void OpenLUIPopup(<I>&lt;localClientNum&gt;</I>,<I>&lt;name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Number of the local client on the machine.<LI>        <B>[MANDATORY]</B>  &lt;name&gt; Name of the popup menu to open.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Opens a loaded LUI menu.<BR><B>EXAMPLE:  </B>OpenLUIPopup( localClientNum, "SomePopup")<BR></OL><P>
<HR><H1>void PopulateScriptDebugMenu(<I>&lt;localClientNum&gt;</I>,<I>&lt;array&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Number of the local client on the machine.<LI>        <B>[MANDATORY]</B>  &lt;array&gt; Array of menu item names for the debug menu.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets a UIModel from the model being passed in.<BR><B>EXAMPLE:  </B>PopulateScriptDebugMenu( localClientNum, menu_items_array )<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; Reset()</H1><OL><UL></UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Reset a HUD element to its default state.<BR><B>EXAMPLE:  </B>element Reset()<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; ScaleOverTime(<I>&lt;time&gt;</I>,<I>&lt;width&gt;</I>,<I>&lt;height&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; The time to scale the element in seconds<LI>        <B>[MANDATORY]</B>  &lt;width&gt; The new width of the material.<LI>        <B>[MANDATORY]</B>  &lt;height&gt; The new height of the material.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set a hud element to scale over time.<BR><B>EXAMPLE:  </B>other.progressbar ScaleOverTime( level.planttime, level.barsize, 8 )<BR></OL><P>
<HR><H1>void &lt;hud_clock_element&gt; SetClock(<I>&lt;time&gt;</I>,<I>&lt;time&gt;</I>,<I>&lt;material&gt;</I>,<I>[width]</I>,<I>[height]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; The new timer time in seconds to count down<LI>        <B>[MANDATORY]</B>  &lt;time&gt; The time in seconds represented by a full cycle of the hand, for instance a stopwatch would be 60s.<LI>        <B>[MANDATORY]</B>  &lt;material&gt; The material for the hud clock<LI>        <B>[OPTIONAL]</B>  [width] The width of the material.<LI>        <B>[OPTIONAL]</B>  [height] The height of the material.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set a clock HUD element to count down over a time period.<BR><B>EXAMPLE:  </B>level.bombstopwatch SetClock( 5, 60, "hudStopwatch", 64, 64 )<BR></OL><P>
<HR><H1>void &lt;hud_clock_element&gt; SetClockUp(<I>&lt;time&gt;</I>,<I>&lt;full time&gt;</I>,<I>&lt;material&gt;</I>,<I>[width]</I>,<I>[height]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; The new timer time in seconds to count up<LI>        <B>[MANDATORY]</B>  &lt;full time&gt; The time in seconds represented by a full cycle of the hand, for instance a stopwatch would be 60s.<LI>        <B>[MANDATORY]</B>  &lt;material&gt; The material for the hud clock<LI>        <B>[OPTIONAL]</B>  [width] The width of the material.<LI>        <B>[OPTIONAL]</B>  [height] The height of the material.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set a clock HUD element to count up over a time period.<BR><B>EXAMPLE:  </B>level.bombstopwatch SetClockUp( 5, 60, "hudStopwatch", 64, 64 )<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; SetCOD7DecodeFX(<I>&lt;decodeTime&gt;</I>,<I>&lt;decayStart&gt;</I>,<I>&lt;decayDuration&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;decodeTime&gt; Time for each letter to decode.<LI>        <B>[MANDATORY]</B>  &lt;decayStart&gt; Time to wait before starting the text decay effect.<LI>        <B>[MANDATORY]</B>  &lt;decayDuration&gt; How long to spend decaying.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the hudelem string to display with a decode effect.<BR><B>EXAMPLE:  </B>elem SetCOD7DecodeFX( 2000, 600 )<BR></OL><P>
<HR><H1>void SetExtraCamRenderReady(<I>&lt;jobIdx&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;jobIdx&gt; Extra Cam Render job index.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets an extra cam render job to start processing<BR><B>EXAMPLE:  </B>StartExtraCamRender( 2 )<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; SetGameTypeString(<I>&lt;game type&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;game type&gt; A string containing the game type</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the game type string for the game<BR></OL><P>
<HR><H1>void SetLUIMenuData(<I>&lt;localClientNum&gt;</I>,<I>&lt;menuIndex&gt;</I>,<I>&lt;menuDataName&gt;</I>,<I>&lt;menuDataValue&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; Number of the local client on the machine.<LI>        <B>[MANDATORY]</B>  &lt;menuIndex&gt; Menu ID received from CreateLUIMenu.<LI>        <B>[MANDATORY]</B>  &lt;menuDataName&gt; Menu Data Name linked to the UIModel.<LI>        <B>[MANDATORY]</B>  &lt;menuDataValue&gt; Value for that piece of menu data.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Set data for LUI menu.<BR><B>EXAMPLE:  </B>SetLUIMenuData( localClientNum, menuIndex, "title", "Some Title" )<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; SetMapNameString(<I>&lt;map name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;map name&gt; A string containing the map name</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the map name string<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; SetPerks(<I>&lt;client&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;client&gt; client we should be showing the perks of</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets a hud element to be a perks element.<BR><B>EXAMPLE:  </B>hudelement SetPerks( true )<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; SetPlayerNameString(<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; A player entity</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the player name string for a HUD element<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; SetPulseFX(<I>&lt;speed&gt;</I>,<I>&lt;decayStart&gt;</I>,<I>&lt;decayDuration&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;speed&gt; Time (in milliseconds) each letter takes to type out.<LI>        <B>[MANDATORY]</B>  &lt;decayStart&gt; Time to wait before starting the string's decay effect.<LI>        <B>[MANDATORY]</B>  &lt;decayDuration&gt; How long to spend decaying.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the hudelem string to display with a "Pulse" effect.<BR><B>EXAMPLE:  </B>elem SetPulseFX( 40, 2000, 600 )<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; SetRedactFX(<I>&lt;decayStart&gt;</I>,<I>&lt;decayDuration&gt;</I>,<I>&lt;redactDecayStart&gt;</I>,<I>&lt;redactDecayDuration&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;decayStart&gt; Time to wait before starting the text decay effect.<LI>        <B>[MANDATORY]</B>  &lt;decayDuration&gt; How long to spend decaying.<LI>        <B>[MANDATORY]</B>  &lt;redactDecayStart&gt; Time to wait before starting the redact decay effect.<LI>        <B>[MANDATORY]</B>  &lt;redactDecayDuration&gt; How long to spend decaying.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the hudelem string to display with a redact effect.<BR><B>EXAMPLE:  </B>elem SetRedactFX( 2000, 600, 3000, 400 )<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; SetShader(<I>&lt;materialname&gt;</I>,<I>[width]</I>,<I>[height]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;materialname&gt; A the name of the material to set<LI>        <B>[OPTIONAL]</B>  [width] The width of the material.<LI>        <B>[OPTIONAL]</B>  [height] The height of the material.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the material for this Hud Element<BR><B>EXAMPLE:  </B>waypoint SetShader( "playbook_objective_stop", 15, 15 )<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; SetTargetEnt(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; Entity to Target</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the entity that this waypoint should target.  In MP, entity should already be a broadcasting entity, as with Objective_OnEntity().<BR><B>EXAMPLE:  </B>waypoint SetTargetEnt( level.axis.bombcarrier )<BR></OL><P>
<HR><H1>void &lt;hud_timer_element&gt; SetTenthsTimer(<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; The new timer time</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set a timer HUD element to count down in tenths of a second<BR><B>EXAMPLE:  </B>self.kc_timer SetTenthsTimer( self.archivetime - delay )<BR></OL><P>
<HR><H1>void &lt;hud_timer_element&gt; SetTenthsTimerUp(<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; The new timer time</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set a timer HUD element to count up in tenths of a second<BR><B>EXAMPLE:  </B>self.kc_timer SetTenthsTimerUp( self.archivetime - delay )<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; SetText(<I>&lt;text&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;text&gt; A localized text reference</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set HUD text for this element.<BR><B>EXAMPLE:  </B>level.introstring1 SetText(string1)<BR></OL><P>
<HR><H1>void &lt;hud_timer_element&gt; SetTimer(<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; The new timer time</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set a timer HUD element to count down<BR><B>EXAMPLE:  </B>level.reinforcement_hud SetTimer( level.counter )<BR></OL><P>
<HR><H1>void &lt;hud_timer_element&gt; SetTimerUp(<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; The new timer time</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set a timer HUD element to count up<BR><B>EXAMPLE:  </B>level.reinforcement_hud SetTimerUp( level.counter )<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; SetTypewriterFX(<I>&lt;letterTime&gt;</I>,<I>&lt;decayStart&gt;</I>,<I>&lt;decayDuration&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;letterTime&gt; Time it take for each letter to type in.<LI>        <B>[MANDATORY]</B>  &lt;decayStart&gt; Time to wait before starting the text decay effect.<LI>        <B>[MANDATORY]</B>  &lt;decayDuration&gt; How long to spend decaying.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the hudelem string to display with a redact effect.<BR><B>EXAMPLE:  </B>elem SetTypewriterFX( 100, 600, 3000 )<BR></OL><P>
<HR><H1>void SetUIModelValue(<I>&lt;model&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;model&gt; Model of the value to set.<LI>        <B>[MANDATORY]</B>  &lt;value&gt; Value to set.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Sets a UIModel from the model being passed in.<BR><B>EXAMPLE:  </B>SetUIModelValue( gameScoreModel )<BR></OL><P>
<HR><H1>void &lt;hud_value_element&gt; SetValue(<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;value&gt; The value to set the element to</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set a value HUD element to a given value.<BR><B>EXAMPLE:  </B>level.reinforcement_hud SetValue( 0 )<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; SetWarGameData(<I>&lt;momentumProgress&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;momentumProgress&gt;, &lt;momentumMultiplier&gt;, &lt;momentumBlitzkriegTime&gt;</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Creates a WAR specific HUD progress element<BR><B>EXAMPLE:  </B>hudelement SetWarGameData( 0, 1, 30 )<BR></OL><P>
<HR><H1>void &lt;hud_element&gt; SetWayPoint(<I>&lt;constantSize&gt;</I>,<I>[offscreenMaterialName]</I>,<I>[isDistanceShown]</I>,<I>[no offscreen]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;constantSize&gt; boolean describing whether the hud element remains the same size<LI>        <B>[OPTIONAL]</B>  [offscreenMaterialName] Material to draw when waypoint is offscreen.<LI>        <B>[OPTIONAL]</B>  [isDistanceShown] boolean turning on/off player distance to waypoint display above the waypoint.<LI>        <B>[OPTIONAL]</B>  [no offscreen] boolean turning on/off arrow indicators when element is offscreen.</UL><B>CATEGORY:  </B>UI<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets a hud element to be a waypoint.<BR><B>EXAMPLE:  </B>newdeathicon SetWayPoint( true )<BR></OL><P>
<HR><H1>void array(<I>&lt;args&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;args&gt; one or more args to add to the array</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>create an array<BR></OL><P>
<HR><H1>void ArrayCombine(<I>&lt;array1&gt;</I>,<I>&lt;array2&gt;</I>,<I>&lt;allowdupes&gt;</I>,<I>&lt;preserve_keys&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;array1&gt; array to operate on<LI>        <B>[MANDATORY]</B>  &lt;array2&gt; array to operate on<LI>        <B>[MANDATORY]</B>  &lt;allowdupes&gt; if true then allow duplicate entries, otherwise prune them out when combining<LI>        <B>[MANDATORY]</B>  &lt;preserve_keys&gt; if true then preserve the keys (only for string keys) otherwise renumber when combining</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>combine two arrays into and returns one new array<BR></OL><P>
<HR><H1>void ArrayCopy(<I>&lt;array1&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;array1&gt; array to operate on</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>returns a copy of an array<BR></OL><P>
<HR><H1>void ArrayGetClosest(<I>&lt;origin&gt;</I>,<I>&lt;array&gt;</I>,<I>[dist]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The origin to get closest from<LI>        <B>[MANDATORY]</B>  &lt;array&gt; The array to search in<LI>        <B>[OPTIONAL]</B>  [dist] The minimum distance to check when finding closest (has to be positive)</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the entity/vector that is closest to the &lt;origin&gt; from the &lt;array&gt;.<BR><B>EXAMPLE:  </B>ent = ArrayGetClosest( player.origin, a_enemies )<BR></OL><P>
<HR><H1>void ArrayGetFarthest(<I>&lt;origin&gt;</I>,<I>&lt;array&gt;</I>,<I>[dist]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The origin to get farthest from<LI>        <B>[MANDATORY]</B>  &lt;array&gt; The array to search in<LI>        <B>[OPTIONAL]</B>  [dist] The maximum distance when finding farthest (has to be positive)</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the entity/vector that is farthest to the &lt;origin&gt; from the &lt;array&gt;.<BR><B>EXAMPLE:  </B>ent = ArrayGetFarthest( player.origin, a_enemies )<BR></OL><P>
<HR><H1>void ArrayInsert(<I>&lt;array&gt;</I>,<I>&lt;value&gt;</I>,<I>&lt;index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;array&gt; array to operate on<LI>        <B>[MANDATORY]</B>  &lt;value&gt; value to insert<LI>        <B>[MANDATORY]</B>  &lt;index&gt; index at which to insert the value (must be an integer) - moves existing entries as required</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>insert a value into an array at a given index<BR></OL><P>
<HR><H1>void ArrayIntersect(<I>&lt;array1&gt;</I>,<I>&lt;array2&gt;</I>,<I>[matchKeys]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;array1&gt; An Array<LI>        <B>[MANDATORY]</B>  &lt;array2&gt; An Array<LI>        <B>[OPTIONAL]</B>  [matchKeys] Optionally returns an array of matching key/value pairs from the two input arrays (preserving the keys).</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns an array of values that are present in both arrays.<BR><B>EXAMPLE:  </B>newArray = ArrayIntersect( array1, array2 )<BR></OL><P>
<HR><H1>void ArrayRemoveIndex(<I>&lt;array&gt;</I>,<I>&lt;index&gt;</I>,<I>[preserve_keys]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;array&gt; array to operate on<LI>        <B>[MANDATORY]</B>  &lt;index&gt; index of value to remove<LI>        <B>[OPTIONAL]</B>  [preserve_keys] defaults to false, if true then it preserves the keys - otherwise creates integer keys</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Remove a value from an array at a given index<BR></OL><P>
<HR><H1>void ArrayRemoveValue(<I>&lt;array&gt;</I>,<I>&lt;value&gt;</I>,<I>[preserve_keys]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;array&gt; array to operate on<LI>        <B>[MANDATORY]</B>  &lt;value&gt; value to remove (may be undefined)<LI>        <B>[OPTIONAL]</B>  [preserve_keys] defaults to false, if true then it preserves the keys - otherwise creates integer keys</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Remove a value from an array (may affect multiple indexes)<BR></OL><P>
<HR><H1>void Assert(<I>&lt;value&gt;</I>,<I>[desc]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;value&gt; statement that is asserted to be correct<LI>        <B>[OPTIONAL]</B>  [desc] string describing the nature of the assert</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Assert that the given statement is correct. The function will throw a script error if this is false.<BR><B>EXAMPLE:  </B>Assert( enemyInSight == true )<BR></OL><P>
<HR><H1>void AssertMsg(<I>&lt;message&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;message&gt; error message</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Throws a script error with the given message.<BR><B>EXAMPLE:  </B>AssertMsg( "Unhandled enemy type." )<BR></OL><P>
<HR><H1>void associativeArray(<I>&lt;key_i&gt;</I>,<I>&lt;value_i&gt;</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  &lt;key_i&gt; the string key for the next value<LI>        <B>[OPTIONAL]</B>  &lt;value_i&gt; the value for the previous key</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>creates an associativeArray<BR></OL><P>
<HR><H1>void ClientHasSnapshot(<I>&lt;local client&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;local client&gt; the desired Local Client number.</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if client has recieved a snapshot from the server<BR></OL><P>
<HR><H1>void ErrorMsg(<I>&lt;message&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;message&gt; error message</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Throws a non-fatal script error with the given message.<BR><B>EXAMPLE:  </B>ErrorMsg( "Unhandled enemy type." )<BR></OL><P>
<HR><H1>void GetArrayKeys(<I>&lt;array&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;array&gt; Input array</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns an array consisting of the keys of the input array.<BR><B>EXAMPLE:  </B>result = GetArrayKeys( array )<BR></OL><P>
<HR><H1>void GetAttachmentTableIndex(<I>&lt;attachmentRef&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;attachmentRef&gt; Attachment Reference</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the attachment table index for the attachment name<BR><B>EXAMPLE:  </B>attachmentIndex = GetAttachmentTableIndex( "reflex" )<BR></OL><P>
<HR><H1>void GetDvarFloat(<I>&lt;dvar&gt;</I>,<I>[default_value]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;dvar&gt; The dvar name as a string or hash.<LI>        <B>[OPTIONAL]</B>  [default_value] The value to be returned if the dvar doesn't exist, must be an float.</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Gets the value of a dvar.<BR><B>EXAMPLE:  </B>GetDvarFloat( "r_eyesAdjust", 1.0 )<BR></OL><P>
<HR><H1>void GetDvarInt(<I>&lt;dvar&gt;</I>,<I>[default_value]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;dvar&gt; The dvar name as a string or hash.<LI>        <B>[OPTIONAL]</B>  [default_value] The value to be returned if the dvar doesn't exist, must be an integer.</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Gets the value of a dvar.<BR><B>EXAMPLE:  </B>GetDvarInt( "r_eyesAdjust", 1 )<BR></OL><P>
<HR><H1>void GetDvarString(<I>&lt;dvar&gt;</I>,<I>[default_value]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;dvar&gt; The dvar name as a string or hash.<LI>        <B>[OPTIONAL]</B>  [default_value] The value to be returned if the dvar doesn't exist, must be a string.</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Gets the value of a dvar.<BR><B>EXAMPLE:  </B>GetDvarString( "r_eyesAdjust", "yes" )<BR></OL><P>
<HR><H1>void GetDvarVector(<I>&lt;dvar&gt;</I>,<I>[default_value]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;dvar&gt; The dvar name as a string or hash.<LI>        <B>[OPTIONAL]</B>  [default_value] The value to be returned if the dvar doesn't exist, must be an vector.</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Gets the value of a dvar.<BR><B>EXAMPLE:  </B>GetDvarVector( "r_eyesAdjust", (1,0,0) )<BR></OL><P>
<HR><H1>void GetFirstArrayKey(<I>&lt;array&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;array&gt; Input array</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the first key of the input array.<BR><B>EXAMPLE:  </B>key = GetFirstArrayKey( array )<BR></OL><P>
<HR><H1>void GetItemIndexFromRef(<I>&lt;itemRef&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;itemRef&gt; Item Reference</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the item index for the specified item reference<BR><B>EXAMPLE:  </B>itemIndex = GetItemIndexFromRef( &lt;itemRef&gt; )<BR></OL><P>
<HR><H1>void GetLastArrayKey(<I>&lt;array&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;array&gt; Input array</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the last key of the input array.<BR><B>EXAMPLE:  </B>key = GetLastArrayKey( array )<BR></OL><P>
<HR><H1>void GetMapCenter()</H1><OL><UL></UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the map center<BR><B>EXAMPLE:  </B>center = GetMapCenter()<BR></OL><P>
<HR><H1>void GetNextArrayKey(<I>&lt;array&gt;</I>,<I>&lt;key&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;array&gt; Input array<LI>        <B>[MANDATORY]</B>  &lt;key&gt; The given key</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the next key of the input array, after the specified key.<BR><B>EXAMPLE:  </B>key = GetNextArrayKey( array, key )<BR></OL><P>
<HR><H1>void GetPrevArrayKey(<I>&lt;array&gt;</I>,<I>&lt;key&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;array&gt; Input array<LI>        <B>[MANDATORY]</B>  &lt;key&gt; The given key</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the prev key of the input array, before the specified key.<BR><B>EXAMPLE:  </B>key = GetPrevArrayKey( array, key )<BR></OL><P>
<HR><H1>void GetServerTime(<I>&lt;localClientNum&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;localClientNum&gt; The local client</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the time according to the server<BR><B>EXAMPLE:  </B>GetServerTime(localClientNum)<BR></OL><P>
<HR><H1>void GetSubStr(<I>&lt;string&gt;</I>,<I>&lt;start index&gt;</I>,<I>[end index]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string&gt; The input string<LI>        <B>[MANDATORY]</B>  &lt;start index&gt; The start index of the substring<LI>        <B>[OPTIONAL]</B>  [end index] The end index of the substring</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns the substring of characters &gt;= &lt;start index&gt; and &lt; &lt;end index&gt;. &lt;end index&gt; is optional.<BR><B>EXAMPLE:  </B>name = getSubStr( playerwarp_string, 8 )<BR></OL><P>
<HR><H1>void GetSystemTime(<I>[ignore timezone]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [ignore timezone] Set to non-zero to ignore the timezone information</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns the time of the system in a vector where the 0 index is hours (in 24hr time), 1 is minutes, and 2 is seconds<BR><B>EXAMPLE:  </B>GetSystemTime(1)<BR></OL><P>
<HR><H1>void IsArray(<I>&lt;variable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;variable&gt; variable that may or may not be a array</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Checks whether this entity/variable is an array<BR><B>EXAMPLE:  </B>if ( isarray ( gun_owner )) ... <BR></OL><P>
<HR><H1>void IsClass(<I>&lt;variable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;variable&gt; variable that may or may not be a class</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Checks whether this entity/variable is a class object<BR><B>EXAMPLE:  </B>if ( isclass(self)) ... <BR></OL><P>
<HR><H1>void IsFloat(<I>&lt;variable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;variable&gt; variable that may or may not be a float</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Checks whether this entity/variable is a float<BR><B>EXAMPLE:  </B>if ( IsFloat( gun_owner ) ) ...<BR></OL><P>
<HR><H1>void IsFunctionPtr(<I>&lt;variable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;variable&gt; variable to test</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Checks whether given variable is of type Function Pointer in script, useful to differentiate between Var and FuncPtr in Script.<BR><B>EXAMPLE:  </B>if ( IsFunctionPtr( myFuncPtr ) ) ...<BR></OL><P>
<HR><H1>void IsInArray(<I>&lt;array&gt;</I>,<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;array&gt; array to search<LI>        <B>[MANDATORY]</B>  &lt;value&gt; value to search for</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>searches an array to determine if a given value is present in that array<BR></OL><P>
<HR><H1>void IsInt(<I>&lt;variable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;variable&gt; variable that may or may not be an int</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Checks whether this entity/variable is an int<BR><B>EXAMPLE:  </B>if ( IsInt( gun_owner ) ) ...<BR></OL><P>
<HR><H1>void IsMatureContentEnabled()</H1><OL><UL></UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if mature content is enabled<BR><B>EXAMPLE:  </B>if( IsMatureContentEnabled() )<BR></OL><P>
<HR><H1>void IsShowBloodEnabled()</H1><OL><UL></UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if blood is enabled<BR><B>EXAMPLE:  </B>if( IsShowBloodEnabled() )<BR></OL><P>
<HR><H1>void IsShowGibsEnabled()</H1><OL><UL></UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Returns true if gibs is enabled<BR><B>EXAMPLE:  </B>if( IsShowGibsEnabled() )<BR></OL><P>
<HR><H1>void IsString(<I>&lt;variable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;variable&gt; variable that may or may not be a string</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Checks whether this entity/variable is a string<BR><B>EXAMPLE:  </B>if ( isstring ( gun_owner )) ... <BR></OL><P>
<HR><H1>void IsStruct(<I>&lt;variable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;variable&gt; variable that may or may not be a struct</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Checks whether this variable is a struct object<BR><B>EXAMPLE:  </B>if ( isstruct(self)) ... <BR></OL><P>
<HR><H1>void IsSubStr()</H1><OL><UL></UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns true/false if &lt;substring&gt; is a substring of &lt;string&gt;. Case sensitive.<BR><B>EXAMPLE:  </B>has_str = IsSubStr( "my_string", "str" )<BR></OL><P>
<HR><H1>void istring(<I>&lt;value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;value&gt; A string to cast to an istring</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Casts a string to an istring<BR><B>EXAMPLE:  </B>x = istring( String )<BR></OL><P>
<HR><H1>void IsVec(<I>&lt;variable&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;variable&gt; variable that may or may not be a vector</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Checks whether this entity/variable is a vector<BR><B>EXAMPLE:  </B>if ( IsVec( gun_owner ) ) ...<BR></OL><P>
<HR><H1>void IsWeapon(<I>&lt;weapon_object&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon_object&gt; An parameter that may be a weapon object</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Checks whether this is a weapon object<BR><B>EXAMPLE:  </B>if ( IsWeapon( current_weapon ) ) ...<BR></OL><P>
<HR><H1>void MakeLocalizedString(<I>&lt;string&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string&gt; The string to translate</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Make a localized string of the given string<BR></OL><P>
<HR><H1>void SplitArgs(<I>&lt;arg string&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;arg string&gt; space seperated string.</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Client<BR><B>SUMMARY:  </B>Splits a space seperated string, returning an array of each word in the string.<BR><B>EXAMPLE:  </B>args = SplitArgs("First second third fourth")<BR></OL><P>
<HR><H1>void sprintf(<I>&lt;string&gt;</I>,<I>[args]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string&gt; The string to translate<LI>        <B>[OPTIONAL]</B>  [args] zero or more arguments</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Replaces field specifiers in a string with values passed in, returns result string format specifiers take the form of {[n]} in the source string where [n] indicates which value to print, e.g. 0 is the first user arg<BR><B>EXAMPLE:  </B>sprintf("{0} is the first string","first")<BR></OL><P>
<HR><H1>void StrEndsWith(<I>&lt;string&gt;</I>,<I>&lt;substring&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string&gt; String to search<LI>        <B>[MANDATORY]</B>  &lt;substring&gt; Substring to search with.</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns true/false if &lt;string&gt; ends with &lt;substring&gt;. Case sensitive.<BR><B>EXAMPLE:  </B>ends_with = StrEndsWith( "my_string", "_string" )<BR></OL><P>
<HR><H1>void StrIsFloat(<I>&lt;string&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string&gt; : The string to check.</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Check if a string is a float.<BR><B>EXAMPLE:  </B>StrIsFloat( "1.2" ); // true<BR></OL><P>
<HR><H1>void StrIsInt(<I>&lt;string&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string&gt; : The string to check.</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Check if a string is an int.<BR><B>EXAMPLE:  </B>StrIsInt( "1" ); // true<BR></OL><P>
<HR><H1>void StrIsNumber(<I>&lt;string&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string&gt; : The string to check.</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Check if a string is a number.<BR><B>EXAMPLE:  </B>StrIsNumber( "1.2" ); // true<BR></OL><P>
<HR><H1>void StrStartsWith(<I>&lt;string&gt;</I>,<I>&lt;substring&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string&gt; String to search<LI>        <B>[MANDATORY]</B>  &lt;substring&gt; Substring to search with.</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Returns true/false if &lt;string&gt; starts with &lt;substring&gt;. Case sensitive.<BR><B>EXAMPLE:  </B>starts_with = StrStartsWith( "my_string", "my_" )<BR></OL><P>
<HR><H1>void StrStrip(<I>&lt;string&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string&gt; : The string to strip.</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Strip whitespace from right and left side of string.<BR><B>EXAMPLE:  </B>StrStrip( "    hq_cleared   " ); // 'hq_cleared'<BR></OL><P>
<HR><H1>void StrTok(<I>&lt;string&gt;</I>,<I>&lt;delim&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string&gt; The input string<LI>        <B>[MANDATORY]</B>  &lt;delim&gt; The delimiter to tokenize by</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Tokenizes &lt;string&gt; by the delimiters &lt;delim&gt;. Returns the array of string tokens.<BR><B>EXAMPLE:  </B>my_string_array = StrTok( "my_string; my_string_2", "; " )<BR></OL><P>
<HR><H1>void StrTok2(<I>&lt;string&gt;</I>,<I>&lt;delim&gt;</I>,<I>&lt;case_sensitive&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string&gt; The input string<LI>        <B>[MANDATORY]</B>  &lt;delim&gt; The delimiter to tokenize by<LI>        <B>[OPTIONAL]</B>  &lt;case_sensitive&gt; true if test is case sensitive</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Tokenizes &lt;string&gt; by a single delimiter string.  doesn't treat the delimiter string as a series of characters, but as a string<BR><B>EXAMPLE:  </B>my_string_array = StrTok2( "my_string foo; my_string_2", "foo; " )<BR></OL><P>
<HR><H1>void TableLookup(<I>&lt;filename&gt;</I>,<I>&lt;search column num&gt;</I>,<I>&lt;search value&gt;</I>,<I>&lt;return value column num&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;filename&gt; The table to look up<LI>        <B>[MANDATORY]</B>  &lt;search column num&gt; The column number of the stats table to search through<LI>        <B>[MANDATORY]</B>  &lt;search value&gt; The value to use when searching the &lt;search column num&gt;<LI>        <B>[MANDATORY]</B>  &lt;return value column num&gt; The column number value to return after we find the correct row</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>look up a row in a table and pull out a particular column from that row<BR><B>EXAMPLE:  </B>TableLookup( "mp/statstable.csv", 0, "INDEX_KILLS", 1 )<BR></OL><P>
<HR><H1>void TableLookupColumnCount(<I>&lt;filename&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;filename&gt; The table to look up</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>look up the number of columns in a table<BR><B>EXAMPLE:  </B>TableLookup( "mp/statstable.csv" )<BR></OL><P>
<HR><H1>void TableLookupColumnForRow(<I>&lt;filename&gt;</I>,<I>&lt;search row num&gt;</I>,<I>&lt;search column num&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;filename&gt; The table to look up<LI>        <B>[MANDATORY]</B>  &lt;search row num&gt; The row number of the string table to search through<LI>        <B>[MANDATORY]</B>  &lt;search column num&gt; The column number of the string table to search through</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>look up a particular row and column in a table<BR><B>EXAMPLE:  </B>TableLookupColumnForRow( "gamedata/tables/mp/exampleStringTable.csv", 101, 7 )<BR></OL><P>
<HR><H1>void TableLookupFindCoreAsset(<I>&lt;filename&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;filename&gt; The table to look up</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Find core asset index for a stringtable<BR><B>EXAMPLE:  </B>TableLookupRowNum( "mp/statstable.csv" )<BR></OL><P>
<HR><H1>void TableLookupIString(<I>&lt;filename&gt;</I>,<I>&lt;search column num&gt;</I>,<I>&lt;search value&gt;</I>,<I>&lt;return value column num&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;filename&gt; The table to look up<LI>        <B>[MANDATORY]</B>  &lt;search column num&gt; The column number of the stats table to search through<LI>        <B>[MANDATORY]</B>  &lt;search value&gt; The value to use when searching the &lt;search column num&gt;<LI>        <B>[MANDATORY]</B>  &lt;return value column num&gt; The column number value to return after we find the correct row</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>look up a row in a table and pull out a particular column from that row<BR><B>EXAMPLE:  </B>TableLookupIString( "mp/statstable.csv", 0, "INDEX_KILLS", 1 )<BR></OL><P>
<HR><H1>void TableLookupRow(<I>&lt;filename&gt;</I>,<I>&lt;row num&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;filename&gt; The table to look up<LI>        <B>[MANDATORY]</B>  &lt;row num&gt; The row num of the row in table to return</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Return an array of strings for the columns in that row<BR></OL><P>
<HR><H1>void TableLookupRowCount(<I>&lt;filename&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;filename&gt; The table to look up</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>look up the number of rows in a table<BR><B>EXAMPLE:  </B>TableLookup( "mp/statstable.csv" )<BR></OL><P>
<HR><H1>void TableLookupRowNum(<I>&lt;filename&gt;</I>,<I>&lt;search column num&gt;</I>,<I>&lt;search value&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;filename&gt; The table to look up<LI>        <B>[MANDATORY]</B>  &lt;search column num&gt; The column number of the stats table to search through<LI>        <B>[MANDATORY]</B>  &lt;search value&gt; The value to use when searching the &lt;search column num&gt;</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>look up a row number in a table<BR><B>EXAMPLE:  </B>TableLookupRowNum( "mp/statstable.csv", 0, "INDEX_KILLS" )<BR></OL><P>
<HR><H1>void Throw()</H1><OL><UL></UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>force a script exception (from a builtin call)<BR><B>EXAMPLE:  </B>throw( )<BR></OL><P>
<HR><H1>void ToLower(<I>&lt;string&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string&gt; (string) Base string</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Converts &lt;string&gt; to a lower case string which is returned.<BR><B>EXAMPLE:  </B>my_string = ToLower( "MY_STRING" )<BR></OL><P>
<HR><H1>void ToUpper(<I>&lt;string&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;string&gt; (string) Base string</UL><B>CATEGORY:  </B>Utility<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Converts &lt;string&gt; to a upper case string which is returned.<BR><B>EXAMPLE:  </B>my_string = ToUpper( "lower" )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; AttachPath(<I>&lt;node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt; A node on the path to attach.</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Attaches this vehicle to the given path.<BR><B>EXAMPLE:  </B>bomber AttachPath( aBomberPaths[i] )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; CancelAIMove()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Tell the vehicle to stop moving towards its current goal position.<BR><B>EXAMPLE:  </B>eTank CancelAIMove()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; ClearDefaultPitch()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears the desired default pitch for a vehicle.<BR><B>EXAMPLE:  </B>level.heli cleardefaultpitch()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; ClearGoalYaw()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clear the goal yaw direction for this vehicle.<BR><B>EXAMPLE:  </B>level.flak1 ClearGoalYaw()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; ClearGunnerTarget(<I>[gunner index]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [gunner index] Which gun, 0-3.</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clear the target for the vehicle turret.<BR><B>EXAMPLE:  </B>eTank ClearGunnerTarget(0)<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; ClearLookAtEnt()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clear the entity or origin the vehicle is orienting towards.<BR><B>EXAMPLE:  </B>heli clearLookAtEnt()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; ClearTargetYaw()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clear the target yaw direction for this vehicle.<BR><B>EXAMPLE:  </B>level.flak1 cleartargetyaw()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; ClearTurretTarget(<I>[turret index]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [turret index] 0 for turret, 1-4 for gunners</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clear the target for the vehicle turret.<BR><B>EXAMPLE:  </B>eTank ClearTurretTarget()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; ClearVehGoalPos()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears the target position for this vehicle.<BR><B>EXAMPLE:  </B>tank ClearVehGoalPos()<BR></OL><P>
<HR><H1>void CreateTrack(<I>&lt;node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node&gt;</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the node enabled or disabled for vehicle pathfinding.  SetVehGoalPos will now return true or false if it can find a path.<BR><B>EXAMPLE:  </B>CreateTrack( track_node )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; DisableDriverFiring()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enables or disables the driver's vehicle turret<BR><B>EXAMPLE:  </B>tank DisableDriverFiring( true )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; DisableGunnerFiring(<I>&lt;gunner index&gt;</I>,<I>&lt;onoff&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;gunner index&gt; The gunner to disable/enable<LI>        <B>[MANDATORY]</B>  &lt;onoff&gt; true to disable, false otherwise</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enable or disable gunner firing<BR><B>EXAMPLE:  </B>tank DisableGunnerFiring( 1, true )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; DrawTrajectory(<I>&lt;show&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;show&gt; Whether to draw trajectory or not</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Draws the vehicles trajectory.<BR><B>EXAMPLE:  </B>plane DrawTrajectory( true )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; DrivePath(<I>[node index]</I>,<I>[allow free drive]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [node index] A node on the path to attach.<LI>        <B>[OPTIONAL]</B>  [allow free drive] This give the player free driving but script notifies when passing nodes on a vehcile spline</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Starts the vehicle driving this path and uses the vehicle physics, not locked to the spline, can only achieve turns that the physics can handle.<BR><B>EXAMPLE:  </B>huey DrivePath( start_node )<BR></OL><P>
<HR><H1>entity &lt;vehicle&gt; FinishVehicleDamage(<I>&lt;Inflictor&gt;</I>,<I>&lt;Attacker&gt;</I>,<I>&lt;Damage&gt;</I>,<I>&lt;Damage Flags&gt;</I>,<I>&lt;Means Of Death&gt;</I>,<I>&lt;Weapon&gt;</I>,<I>&lt;Point&gt;</I>,<I>&lt;Direction&gt;</I>,<I>&lt;Hit Loc&gt;</I>,<I>&lt;Offset Time&gt;</I>,<I>&lt;DamageFromUnderneath&gt;</I>,<I>&lt;modelIndex&gt;</I>,<I>&lt;partIndex&gt;</I>,<I>&lt;damageteammates&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;Inflictor&gt; The entity that causes the damage.(e.g. a turret)<LI>        <B>[MANDATORY]</B>  &lt;Attacker&gt; The entity that is attacking.<LI>        <B>[MANDATORY]</B>  &lt;Damage&gt; Integer specifying the amount of damage done<LI>        <B>[MANDATORY]</B>  &lt;Damage Flags&gt; Integer specifying flags that are to be applied to the damage<LI>        <B>[MANDATORY]</B>  &lt;Means Of Death&gt; Integer specifying the method of death<LI>        <B>[MANDATORY]</B>  &lt;Weapon&gt; The weapon number of the weapon used to inflict the damage<LI>        <B>[MANDATORY]</B>  &lt;Point&gt; Point of damage<LI>        <B>[MANDATORY]</B>  &lt;Direction&gt; (vector) The direction of the damage<LI>        <B>[MANDATORY]</B>  &lt;Hit Loc&gt; The location of the hit<LI>        <B>[MANDATORY]</B>  &lt;Offset Time&gt; The time offset for the damage<LI>        <B>[MANDATORY]</B>  &lt;DamageFromUnderneath&gt; If the hit is underneath the vehicle<LI>        <B>[MANDATORY]</B>  &lt;modelIndex&gt; which model in the dobj was hit<LI>        <B>[MANDATORY]</B>  &lt;partIndex&gt; which bone was hit<LI>        <B>[MANDATORY]</B>  &lt;damageteammates&gt; Whether to damage teammates or not</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Does damage to an vehicle - usually as part of the damage callback<BR><B>EXAMPLE:  </B>self FinishVehicleDamage( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, sWeapon, vPoint, vDir, sHitLoc, psOffsetTime, damageUnderneathVehicle, modelindex, partname, damageteammates )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; FinishVehicleRadiusDamage(<I>&lt;Inflictor&gt;</I>,<I>&lt;Attacker&gt;</I>,<I>&lt;Damage&gt;</I>,<I>&lt;Inner Damage&gt;</I>,<I>&lt;Outer Damage&gt;</I>,<I>&lt;Damage Flags&gt;</I>,<I>&lt;Means Of Death&gt;</I>,<I>&lt;Weapon&gt;</I>,<I>&lt;Point&gt;</I>,<I>&lt;Radius&gt;</I>,<I>&lt;ConeRadius&gt;</I>,<I>&lt;ConeDirection&gt;</I>,<I>&lt;Offset Time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;Inflictor&gt; The entity that causes the damage.(e.g. a turret)<LI>        <B>[MANDATORY]</B>  &lt;Attacker&gt; The entity that is attacking.<LI>        <B>[MANDATORY]</B>  &lt;Damage&gt; Integer specifying the amount of damage done<LI>        <B>[MANDATORY]</B>  &lt;Inner Damage&gt; Integer specifying the amount of inner damage done<LI>        <B>[MANDATORY]</B>  &lt;Outer Damage&gt; Integer specifying the amount of outer damage done<LI>        <B>[MANDATORY]</B>  &lt;Damage Flags&gt; Integer specifying flags that are to be applied to the damage<LI>        <B>[MANDATORY]</B>  &lt;Means Of Death&gt; Integer specifying the method of death<LI>        <B>[MANDATORY]</B>  &lt;Weapon&gt; The weapon number of the weapon used to inflict the damage<LI>        <B>[MANDATORY]</B>  &lt;Point&gt; (vector) The Point of the damage<LI>        <B>[MANDATORY]</B>  &lt;Radius&gt; (float) The radius of the damage<LI>        <B>[MANDATORY]</B>  &lt;ConeRadius&gt; (float) The radius of the cone damage<LI>        <B>[MANDATORY]</B>  &lt;ConeDirection&gt; (vector) The direction of the cone damage<LI>        <B>[MANDATORY]</B>  &lt;Offset Time&gt; The time offset for the damage</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Does damage to an vehicle - usually as part of the damage callback<BR><B>EXAMPLE:  </B>self FinishVehicleRadiusDamage( eInflictor, eAttacker, iDamage, iDFlags, sMeansOfDeath, sWeapon, vPoint, fRadius, fConeRadius, fConeDir, psOffsetTime )<BR></OL><P>
<HR><H1>entity &lt;vehicle&gt; FireWeapon(<I>[turret_index]</I>,<I>[target ent]</I>,<I>[target offset]</I>,<I>[attacker]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [turret_index]			turret index, 0 being main turret, 1~4 being gunners<LI>        <B>[OPTIONAL]</B>  [target ent]		A target entity for guided missiles<LI>        <B>[OPTIONAL]</B>  [target offset]	Only used for projectile and bomb weapons<LI>        <B>[OPTIONAL]</B>  [attacker]		real attacker who should take credit of this shot</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Fire the vehicle's weapon<BR><B>EXAMPLE:  </B>m_vehicle FireWeapon( 0, m_e_target, v_target_offset )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; Flip180()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Flips this vehicle 180 (for going forwards / backwards along a path)<BR><B>EXAMPLE:  </B>huey Flip180()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; FreeVehicle()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Frees this vehicle instance.  It will unlink any players occupying the vehicle. It will change the vehicle into a vehicle corpse.  It will send a death notify on the vehicle.  Once called the vehicle cannot move anymore.<BR><B>EXAMPLE:  </B>self FreeVehicle()<BR></OL><P>
<HR><H1>void GetAllVehicleNodes()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets all of the vehicle nodes in a level<BR><B>EXAMPLE:  </B>nodes = GetAllVehicleNodes()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetAngularVelocity()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the current angular velocity.<BR><B>EXAMPLE:  </B>self GetAngularVelocity()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetAttachPos(<I>&lt;node index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node index&gt; A node on the path to attach.</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the origin and angles if the vehicle were to be attached to the path.  The origin and angles are returned as a vector array of size 2.  Origin is 1st and angles is 2nd.<BR><B>EXAMPLE:  </B>pos = self GetAttachPos( node )origin = pos[0]angles = pos[1]<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetBrake()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the brake value of a nitrous physics vehicle.<BR><B>EXAMPLE:  </B>jeep getbrake()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetDefaultAcceleration()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the acceleration value set in GDT.<BR><B>EXAMPLE:  </B>accel = self GetDefaultAcceleration()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; getgoalspeedMPH()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the goal speed in miles per hour.<BR><B>EXAMPLE:  </B>self GetGoalSpeedMPH()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetGoalYaw()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the goal yaw direction for this vehicle. Goal yaw is ignored if vehicle doesn't stop at goal. Lookat entity has priority over goal yaw<BR><B>EXAMPLE:  </B>level.flak1 GetGoalYaw()<BR></OL><P>
<HR><H1>entity &lt;vehicle&gt; GetGunnerTargetEnt(<I>&lt;gunner index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;gunner index&gt; Which gun, 0-3.</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the target entity for this gunner position.<BR><B>EXAMPLE:  </B>target = huey GetGunnerTurretEnt( 0 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetGunnerTargetVec(<I>&lt;gunner index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;gunner index&gt; which gun 0-3</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the target position for this vehicle turret gunner.<BR><B>EXAMPLE:  </B>endpt = GetGunnerTargetVec( 1 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetHandBrake()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the hand brake value of a nitrous physics vehicle.<BR><B>EXAMPLE:  </B>jeep gethandbrake()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetHeliHeightLock()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Locks the heli to the height mesh<BR><B>EXAMPLE:  </B>if ( vehicle GetHeliHeightLock( ) )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetHeliHeightLockHeight(<I>&lt;point&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;point&gt; The point to check at</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the mesh height at a given point.<BR><B>EXAMPLE:  </B>maxheight = GetHeliHeightLockHeight( point )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetMaxSpeed(<I>[get gdt]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [get gdt]  true to get the gdt setting and not the script set.</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the max speed of a vehicle. By default gets the script setting<BR><B>EXAMPLE:  </B>heli GetMaxSpeed( true )<BR></OL><P>
<HR><H1>void GetNumVehicles()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the number of vehicles entities in the level<BR><B>EXAMPLE:  </B>vehicleCount = GetNumVehicles()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetOccupantSeat(<I>&lt;player&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;player&gt; The player to get the seat index for</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the seat index occupied by the given player.  -1 if player isn't in vehicle.<BR><B>EXAMPLE:  </B>isDriver = 0 == vehicle GetOccupantSeat( player )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetPathFixedOffset()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets a fixed offset from the path for a specific vehicle.<BR><B>EXAMPLE:  </B>offset = huey GetPathFixedOffset()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetPathVariableOffset()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets a variable offset from the path for a specific vehicle.<BR><B>EXAMPLE:  </B>offset = huey GetPathVariableOffset()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetPhysAcceleration()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the vehicles acceleration vector.<BR><B>EXAMPLE:  </B>accel = plane GetPhysAccel()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetScriptBrake()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the script brake value of a nitrous physics vehicle.<BR><B>EXAMPLE:  </B>jeep getscriptbrake()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetSeatFiringAngles(<I>&lt;seat index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;seat index&gt; The seat to firing angles for</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Retrieve the angles specifying the direction in which bullets, projectiles, etc. will be emitted from the weapon when it is fired.<BR><B>EXAMPLE:  </B>turretBarrelAngles = tank GetSeatFiringAngles( 0 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetSeatFiringOrigin(<I>&lt;seat index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;seat index&gt; The seat to firing origin for</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Retrieve the location at the end of the barrel where bullets, projectiles, etc. are emitted when the gun is fired.<BR><B>EXAMPLE:  </B>turretBarrelOrigin = tank GetSeatFiringOrigin( 0 )<BR></OL><P>
<HR><H1>entity &lt;vehicle&gt; GetSeatOccupant(<I>&lt;seat&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;seat&gt; 0 driver, 1-4 gunners, 5-10 passengers</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the entity occupying the given seat index.  Undefined if the seat is empty.<BR><B>EXAMPLE:  </B>driver = vehicle GetSeatOccupant( 0 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetSpeed()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the current speed in inches per second.<BR><B>EXAMPLE:  </B>self GetSpeed()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetSpeedMPH()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the current speed in miles per hour.<BR><B>EXAMPLE:  </B>self GetSpeedMPH()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetSteering()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the steer factor of the vehicle.<BR><B>EXAMPLE:  </B>self GetSteering()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetThrottle()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the throttle factor of the vehicle.<BR><B>EXAMPLE:  </B>self GetThrottle()<BR></OL><P>
<HR><H1>void GetTimeFromVehicleNodeToNode(<I>&lt;start_node&gt;</I>,<I>&lt;end_node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;start_node&gt; The start node of the path<LI>        <B>[MANDATORY]</B>  &lt;end_node&gt; The end node of the path</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>The time it would take to go from start node to end node if traveling the spline speed.<BR><B>EXAMPLE:  </B>time = GetTimeFromVehicleNodeToNode( start_node, end_node )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetTurretHeatValue(<I>&lt;gunner index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;gunner index&gt;  which gun 0-3</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the current heat value for a vehicle weapon.<BR><B>EXAMPLE:  </B>heat = self GetTurretHeatValue( 1 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetTurretLimitsYaw(<I>[turret index]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [turret index] 0 for turret, 1-4 for gunners</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the furthest relative yaw angles the turret can aim, all numbers are positive<BR><B>EXAMPLE:  </B>limit = veh GetTurretLimits( 1 ); limitMin = -limit[0]; limitMax = limit[1]<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetTurretTargetVec(<I>[turret index]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [turret index] 0 for turret, 1-4 for gunners</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the target position for this vehicle turret or gunner.<BR><B>EXAMPLE:  </B>endpt = GetTurretTargetVec( 1 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetVehDamageMultiplier(<I>&lt;damageType&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;damageType&gt; The type of damage being applied to the vehicle</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets the damage multiplier that applies to the damage type.<BR><B>EXAMPLE:  </B>vehicle GetVehDamageMultiplier( damgType )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetVehicleAvoidance()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Locks the heli to the height mesh<BR><B>EXAMPLE:  </B>if ( vehicle GetVehicleAvoidance() )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetVehicleAvoidanceNodes(<I>&lt;radius&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;radius&gt; A radius to filter out nodes returned.</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the positions for nearby avoidance nodes.<BR><B>EXAMPLE:  </B>nodes = plane GetVehicleAvoidanceNodes( radius )<BR></OL><P>
<HR><H1>void GetVehicleNode(<I>&lt;name&gt;</I>,<I>&lt;key&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; (string) The name to search for<LI>        <B>[MANDATORY]</B>  &lt;key&gt; (string) The key that name goes with</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets a vehicle node with the given name, key pair<BR><B>EXAMPLE:  </B>node = getvehiclenode(self.target, "targetname")<BR></OL><P>
<HR><H1>void GetVehicleNodeArray(<I>&lt;name&gt;</I>,<I>&lt;key&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;name&gt; (string) The name to search for<LI>        <B>[MANDATORY]</B>  &lt;key&gt; (string) The key that name goes with</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Gets an array of vehicle nodes that have the given name, key pair<BR><B>EXAMPLE:  </B>nodes = GetVehicleNodeArray(self.target, "targetname")<BR></OL><P>
<HR><H1>entity &lt;vehicle&gt; GetVehicleOwner()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the owner of this particular vehicle.<BR><B>EXAMPLE:  </B>eFlak88user = eFlak88 GetVehicleOwner()<BR></OL><P>
<HR><H1>entity &lt;vehicle&gt; GetVehOccupants()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Get the occupants of this vehicle in an entity array.<BR><B>EXAMPLE:  </B>ridersarray = vehicle getvehoccupants()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; GetWheelSurface(<I>&lt;wheel&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;wheel&gt; The wheel position, can be 'front_left', 'front_right', 'back_left', 'back_right', 'middle_left', 'middle_right'</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the surface type of the given wheel as a string.<BR><B>EXAMPLE:  </B>surface = self GetWheelSurface( side )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; IsDriverFiring()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks if this driver is firing the vehicle turret<BR><B>EXAMPLE:  </B>if( tank IsDriverFiring() )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; IsGunnerFiring(<I>&lt;gunner index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;gunner index&gt; The gunner to check</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Checks if this gun is currently firing.<BR><B>EXAMPLE:  </B>if( tank IsGunnerFiring( 1 ) )<BR></OL><P>
<HR><H1>void IsInsideHeliHeightLock()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if Helicopter is inside height mesh<BR><B>EXAMPLE:  </B>if ( IsInsideHeliHeightLock() )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; isremotecontrol()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Query whether this vehicle is usable by players<BR><B>EXAMPLE:  </B>if ( vehicle isvehicleusable(  ) )...<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; IsTurretReady()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Query whether this vehicle's turret is ready for firing<BR><B>EXAMPLE:  </B>while ( level.playertank IsTurretReady() != true ) ...<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; IsVehicleImmuneToDamage(<I>&lt;Damage Flags&gt;</I>,<I>&lt;Means Of Death&gt;</I>,<I>&lt;Weapon&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;Damage Flags&gt; Integer specifying flags that are to be applied to the damage<LI>        <B>[MANDATORY]</B>  &lt;Means Of Death&gt; Integer specifying the method of death<LI>        <B>[MANDATORY]</B>  &lt;Weapon&gt; The weapon number of the weapon used to inflict the damage</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>This checks the vehicle GDT settings related to bulletdamage, grenadedamage, etc.<BR><B>EXAMPLE:  </B>if ( vehicle IsVehicleImmuneToDamage( flags, mod, weapon ) )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; IsVehicleManualControl()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>check if vehicle hkai behavior is enabled. Not to be confused with UseVehicle()<BR><B>EXAMPLE:  </B>vehicle IsVehicleManualControl()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; IsVehicleSeatOccupied(<I>&lt;seat&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;seat&gt; 0 driver, 1-4 gunners, 5-10 passengers</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>same as useby except you can specify a seat, 0 driver, 1-4 gunners, 5-10 passengers<BR><B>EXAMPLE:  </B>lvt IsVehicleSeatOccupied( 2 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; IsVehicleTurretOverheating(<I>&lt;gunner index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;gunner index&gt;  which gun 0-3</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns true if the vehicle turret weapon is overheating, else returns false.<BR><B>EXAMPLE:  </B>if( self IsVehicleTurretOverheating( 1 ) )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; IsVehicleUsable()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Query whether this vehicle is usable by players<BR><B>EXAMPLE:  </B>if ( vehicle isvehicleusable(  ) )...<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; JoltBody(<I>&lt;jolt position&gt;</I>,<I>&lt;intensity&gt;</I>,<I>[speedFrac]</I>,<I>[deceleration]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;jolt position&gt; The position of the jolt<LI>        <B>[MANDATORY]</B>  &lt;intensity&gt; The intensity of the jolt<LI>        <B>[OPTIONAL]</B>  [speedFrac] A speed fraction to apply to the jolt. Most be betweeon 0 and 1.<LI>        <B>[OPTIONAL]</B>  [deceleration] The deceleration to apply to this vehicle in miles per hour per second.</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Jolts the vehicle.<BR><B>EXAMPLE:  </B>self JoltBody( (self.origin + (0,0,64)), 0.5 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; MakeVehicleUnusable()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets this vehicle to be not usable by the player<BR><B>EXAMPLE:  </B>car MakeVehicleUnusable()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; MakeVehicleUsable()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets this vehicle to be usable by the player<BR><B>EXAMPLE:  </B>nFlak makeVehicleUsable()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; PathFixedOffset(<I>&lt;offset&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;offset&gt; The offset to apply. A vector in the form (forward, right, up)</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets a fixed offset for this vehicle to travel on a vehicle path.<BR><B>EXAMPLE:  </B>huey PathFixedOffset( (0, -200, 0) )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; PathFixedOffsetClear()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears the vehicles fixed offset.<BR><B>EXAMPLE:  </B>huey PathFixedOffsetClear()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; PathMove(<I>&lt;node index&gt;</I>,<I>&lt;new origin&gt;</I>,<I>&lt;new angles&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;node index&gt; Which node to move to the new location (it moves the whole path not just this node).<LI>        <B>[MANDATORY]</B>  &lt;new origin&gt; The new position<LI>        <B>[MANDATORY]</B>  &lt;new angles&gt; The new angles</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Moves the entire path for this vehicle to the specific origin and angles.<BR><B>EXAMPLE:  </B>huey PathMove( node, origin, angles )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; PathMoveClear()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears the moved path for this vehicle.  If not cleared then all paths taken will be moved.<BR><B>EXAMPLE:  </B>huey PathMoveClear()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; PathVariableOffset(<I>&lt;offset&gt;</I>,<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;offset&gt; The offset to apply. A vector in the form (forward, right, up)<LI>        <B>[MANDATORY]</B>  &lt;time&gt;, The interval at which to choose new offsets</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets a variable offset for this vehicle to travel on a vehicle path.<BR><B>EXAMPLE:  </B>huey PathVariableOffset( (0, 50, 0), 2 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; PathVariableOffsetClear()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Clears the vehicles variable offset.<BR><B>EXAMPLE:  </B>huey PathVariableOffsetClear()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; RecalcSplinePaths()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Recalcs all the nodes int the map<BR><B>EXAMPLE:  </B>tank2 RecalcSplinePaths()<BR></OL><P>
<HR><H1>void ReconnectVehicleNodes()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Reconnect vehicle nodes<BR><B>EXAMPLE:  </B>ReconnectVehicleNodes()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; ResetVehicleFromDropDeploy()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Reset vehicle properties from drop deploy so that it may behave as normal.<BR><B>EXAMPLE:  </B>raps ResetVehicleFromDropDeploy()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; ResumeSpeed(<I>[acceleration]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [acceleration] The acceleration to apply to this vehicle in miles per hour per second.</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the vehicle to resume its path speed.<BR><B>EXAMPLE:  </B>level.tank ResumeSpeed( 3 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; ReturnPlayerControl()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>After controlling a vehicle from script using something like setvehgoalpos(), if the vehicle is being driven by a player, you call this function to return control of the vehicle to the player.<BR><B>EXAMPLE:  </B>cobra returnplayercontrol()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SeatGetWeapon(<I>&lt;seat index&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;seat index&gt; The seat to get weapon for</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Returns the weapon name for the specified seat.  Undefined if there isn't a weapon. Only driver and gunner seats can have weapons.<BR><B>EXAMPLE:  </B>weaponname = vehicle SeatGetWeapon( 0 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetAcceleration(<I>&lt;acceleration&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;acceleration&gt; The acceleration of the vehicle in miles per hour per second</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the acceleration for this vehicle.<BR><B>EXAMPLE:  </B>self SetAcceleration( 15 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetAirResistance(<I>&lt;max air resistance speed&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;max air resistance speed&gt; speed at which air resistance maxes out (MPH)</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the speed at which air resistance maxes out.<BR><B>EXAMPLE:  </B>self SetAirResistance( 60 )<BR><B>NOTES:  </B>Air resistance ramps up exponentially up to this speed. Set it to a high value to flatten helicopter when it is done accelerating to move at the desired speed<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetAngularVelocity(<I>&lt;angular velocity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;angular velocity&gt; The angular velocity to set</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the angular velocity of a vehicle in degs/s.<BR><B>EXAMPLE:  </B>self SetAngularVelocity( (0, 90, 0) )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetBrake(<I>&lt;bool&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;bool&gt;  True or 1 to turn on the brake, false or 0 otherwise</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Turns off/on the hand brake of a nitrous physics vehicle.<BR><B>EXAMPLE:  </B>jeep setbrake(1)<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetBuoyancyOffset(<I>&lt;offset&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;offset&gt; A height offset from water surface.</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>set buoyancy offset that changes the height an individual vehicle floats in water<BR><B>EXAMPLE:  </B>crocodile SetBuoyancyOffset( 20 )<BR></OL><P>
<HR><H1>void SetDamageStage(<I>&lt;stage&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;stage&gt; the damage stage to set</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the damage stage of the helicopter<BR><B>EXAMPLE:  </B>self setdamagestage( 3 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetDeceleration(<I>&lt;deceleration&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;deceleration&gt; The deceleration of the vehicle in miles per hour per second</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the deceleration for this vehicle.<BR><B>EXAMPLE:  </B>self SetDeceleration( 5 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetDefaultPitch(<I>&lt;pitch&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;pitch&gt; Set the default pitch</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the desired default pitch for a vehicle.<BR><B>EXAMPLE:  </B>level.heli setdefaultpitch(10)<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetDrivePathPhysicsScale(<I>[scale]</I>)</H1><OL><UL><LI>        <B>[OPTIONAL]</B>  [scale] The scale to set</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>This scales all of the necessary parameters that will help a vehicle drive a path better.<BR><B>EXAMPLE:  </B>boat SetDrivePathPhysicsScale( 3.0 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetGoalYaw(<I>&lt;integer&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;integer&gt; The yaw direction of the target: 0 to 360 integer value</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the goal yaw direction for this vehicle. Goal yaw is ignored if vehicle doesn't stop at goal. Lookat entity has priority over goal yaw<BR><B>EXAMPLE:  </B>level.flak1 SetGoalYaw( int_value )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetGunnerTargetEnt(<I>&lt;target entity&gt;</I>,<I>[target offset]</I>,<I>[gunner index]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target entity&gt; The target.<LI>        <B>[OPTIONAL]</B>  [target offset] The target offset.<LI>        <B>[OPTIONAL]</B>  [gunner index] Which gun, 0-3.</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the target entity for this vehicle gunner.<BR><B>EXAMPLE:  </B>eLiberator SetGunnerTargetEnt( eFlaktarget, (0,0,0), 2 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetGunnerTargetVec(<I>&lt;target position&gt;</I>,<I>[gunner index]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target position&gt; vecter to aim at/ the position of the target<LI>        <B>[OPTIONAL]</B>  [gunner index] which gun 0-3</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the target position for this vehicle turret gunner.<BR><B>EXAMPLE:  </B>level.flak1 SetGunnerTargetVec( vec1, 1 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetGunnerTurretOnTargetRange(<I>&lt;gunner index&gt;</I>,<I>[range]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;gunner index&gt; Which gun, 0-3.<LI>        <B>[OPTIONAL]</B>  [range] In degrees</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the range at which the gunner_turret_on_target notify will occur.<BR><B>EXAMPLE:  </B>boat SetGunnerTurretOnTargetRange( 0, 15 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetHeliDogfighting(<I>&lt;enabled&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;enabled&gt; true to enable dogfighting, false otherwise</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the vehicle (intended for VTOLs only) to be in dogfighting mode (dogfights with the vehicle's focus entity)<BR><B>EXAMPLE:  </B>vehicle SetHeliDogfighting( true )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetHeliHeightCap(<I>&lt;enabled&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;enabled&gt; true to enable, false otherwise</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Pulls the heli back down below the height mesh<BR><B>EXAMPLE:  </B>vehicle SetHeliHeightCap( true )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetHeliHeightLock(<I>&lt;enabled&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;enabled&gt; true to enable lock, false otherwise</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Locks the heli to the height mesh<BR><B>EXAMPLE:  </B>vehicle SetHeliHeightLock( true )<BR></OL><P>
<HR><H1>void SetHeliHeightPatchEnabled(<I>&lt;targetname&gt;</I>,<I>&lt;enabled&gt;</I>,<I>[player]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;targetname&gt; All heli height lock patches with this target name<LI>        <B>[MANDATORY]</B>  &lt;enabled&gt; Turn it on or off<LI>        <B>[OPTIONAL]</B>  [player] If defined, only modify the setting for that player</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enabled or disables the specified heli height lock path<BR><B>EXAMPLE:  </B>SetHeliHeightPatchEnabled( "area51", 0 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetHoverParams(<I>&lt;radius&gt;</I>,<I>[speed]</I>,<I>[accel]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;radius&gt; The hovering range.<LI>        <B>[OPTIONAL]</B>  [speed] Speed to hover at (MPH)<LI>        <B>[OPTIONAL]</B>  [accel] Acceleration to hover at (MPH/s)</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the hovering parameters.<BR><B>EXAMPLE:  </B>self SetHoverParams( 50, 1, 0.5 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetJitterParams(<I>&lt;range vector&gt;</I>,<I>[min period]</I>,<I>[max period]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;range vector&gt; The jitter range vector.<LI>        <B>[OPTIONAL]</B>  [min period] Minimum time in seconds to switch jitter direction. Default 0.5 sec<LI>        <B>[OPTIONAL]</B>  [max period] Maximum time in seconds to switch jitter direction. Default 1.0 sec</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the jitter parameters. Set everything to 0 to stop jittering. Vehicle ignores jitter parameters when on ground<BR><B>EXAMPLE:  </B>self SetJitterParams( (0,0,20), 0.5, 1.5 ); // Jitter up or down randomly within 20 units, switching every 0.5 to 1.5 seconds<BR><B>NOTES:  </B>For player helicopters, the jitter params are used for jittering the pitch and roll of the helicopter<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetLookAtEnt(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The target.</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the entity this vehicle will orient towards.<BR><B>EXAMPLE:  </B>eFlak88 setLookAtEnt( eFlaktarget )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetLookAtOrigin(<I>&lt;entity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The target.</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the origin this vehicle will orient towards.<BR><B>EXAMPLE:  </B>heli setLookAtOrigin( org )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetMantleEnabled(<I>&lt;enabled&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;enabled&gt; True to set the mantle enabled, false otherwise</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the mantle enabled flag on the vehicle<BR><B>EXAMPLE:  </B>vehicle SetMantleEnabled( true )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetMaxAccelerationScale(<I>&lt;scale&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;scale&gt; The acceleration scale of the physics vehicle</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the max acceleration scale for this physics vehicle.<BR><B>EXAMPLE:  </B>self SetMaxAccelerationScale( 2.6 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetMaxPitchRoll(<I>&lt;pitch&gt;</I>,<I>&lt;roll&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;pitch&gt; Max pitch angle<LI>        <B>[MANDATORY]</B>  &lt;roll&gt; Max roll angle</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets max pitch and roll angle for this vehicle.<BR><B>EXAMPLE:  </B>self SetMaxPitchRoll( 30, 30 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetMaxSpeedScale(<I>&lt;scale&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;scale&gt; The max speed scale of the physics vehicle</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the max speed scale for this physics vehicle.<BR><B>EXAMPLE:  </B>self SetMaxSpeedScale( 2.6 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetMinDesiredTurnYaw(<I>&lt;yaw&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;yaw&gt; The min desired turn yaw to set</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>The vehicle will not update its desired yaw until the min turn yaw is reached. Set it to 0 to clear it.<BR><B>EXAMPLE:  </B>quadtank SetMinDesiredTurnYaw( 45 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetNearGoalNotifyDist(<I>&lt;dist&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;dist&gt; Distance to goal position</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set distance near goal at which near_goal notification should be sent once.<BR><B>EXAMPLE:  </B>tank setNearGoalNotifyDist( 50 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetPathTransitionTime(<I>&lt;time&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;time&gt; The transition time</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the time it takes for a vehicle to lerp on to a spline.<BR><B>EXAMPLE:  </B>boat SetPathTransitionTime( 1.0 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetPhysAcceleration(<I>&lt;acceleration&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;acceleration&gt; The vehicle acceleration</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the vehicles acceleration vector.<BR><B>EXAMPLE:  </B>plane SetPhysAcceleration( ( 0, 0, -1600) )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetPhysAngles(<I>&lt;angles vector&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;angles vector&gt; The desired angles.</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the angles on the phys structure<BR><B>EXAMPLE:  </B>self SetPhysAngles( VectorToAngles( desired_forward ) )<BR></OL><P>
<HR><H1>void &lt;plane&gt; SetPlaneBarrelRoll(<I>&lt;number&gt;</I>,<I>[time]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;number&gt; The number of rolls<LI>        <B>[OPTIONAL]</B>  [time] The goal roll time</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the goal Roll direction for this plane. PLANE_ON_CURVE has priority over ROLL if this is not set.<BR><B>EXAMPLE:  </B>level.plane SetPlaneBarrelRoll( 1, 5.0f )<BR></OL><P>
<HR><H1>void &lt;plane&gt; SetPlaneGoalPos(<I>&lt;goal position&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;goal position&gt; The goal position</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the target position, speed, angles for this vehicle.<BR><B>EXAMPLE:  </B>plane Setplanegoalpos( ( 200, 200, 200 ), ( 30, 0, 90 ), 170.0 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetRotorSpeed(<I>&lt;speed&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;speed&gt; The rotor speed, 0 is stopped 1 is full speed.</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the helicopters rotor speed.<BR><B>EXAMPLE:  </B>heli SetRotorSpeed( 0.2 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetSeatOccupied(<I>&lt;seat&gt;</I>,<I>[onoff]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;seat&gt; 0 driver, 1-4 gunners, 5-10 passengers<LI>        <B>[OPTIONAL]</B>  [onoff] true to enable, false otherwise</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets this seat to be occupied/disabled (for players.<BR><B>EXAMPLE:  </B>vehicle SetSeatOccupied( 2, true )<BR><B>NOTES:  </B>For players only, the AI pay attention to vehicle.usedPositions[] = true/false<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetSpeed(<I>&lt;speed&gt;</I>,<I>[acceleration]</I>,<I>[deceleration]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;speed&gt; The speed of the vehicle in miles per hour<LI>        <B>[OPTIONAL]</B>  [acceleration] The acceleration of the vehicle in miles per hour per second<LI>        <B>[OPTIONAL]</B>  [deceleration] Deceleration. If not specified, set to be equal to half of accleration</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the speed and acceleration for this vehicle.<BR><B>EXAMPLE:  </B>self SetSpeed( 60, 15, 5 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetSpeedImmediate(<I>&lt;speed&gt;</I>,<I>[acceleration]</I>,<I>[deceleration]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;speed&gt; The speed of the vehicle in miles per hour<LI>        <B>[OPTIONAL]</B>  [acceleration] The acceleration of the vehicle in miles per hour per second<LI>        <B>[OPTIONAL]</B>  [deceleration] Deceleration. If not specified, set to be equal to half of accleration</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the speed and acceleration for this vehicle instantaneously. Direction will be toward the goal direction if there is a goal, otherwise the current direction.<BR><B>EXAMPLE:  </B>self setspeedimmediate(60, 15, 5)<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetSwitchNode(<I>&lt;source node&gt;</I>,<I>&lt;dest node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;source node&gt; The switch source node<LI>        <B>[MANDATORY]</B>  &lt;dest node&gt; The switch destination node.</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets a switch node for this vehicle.<BR><B>EXAMPLE:  </B>tank2 SetSwitchNode( tank2snode1, tank2snode2 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetTargetYaw(<I>&lt;yaw&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;yaw&gt; The yaw direction of the target</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the target yaw direction for this vehicle. Goal yaw has priority over target yaw.<BR><B>EXAMPLE:  </B>level.flak1 SetTargetYaw( vec1 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetTurningAbility(<I>&lt;turning ability&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;turning ability&gt; Between 0.001 and 1.0. Defaults to 0.5</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>If this is higher, helicopters can make sharper turns to match goal positions better.<BR><B>EXAMPLE:  </B>self SetTurningAbility( 0.9 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetTurretTargetEnt(<I>&lt;target entity&gt;</I>,<I>[target offset]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target entity&gt; The target.<LI>        <B>[OPTIONAL]</B>  [target offset] The target offset.</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the target entity for this vehicle turret.<BR><B>EXAMPLE:  </B>eFlak88 SetTurretTargetEnt( eFlaktarget, eFlaktarget.origin )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetTurretTargetRelativeAngles(<I>&lt;relative angles&gt;</I>,<I>[turret index]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;relative angles&gt; The target angle<LI>        <B>[OPTIONAL]</B>  [turret index] 0 for turret, 1-4 for gunners</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the target entity for this vehicle turret.<BR><B>EXAMPLE:  </B>eFlak88 SetTurretTargetEnt( eFlaktarget, eFlaktarget.origin )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetTurretTargetVec(<I>&lt;target position&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;target position&gt; The position of the target</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the target position for this vehicle turret.<BR><B>EXAMPLE:  </B>level.flak1 SetTurretTargetVec( vec1 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetVehGoalPos(<I>&lt;goalpos&gt;</I>,<I>[stopAtGoal]</I>,<I>[usepath]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;goalpos&gt; The goal position<LI>        <B>[OPTIONAL]</B>  [stopAtGoal] Whether the vehicle should slow down to stop at the goal position<LI>        <B>[OPTIONAL]</B>  [usepath] set to 1 to use pathfinding</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the target position for this vehicle. Returns true if it can find a path.  If it fails to find a path the vehicle will be stopped.<BR><B>EXAMPLE:  </B>tank SetVehGoalPos( (0, 0, 0), 1 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetVehicleAvoidance(<I>&lt;enabled&gt;</I>,<I>[radius]</I>,<I>[priority]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;enabled&gt; True to enable avoidance, false otherwise<LI>        <B>[OPTIONAL]</B>  [radius] The avoidance radius<LI>        <B>[OPTIONAL]</B>  [priority] Vehicles will avoid everything that is the same priority or higher.  Default priority is 1.</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Turns on and off vehicle avoidance<BR><B>EXAMPLE:  </B>vehicle SetVehicleAvoidance( true, 50 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetVehicleForDropDeploy()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set vehicle properties so that it can be dropped into a map.<BR><B>EXAMPLE:  </B>raps SetVehicleForDropDeploy()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetVehicleManualControl(<I>&lt;enabled&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;enabled&gt; True to enable vehicle  hkai behavior, false otherwise</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Turns on and off vehicle hkai behavior. Not to be confused with UseVehicle()<BR><B>EXAMPLE:  </B>vehicle SetVehicleManualControl( true )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetVehicleType(<I>&lt;type&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;type&gt; The type name</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the vehicles type.<BR><B>EXAMPLE:  </B>plane SetVehicleType("f35_vtol")<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetVehMaxSpeed(<I>&lt;speed&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;speed&gt; The speed to set</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>overrides the max speed for this vehicle.<BR><B>EXAMPLE:  </B>self SetVehMaxSpeed( 45 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetVehVelocity(<I>&lt;velocity&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;velocity&gt; The vehicle velocity</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the linear velocity on a vehicle/s.<BR><B>EXAMPLE:  </B>self SetVehVelocity( (45, 0, 0) )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetVehWeapon(<I>&lt;weapon name&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon name&gt; The name of the weapon</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Set the vehicle's weapon<BR><B>EXAMPLE:  </B>chopper setVehWeapon( "AGM_114" )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SetYawSpeed(<I>&lt;speed&gt;</I>,<I>&lt;acceleration&gt;</I>,<I>[deceleration]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;speed&gt; The speed of the vehicle in angles per second<LI>        <B>[MANDATORY]</B>  &lt;acceleration&gt; The acceleration of the vehicle in angles per second^2<LI>        <B>[OPTIONAL]</B>  [deceleration] Deceleration. If not specified, set to be equal to acceleration</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Sets the yaw speed for this vehicle.<BR><B>EXAMPLE:  </B>self SetYawSpeed( 120, 60 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; StartPath()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Starts the vehicle following this path.<BR><B>EXAMPLE:  </B>bomber StartPath()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; StopFireWeapon()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Stop firing the vehicle's main weapon<BR><B>EXAMPLE:  </B>nFlak StopFireWeapon()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; SwitchStartNode(<I>&lt;source node&gt;</I>,<I>&lt;dest node&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;source node&gt; The start source node<LI>        <B>[MANDATORY]</B>  &lt;dest node&gt; The start destination node.</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Swaps the start node for this vehicle.<BR><B>EXAMPLE:  </B>tank2 SwitchStartNode( tank2snode1, tank2snode2 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; TakePlayerControl()</H1><OL><UL></UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>You call this function to take control away from a player.<BR><B>EXAMPLE:  </B>cobra TakePlayerControl()<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; UseVehicle(<I>&lt;user entity&gt;</I>,<I>&lt;seat&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;user entity&gt; The player to use the vehicle<LI>        <B>[MANDATORY]</B>  &lt;seat&gt; 0 driver, 1-4 gunners, 5-10 passengers</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>same as useby except you can specify a seat, 0 driver, 1-4 gunners<BR><B>EXAMPLE:  </B>lvt usevehicle( player, 2 )<BR></OL><P>
<HR><H1>void &lt;vehicle&gt; VehDriverAimAtCrosshairs(<I>&lt;AimAtCrosshairs&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;AimAtCrosshairs&gt; True to aim the turret at the crosshairs</UL><B>CATEGORY:  </B>Vehicle<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Enables or disables the driver turret aiming at the crosshairs (aiming at the crosshairs overrides all other aim targets and is the default behavior)<BR><B>EXAMPLE:  </B>vehicle VehDriverAimAtCrosshairs( false )<BR></OL><P>
<HR><H1>void EnumerateWeapons(<I>&lt;weapon type&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;weapon type&gt; The type of weapon to return(weapon or weaponfull)</UL><B>CATEGORY:  </B>Weapon<BR><B>CLIENT/SERVER:  </B>Both<BR><B>SUMMARY:  </B>Return an array of weapon names for the weapons of weapon type in fastfile<BR><B>EXAMPLE:  </B>a_weapons = EnumerateWeapons( "weapon" )<BR></OL><P>
<HR><H1>void Missile_CreateAttractorEnt(<I>&lt;entity&gt;</I>,<I>&lt;strength&gt;</I>,<I>&lt;affectdist&gt;</I>,<I>&lt;affectAllProjectiles&gt;</I>,<I>&lt;alert range&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The entity that is to be an attractor<LI>        <B>[MANDATORY]</B>  &lt;strength&gt; The strength of the attractor (maximum acceleration it can apply to a missile)<LI>        <B>[MANDATORY]</B>  &lt;affectdist&gt; The effective distance at which the missile can be affected.  The effect of the attractor falls off from &lt;strength&gt; to zero from the center to this distance away from the center.<LI>        <B>[OPTIONAL]</B>  &lt;affectAllProjectiles&gt; If set it will affect all projectiles inculding grenades and guided missiles.<LI>        <B>[OPTIONAL]</B>  &lt;alert range&gt; If set it send notify when missile breaches range(but will not repulse).</UL><B>CATEGORY:  </B>Weapon<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Creates a missile attractor at the origin of an entity<BR><B>EXAMPLE:  </B>attractor = Missile_CreateAttractorEnt( enemy_chopper, 10000, 6000 )<BR></OL><P>
<HR><H1>void Missile_CreateAttractorOrigin(<I>&lt;origin&gt;</I>,<I>&lt;strength&gt;</I>,<I>&lt;affectDist&gt;</I>,<I>&lt;affectAllProjectiles&gt;</I>,<I>&lt;alert range&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The center of the attractor<LI>        <B>[MANDATORY]</B>  &lt;strength&gt; The strength of the attractor (maximum acceleration it can apply to a missile)<LI>        <B>[MANDATORY]</B>  &lt;affectDist&gt; The effective distance at which the missile can be affected.  The effect of the attractor falls off from &lt;strength&gt; to zero from the center to this distance away from the center.<LI>        <B>[OPTIONAL]</B>  &lt;affectAllProjectiles&gt; If set it will affect all projectiles inculding grenades and guided missiles.<LI>        <B>[OPTIONAL]</B>  &lt;alert range&gt; If set it send notify when missile breaches range(but will not repulse).</UL><B>CATEGORY:  </B>Weapon<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Creates a missile attractor at the given location<BR><B>EXAMPLE:  </B>attractor = Missile_CreateAttractorOrigin( (100, 350, 10), 10000, 6000 )<BR></OL><P>
<HR><H1>void Missile_CreateRepulsorEnt(<I>&lt;entity&gt;</I>,<I>&lt;strength&gt;</I>,<I>&lt;affectDist&gt;</I>,<I>[affectAllProjectiles]</I>,<I>[alert range]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;entity&gt; The entity that is to be a repulsor<LI>        <B>[MANDATORY]</B>  &lt;strength&gt; The strength of the repulsor (maximum acceleration it can apply to a missile)<LI>        <B>[MANDATORY]</B>  &lt;affectDist&gt; The effective distance at which the missile can be affected.  The effect of the attractor falls off from &lt;strength&gt; to zero from the center to this distance away from the center.<LI>        <B>[OPTIONAL]</B>  [affectAllProjectiles] If set it will affect all projectiles inculding grenades and guided missiles.<LI>        <B>[OPTIONAL]</B>  [alert range] If set it send notify when missile breaches range(but will not repulse).</UL><B>CATEGORY:  </B>Weapon<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Creates a missile repulsor at the origin of an entity<BR><B>EXAMPLE:  </B>repulsor = Missile_CreateRepulsorEnt( enemy_chopper, 10000, 6000 )<BR></OL><P>
<HR><H1>void Missile_CreateRepulsorOrigin(<I>&lt;origin&gt;</I>,<I>&lt;strength&gt;</I>,<I>&lt;affectDist&gt;</I>,<I>[affectAllProjectiles]</I>,<I>[alert range]</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;origin&gt; The center of the Repulsor<LI>        <B>[MANDATORY]</B>  &lt;strength&gt; The strength of the Repulsor (maximum acceleration it can apply to a missile)<LI>        <B>[MANDATORY]</B>  &lt;affectDist&gt; The effective distance at which the missile can be affected.  The effect of the attractor falls off from &lt;strength&gt; to zero from the center to this distance away from the center.<LI>        <B>[OPTIONAL]</B>  [affectAllProjectiles] If set it will affect all projectiles inculding grenades and guided missiles.<LI>        <B>[OPTIONAL]</B>  [alert range] If set it send notify when missile breaches range(but will not repulse).</UL><B>CATEGORY:  </B>Weapon<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Creates a missile Repulsor at the given location<BR><B>EXAMPLE:  </B>repulsor = Missile_CreateRepulsorOrigin( (100, 350, 10), 10000, 6000 )<BR></OL><P>
<HR><H1>void Missile_DeleteAttractor(<I>&lt;attractor&gt;</I>)</H1><OL><UL><LI>        <B>[MANDATORY]</B>  &lt;attractor&gt; The attractor or repulsor</UL><B>CATEGORY:  </B>Weapon<BR><B>CLIENT/SERVER:  </B>Server<BR><B>SUMMARY:  </B>Deletes a missile attractor or repulsor<BR><B>EXAMPLE:  </B>Missile_DeleteAttractor( attractor )<BR></OL><P>
<HR></HTML>